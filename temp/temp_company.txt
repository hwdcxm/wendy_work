Compiling...
Log.cpp
E:\wendy_work\MsEdit_Wendy\Log.cpp(23) : error C2653: 'CWrapperPath' : is not a class or namespace name
E:\wendy_work\MsEdit_Wendy\Log.cpp(23) : error C2065: 'GetExtPath' : undeclared identifier
E:\wendy_work\MsEdit_Wendy\Log.cpp(90) : error C2653: 'CWrapperPath' : is not a class or namespace name
E:\wendy_work\MsEdit_Wendy\Log.cpp(90) : error C2065: 'SpitePath' : undeclared identifier
E:\wendy_work\MsEdit_Wendy\Log.cpp(217) : error C2653: 'CWrapperPath' : is not a class or namespace name


也不用百里挑一， 看懂就过。

#ifndef #define #endif 防止头文件被重复引用
https://www.cnblogs.com/limera/p/5658466.html
其实“被重复引用”是指一个头文件在同一个cpp文件中被include了多次，这种错误常常是由于include嵌套造成的。比如：存在a.h文件#include "c.h"而此时b.cpp文件导入了#include "a.h" 和#include "c.h"此时就会造成c.h重复引用。
头文件被重复引用引起的后果：
有些头文件重复引用只是增加了编译工作的工作量，不会引起太大的问题，仅仅是编译效率低一些，但是对于大工程而言编译效率低下那将是一件多么痛苦的事情。
有些头文件重复包含，会引起错误，比如在头文件中定义了全局变量(虽然这种方式不被推荐，但确实是C规范允许的)这种会引起重复定义。


c++ 防止头文件重复include问题
https://zhidao.baidu.com/question/112685790.html
#ifndef的方式依赖于宏名字不能冲突，这不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件不会被不小心同时包含。当然，缺点就是如果不同头文件的宏名不小心“撞车”，可能就会导致头文件明明存在，编译器却硬说找不到声明的状况
#pragma once则由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。带来的好处是，你不必再费劲想个宏名了，当然也就不会出现宏名碰撞引发的奇怪问题。对应的缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名碰撞引发的“找不到声明”的问题，重复包含更容易被发现并修正。
方式一由语言支持所以移植性好，方式二 可以避免名字冲突。



如何防止头文件被重复包含或引用?
https://blog.csdn.net/sharp_up/article/details/71971184
// Test1.h
#ifndefine ?TEST1_H
#defineTEST1_H
...
#endif

// Test2.h
#pragma once
...

// Test.cpp
#include "Test1.h"// line 1
#include "Test1.h"// line 2
#include "Test2.h"// line 3
#include "Test2.h"// line 4 这里的Test2.h是同一物理文件

预处理器在执行这四句的时候，先打开Test1.h然后发现里面的宏TEST1_H没有被定义，所以会包含这个文件，
第二句的时候，同样还是会打开Test1.h的发现宏已定义，就不包含该文件按了。
第三句时，发现之前没有包含Test2,h则会把该文件包含进来，
执行第四句的时候，发现该文件已经被包含了，所以不用打开就直接跳过了
二、条件编译
#include"a.h"
#include"b.h"
看上去没什么问题。如果a.h和b.h都包含了一个头文件x.h。那么x.h在此也同样被包含了两次，只不过它的形式不是那么明显而已。
多重包含在绝大多数情况下出现在大型程序中，它往往需要使用很多头文件，因此要发现重复包含并不容易。要解决这个问题，我们可以使用条件编译。如果所有的头文件都像下面这样编写:
#ifndef _HEADERNAME_H
#define _HEADERNAME_H

由于工程中的每个.c文件都是独立的解释的，即使头文件有
#ifndef _TEST_H_ #define _TEST_H_ .... #enfif
在其他文件中只要包含了test.h就会独立的解释,然后每个.c文件生成独立的标示符。
在编译器链接时，就会将工程中所有的符号整合在一起，由于文件中有重名变量，于是就出现了重复定义的错误。

解决方法:
在.c文件中定义变量，然后再建一个头文件(.h文件)，在所有的变量声明前加上extern，注意这里不要对变量进行的初始化。
然后在其他需要使用全局变量的.c文件中包含.h文件。编译器会为.c生成目标文件，然后链接时，
如果该.c文件使用了全局变量，链接器就会链接到定义变量的.c文件?

问题扩展：?变量的声明有两种情况:
(1) 一种是需要建立存储空间的(定义、声明)。例如：int a在声明的时候就已经建立了存储空间。?
(2) 另一种是不需要建立存储空间的(声明)。例如：extern int a其中变量a是在别的文件中定义的。
前者是"定义性声明(defining declaration)"或者称为"定义(definition)",而后者是"引用性声明(referncingdeclaration)"。
从广义的角度来讲声明中包含着定义，但是并非所有的声明都是定义，例如:int a它既是声明，同时又是定义。
然而对于extern a来讲它只是声明不是定义。一般的情况下我们常常这样叙述，把建立空间的声明称之为"定义"，
而把不需要建立存储空间称之为"声明"。很明显我们在这里指的声明是范围比较窄的，也就是说非定义性质的声明。

extern int A; //这是个声明而不是定义，声明A是一个已经定义了的外部变量
                 //注意：声明外部变量时可以把变量类型去掉如：extern A;

用static来声明一个变量的作用有二：
    (1) 对于局部变量用static声明，则是为该变量分配的空间在整个程序的执行期内都始终存在
    (2) 外部变量用static来声明，则该变量的作用只限于本文件模块

另外一个好处是减小类A的大小
前置声明解决两个类的互相依赖
前置声明只能作为指针或引用，不能定义类的对象，自然也就不能调用对象中的方法了。



#define #if #ifdef #ifndef 作用和区别
https://blog.51cto.com/12104971/1857992
如果#ifndef…#endif在头文件中，千万不要忽略了头件的中的#ifndef，这是一个很关键的东西。
比如你有两个C文件，这两个C文件都include了同一个头文件。
而编译时，这两个C文件要一同编译成一个可运行文件，于是问题来了，大量的声明冲突。 


#ifndef 与 #if !define区别
https://blog.csdn.net/u011642774/article/details/71729148
我们要检查a是否定义（假设我们已经记不着这点了）,或者我们要给a一个不同的值，就加入如下句子 
#if defined a 
#undef a 
#define a 200 
#endif 
#error XXXX 
是用来产生编译时错误信息XXXX的，一般用在预处理过程中； 


"#if define A" 与 "#if defined A" 的区别 [问题点数：60分，结帖人zhaoxuxing]
https://bbs.csdn.net/topics/380226986
1/" #if define ABC " 这是一种错误的写法
2/" #elif define ABC " 这是一种错误的写法
这两种写法可能 能通过编译器，但执行的结果却是错误的！！！ 既然是错误的怎样改正呢？往下看
3/" #ifdef ABC " == " #if defined ABC " 这才是正确的写法 


#if、#ifdef、#if defined之间的区别
https://www.iteye.com/blog/quanminchaoren-1870977
#if的使用说明
#if的后面接的是表达式

#if (MAX==10)||(MAX==20)
 code...
#endif
它的作用是：如果(MAX==10)||(MAX==20)成立，那么编译器就会把其中的#if 与 #endif之间的代码编译进去（注意：是编译进去，不是执行！！）

#if defined的使用
#if后面接的是一个宏。

#if defined (x)
    ...code...
#endif
这个#if defined它不管里面的“x”的逻辑是“真”还是“假”它只管这个程序的前面的宏定义里面有没有定义“x”这个宏，如果定义了x这个宏，那么，编译器会编译中间的…code…否则不直接忽视中间的…code…代码。

另外 #if defined(x)也可以取反，也就用 #if !defined(x)

#ifdef的使用
#ifdef的使用和#if defined()的用法一致
#ifndef又和#if !defined()的用法一致。

最后强调两点：
第一：这几个宏定义只是决定代码块是否被编译！
第二：别忘了#endif


使用#if defined()组成复杂的预编译控制指令
https://blog.csdn.net/david_xtd/article/details/12652197
#ifdef只能判断单一的宏是否定义，而#if defined()可以组成复杂的判别条件；


对于单一的宏AAA来说，#ifdef AAA和#if defined(AAA)是完全相同的。


而要组成复杂的判别条件，用#if defined()就灵活方便了，比如：#if defined(AAA) && (BBB >= 10)

如果改用#ifdef则没法表示条件BBB>=10了。

#ifndef 与 #if !defined有区别吗？该怎么解决
https://www.cnblogs.com/lycrfx/articles/5766103.html
基本上一样，不过后者的应用范围更大，可以支持多个预编译变量的检查： 
#if (!defined(_DEBUG) && defined(USE_MYLIB)) 
.......... 
#endif 

这种情况用前一种方式就只能写一个嵌套的条件判断： 
#ifndef _DEBUG 
#ifdef USE_MYLIB 
................ 
#endif 
#endif


闰年的定义？？
https://zhidao.baidu.com/question/167039572.html
①、普通年能被4整除且不能被100整除的为闰年。（如2004年就是闰年,1901年不是闰年）地球公转示意图
②、世纪年能被400整除的是闰年。(如2000年是闰年，1900年不是闰年) 
③、对于数值很大的年份能整除3200,但同时又能整除172800则又是闰年.(如172800年是闰年，86400年不是闰年）
闰年
https://baike.baidu.com/item/%E9%97%B0%E5%B9%B4/27098
闰年是怎么定义的
https://zhidao.baidu.com/question/28992622.html

白增多
https://baike.baidu.com/item/%E7%99%BD%E5%B8%A6%E8%BF%87%E5%A4%9A/7716427?fr=aladdin
先查后做(v ok)

#ifdef #if defined #ifndef和#if !defined区别
https://blog.csdn.net/tmd_mcu/article/details/78140229
预处理指令包含了以下内容：
　　1，宏定义   #define
　　2，文件包含 #include
　　3，条件编译 #if
　　#ifdef
　　#ifndef
　　#if defined
　　#if !defined
　　#elif
　　#else
　　#endif
　　#undef
　　指令都是以#开始的
宏可以带参数，也是常说的宏函数
　　#define 标识符（x1,x2...） 替换列表
　　特别注意的是标识符和(之间不能有空格，圆括号是必须的。
　　还可以写得更复杂一点，比如我们来写一个宏函数，用它来验证一个日期是否合法
　　#define ISLEAP(y) ((y)%4==0&&(y)%100!=0||(y)%400==0)
　　#define ISSMALL(m) ((m)==4||(m)==6||(m)==9||(m)==11)
　　#define NORMAL(m) (ISSMALL(m)?30:31)
　　#define DAYS(y,m) ((m)==2?28+ISLEAP(y):NORMAL(m))
　　#define IN(x, from,to) ((x)>=(from)&&(x)<=(to))
　　#define VALID(y,m,d) ((y)>1600&&IN(m,1,12)&&IN(d,1,DAYS(y,m)))

　　#if (comdition)
　　{//语句##；}
　　#endif

　#if  常量表达式
　　常量表达式为0时，预处理器删除#if 和#endif中间的代码
　　#if 会把没有定义过的标准符视做为0，　如果没有定义DEBUG, 则
　　测试#if DEBUG 会失败，但#if !DEBUG会成功。

　　可以用宏来定义文件名：
　　#if define(IA32)
　　#define CPU_FILE “ia32.h”
　　#elif defined(IA64)
　　#deifine CPU_FILE “ia64.h”
　　#elif defined(AMD64)
　　#define CPU_FILE “amd64.h”
　　#endif
　　#include CPU_FILE

　　#if defined VALUE              // 检验VALUE是否被定义 ，如果被定义
　　#undef VALUE            // 解除语句定义
　　#define VALUE 1000            //  重新定义VALUE 为1000
　　#endif

　　如果检验没有定义，可以这样写：
　　#ifndef VALUE               // 如果VALUE没有被定义
　　#define VALUE 1000          //  定义VALUE 为1000
　　#endif

　　#undef为解除定义;
　　#ifndef是if not defined的缩写，也可以写成#if !defined 即如果没有定义;
　　#ifdef是if defined的缩写，也可以写成#if defined 即检查是否定义过;

总结：
#ifdef只能判断单一的宏是否定义，而#if defined()可以组成复杂的判别条件；
对于单一的宏AAA来说，#ifdef AAA和#if defined(AAA)是完全相同的。
而要组成复杂的判别条件，用#if defined()就灵活方便了，比如：#if defined(AAA) && (BBB >= 10)
如果改用#ifdef则没法表示条件BBB>=10了。


C:\Users\Wendy\Desktop\temp\temp.txt
--->
E:\wendy_work\temp\temp_company.txt

军事管制

意料之外，预料之中
https://news.sina.cn/gn/2020-02-09/detail-iimxxstf0024695.d.html
李文亮是在1月8日接诊一位82岁的病人时感染新冠病毒的

幽螺莎星爆珠丸 幽门螺杆菌（简称HP）。
加上价格也很赞，一盒里面有30粒，只要39.9元，现在还有买一送一的活动，也就是39.9元到手60粒，简直不要太划算！
口气清新，你我更亲近！
两盒只要39.9元
买三送一，59.9元/4盒
买五送三，99.9元/8盒

湖北省卫健委书记被免职 昨日还在参加防治工作会
https://news.163.com/20/0211/10/F53LSRO70001899O.html

湖北省卫健委两名主要官员被免职
https://www.sohu.com/a/372114557_123753

湖北省l健委、主任被免，疫情的S金防控期楹e^？
https://news.fx168.com/opinion/column/gwzj/2002/3614068.shtml

湖北省卫健委两官员被免职！预计武汉所有疑似患者检测今日清零
https://3g.163.com/news/article/F541BCGE0517BMJU.html

湖北省卫健委党组书记、主任同时被免：还会有谁被问责？
http://blog.sina.cn/dpool/blog/s/blog_537368000102yrwf.html?md=gd&wm=3049_0007
而在武汉、湖北以外，据有关报道，除了黄冈市卫健委女主任唐某某被指一问三不知被免职外，2月10日，呼和浩特市已经被公示拟提升为副厅级的卫健委女主任也被免职。而2月11日一早被公开的“湖北省卫健委党组书记主任双双被免职”，恐怕是到目前为止，被问责职务最高的了。

专访卫健委派武汉第二批专家：为何没发现人传人？
http://finance.sina.com.cn/wm/2020-02-26/doc-iimxxstf4577235.shtml

20天，湖北换了3个卫健委主任！
https://news.sina.cn/gn/2020-02-21/detail-iimxyqvz4703931.d.html?from=wap

湖北被免职卫健委女主任：管理学教授 曾在高校任教15年
http://news.ifeng.com/c/7txNnFZqVWD
据央视新闻，2月10日，湖北省委常委会决定：免去张晋的省卫生健康委员会党组书记职务；免去刘英姿的省卫生健康委员会主任职务；上述两职务，由新到任的省委常委王贺胜同志兼任

湖北省卫健委书记被免职 昨日还在参加防治工作会
https://news.163.com/20/0211/10/F53LSRO70001899O.html
据央视报道，2月10日，湖北省委常委会决定，省委常委王贺胜兼任湖北省卫健委党组书记和主任。
免去张晋、刘英姿湖北省卫生健康委员会党组书记和主任职务。
您可透^Yg[器，惠r享用tt18.com及tt28.com 所提供之W上Y服眨热萜贩N繁多，其中有：

港信软件(深圳)有限公司
https://xin.baidu.com/company_detail_31982401048121

捷利港信软件(深圳)有限公司
https://www.11467.com/qiye/27552884.htm

E:\wen_test\dlgtest1\dlgtest1Dlg.cpp(119) : error C2065: 'printf' : undeclared identifier
D:\Program Files\Microsoft Visual Studio\VC98\MFC\Include\AFX.H
// Other includes from standard "C" runtimes
#ifndef _INC_STRING
	#include <string.h>
#endif
#ifndef _INC_STDIO
	//#include <stdio.h>
#endif

眼镜架结构详解 眼镜框各部分的功能介绍
https://www.maigoo.com/goomai/108147.html
一副眼镜架通常由镜圈、鼻托、桩头和镜脚等主要部分构成，除上述部件外，还有脚套、托叶螺丝、铰链螺丝等。

2020.03.11

---- stdio.h Matches (15 in 13 files) ----
Afx.h (vc98\mfc\include):	#include <stdio.h>
Atlbase.h (vc98\atl\include):#include <stdio.h>
Cstdio (vc98\include): #include <stdio.h>
Cstdio (vc98\include): #include <stdio.h>
Dprintf.h (vc98\include):#include <stdio.h>
Edk.h (vc98\include):#include <stdio.h>
Edkdebug.h (vc98\include):#include <stdio.h>
Isapi.cpp (vc98\mfc\src):#include <stdio.h>
Resapi.h (vc98\include):#include "stdio.h"
Snados.h (vc98\include):/* Echo the format of the ifdefs that stdio.h uses */
Stdio.h (vc98\include):*stdio.h - definitions/declarations for standard I/O routines
Stdiostr.h (vc98\include):#include <stdio.h>
Utassert.h (vc98\include):#include <stdio.h>
Wchar.h (vc98\include):*       Note: keep in sync with ctype.h, stdio.h, stdlib.h, string.h, time.h.
Wchar.h (vc98\include):/* also declared in stdio.h */




Find Source PRINTF.C.

printf源码
http://blog.chinaunix.net/uid-24567872-id-87686.html

E:\wendy_work\MsEdit_Wendy\StdAfx.h

// wendy 2020.03.10
#include "Datadef.h"
#include "Resource.h"

指数ETF或行业ETF

我自认为没本事能给大家推荐股票保证稳赢，所以我推荐指数ETF或行业ETF，至少不会被坑（不停牌，不暴雷，寿与天齐）

又一个被训诫的女医生（艾芬）浮出水面
http://www.cbfau.com/cbf-201585990.html

struct AFX_MSGMAP_ENTRY
{
	UINT nMessage;   // windows message
	UINT nCode;      // control code or WM_NOTIFY code
	UINT nID;        // control ID (or 0 for windows messages)
	UINT nLastID;    // used for entries specifying a range of control id's
	UINT nSig;       // signature type (action) or pointer to message #
	AFX_PMSG pfn;    // routine to call (or special value)
#ifdef _AFXDLL
#define BEGIN_MESSAGE_MAP(theClass, baseClass) \
	const AFX_MSGMAP* PASCAL theClass::_GetBaseMessageMap() \
		{ return &baseClass::messageMap; } \
	const AFX_MSGMAP* theClass::GetMessageMap() const \
		{ return &theClass::messageMap; } \
	AFX_COMDAT AFX_DATADEF const AFX_MSGMAP theClass::messageMap = \
	{ &theClass::_GetBaseMessageMap, &theClass::_messageEntries[0] }; \
	AFX_COMDAT const AFX_MSGMAP_ENTRY theClass::_messageEntries[] = \
	{ \

#define ON_COMMAND(id, memberFxn) \
	{ WM_COMMAND, CN_COMMAND, (WORD)id, (WORD)id, AfxSig_vv, (AFX_PMSG)&memberFxn },


#define END_MESSAGE_MAP() \
		{0, 0, 0, 0, AfxSig_end, (AFX_PMSG)0 } \
	}; \

#define PASCAL      __stdcall

struct AFX_MSGMAP
{
#ifdef _AFXDLL
	const AFX_MSGMAP* (PASCAL* pfnGetBaseMap)();
#else
	const AFX_MSGMAP_ENTRY* lpEntries;
};

d:\Program Files\Microsoft Visual Studio\VC98\MFC\Include\AFXWIN.H
#ifdef _AFXDLL
#define DECLARE_MESSAGE_MAP() \
private: \
	static const AFX_MSGMAP_ENTRY _messageEntries[]; \
protected: \
	static AFX_DATA const AFX_MSGMAP messageMap; \
	static const AFX_MSGMAP* PASCAL _GetBaseMessageMap(); \
	virtual const AFX_MSGMAP* GetMessageMap() const; \

#else

BOOL CMsEdit_WendyApp::InitApplication() 
{
	// TODO: Add your specialized code here and/or call the base class
	
#ifdef _AFXDLL
	int i;
#else
	asdfadf
#endif
	return CWinApp::InitApplication();
}


D:\Program Files\Microsoft Visual Studio\VC98\MFC\SRC\APPMODUL.CPP
extern int AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPTSTR lpCmdLine, int nCmdShow);

extern "C" int WINAPI
_tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LP InModalStateTSTR lpCmdLine, int nCmdShow)
{
	// call shared/exported WinMain
	return AfxWinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow);
}
--->
D:\Program Files\Microsoft Visual Studio\VC98\MFC\SRC\WINMAIN.CPP
int AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPTSTR lpCmdLine, int nCmdShow)
{
	ASSERT(hPrevInstance == NULL);

	int nReturnCode = -1;
	CWinThread* pThread = AfxGetThread();
	CWinApp* pApp = AfxGetApp();

	// AFX internal initialization
	if (!AfxWinInit(hInstance, hPrevInstance, lpCmdLine, nCmdShow))
		goto InitFailure;

	// App global initializations (rare)
	if (pApp != NULL && !pApp->InitApplication())
		goto InitFailure;

	// Perform specific initializations
	if (!pThread->InitInstance())
	{
		if (pThread->m_pMainWnd != NULL)
		{
			TRACE0("Warning: Destroying non-NULL m_pMainWnd\n");
			pThread->m_pMainWnd->DestroyWindow();
		}
		nReturnCode = pThread->ExitInstance();
		goto InitFailure;
	}
	nReturnCode = pThread->Run();

InitFailure:
...
	AfxWinTerm();
	return nReturnCode;
}



D:\Program Files\Microsoft Visual Studio\Common\MSDev98\BIN
--->> *.dll 复制缺少的dll动态库文件过去
D:\softs\VC6免安装绿色版\VC6\Common\MSDev98\Bin
(v ok)

用C++的时候，运行的时候总出现SHSQL,DLL 必需的文件不能加载，请重新安装Microsoft Visual C++
https://zhidao.baidu.com/question/386513237.html
你是不是安装的绿色版VC？一般完全安装的VC不会出现这个提示。
绿色版的VC有可能安装的位置（比如D盘）和它自己默认的位置（比如C盘）不一致，导致一些关键的DLL找不到（文件存在，但是它没找到）
可以按照以下方法解决：
点击VC主窗口中的“TOOLS（工具）”―>“Option（选项）”― >“Directories（目录）”重新设置“Excutable Fils、Include Files、Library Files、Source Files”这4个路径。正常情况可能就改个盘符。然后所有硬盘搜索SHSQL.DLL，找到后放进已安装的vc->common->MSDev98->Bin下就可以了。如果没找到，那就在网上搜一个下载，应该很好解决~

VC++6.0 Project Settings --> 选择"Link"属性页
Project Options中将/subsystem:console改成/subsystem:window， 这个选项在哪里？我是中文版的， 找了半天没有啊！！！

关于不同的程序入口，main(), _tmain()，WinMain()，wmain()？
https://blog.csdn.net/camel20/article/details/8481442
我读了MSDN里面的讲解才弄出点眉目了，其实我们以前所写的以main()函数开始的程序都是一个半成品，剩下的也是与系统息息相关的工作由编译器帮我们代劳了。怎么回事呢？编译器是如何帮我们代劳的呢？那么程序被系统加载时，准确的说是被系统中的加载器加载时又是如何知道编译器在我们写的程序上做了手脚呢？难道编译器和加载器之间有什么协定吗？这一些列的问题，做为刚入行的你是否在心里问过自己没有！？

???我们以前写的程序在编译器编译成为一个模块（可能是obj文件或其他形式），然后链接器会将一些所需要的库文件和刚才编译器生成的文件进行链接，最终生成一个exe文件，在所链接的库文件中就包含CRT运行时库，这就是我们今天谈论的主角。在运行时库里面有好一个已经定义如下的函数函数：

（1）mainCRTStartup（或wmainCRTStartup）???????//使用/SUBSYSTEM:CONSOLE 的应用程序

（2）WinMainCRTStartup（或 wWinMainCRTStartup） //使用/SUBSYSTEM:WINDOWS 的应用程序

（3）_DllMainCRTStartup????????????????????????//调用 DllMain（如果存在），DllMain 必须用 __stdcall 来定义

其中w开头的函数时unicode版本的,分割符‘//’后面的是入口点函数匹配的subsystem(msdn中查看subsystem)属性设置。

如果未指定 /DLL 或 /SUBSYSTEM （也就是subsystem选项）选项，则链接器将根据是否定义了 main 或WinMain 来选择子系统和入口点。 函数 main、WinMain 和 DllMain 是三种用户定义的入口点形式。

在默认情况下，如果你的程序中使用的是main()或_main()函数，这链接器会将你的使用（1）中的函数连接到你的exe中；如果你的函数是以WinWain（）函数开始的则连接器使用（2）中的函数连接进exe中；如果我们写的是DLL程序这连接进DLL的是（3）中的函数。

???用我们写的程序最终生成的exe执行时，一开始执行的就是上面的函数之一，而不是我们程序所写的main或WinMain等。那么链接器为什么要这样做呢？这就是因为我们写的程序必须要使用到各种各样的运行时库函数才能正常工作，所有在执行我们自己写程序之前必须要先准备好所需要的一切库，噢，明白了吧，之所以要链接它们是因为他们肩负着很重要的使命，就是初始化好运行时库，准备在我们的程序执行时调用。
...
修改入口点方法：proerties->Linker->Advanced->EntryPoint

如果函数与链接器的SubSystem的属性要一致的：

proerties->Linker->System->SubSystem

如果未指定 /DLL 或 /SUBSYSTEM 选项，则链接器将根据是否定义了 main 或 WinMain来选择子系统和入口点。 函数 main、WinMain 和 DllMain 是三种用户定义的入口点形式。

程序入口点
https://blog.csdn.net/H002399/article/details/46339877
WinMain()是WINDOWS的GUI程序入口,
wmain()是UNICODE版本的main(),
_tmain()是个宏,如果是UNICODE则他是wmain()否则他是main()
 ...

有关WinMainCRTStartup() 函数 [问题点数：0分]
https://bbs.csdn.net/topics/10406514
这个我好象见过有个程序是用汇编写的,最小有500多bytes吧,具体的忘记了,不好意思
WinMainCRTStartup其实是Windows 下 C Run-time 的入口点。
如果您的VC在安装时选择了C Run-time 的sourcecode，
那您可以在vc的目录中找到C Run-time 完整的sourcecode。
如果您觉得整个sourcecode过于庞大，您也可以选择一个小些的
C Run-time 的sourcecode进行阅读例如 tinylib。
tinylib更具体的说明请参考下面资料： 
http://www.microsoft.com/msj/defaulttop.asp?page=/msj/archive/s569.htm


关于main(),wmain(),winMain(),wWinMain(),_tmain(),_tWinMain()的理解。
https://blog.csdn.net/weixin_42732867/article/details/90202174
一般情况下，我们并不知道当前编译环境是否为unicode，这时候我们可以用_tmain()或_tWinMain()来代替main()/wmian()或者winMain()/wWinMain()，因为_tmain()和_tWinMain()函数会根据当前编译环境来决定调用对应的入口函数，比如用_tmain(),这样编译器会根据当前的编译环境是否为unicode来决定调用main()或者wmain(),如果编译器环境是unicode,则调用wmain(),否则调用main()函数。

? ? ?实际上，_tmain和_tWinMain都是宏定义，代码可以简单理解如下：

#ifdef _UNICODE
   #define _tmain     wmain
   #define _tWinMain  wWinMain
#else
   #define _tmain     main
   #define _tWinMain  winMain
 #endif
     这样编译器会自己根据当前编译环境是否为unicode来决定调用哪个入口函数，这样也是为了能够兼容unicode编译环境。
     注：以上为个人理解，如果有什么地方理解错误或者需要改进，希望各位大神不吝赐教！谢谢！ 


void CShowData::OnMenuitemInfo() 
{
	// TODO: Add your command handler code here

	pEINFO =  new CEINFO;

	m_list_data.GetItemText(m_indexOfCell.x,3,pEINFO->strTime,100);
	m_list_data.GetItemText(m_indexOfCell.x,4,pEINFO->strItemCode,100);

	pEINFO->Create(IDD_E_INFO);
	pEINFO->ShowWindow(SW_SHOW);
	
}

void CEINFO::OnClose() 
{
	// TODO: Add your message handler code here and/or call default
	CDialog::OnClose();
	DestroyWindow();
}

void CEINFO::PostNcDestroy() 
{
	// TODO: Add your specialized code here and/or call the base class
	CDialog::PostNcDestroy();
	if (AfxGetMainWnd()->IsWindowEnabled())
	{
		delete this;
	}
}
(v ok)


高信:
不会玩

awendy:
斗地主？象棋？ 


高信:
多年没玩了


awendy:
哦，那还是学习好吧，玩游戏没有进步的。玩个一百年一千年都是一个鸟样的。


awendy:
学习进步不同，一天一个样，学得多想法就多，业务门路就多.....


高信:
主要是没有那个闲情逸致



void CMsEdit_WendyDlg::OnRead() 
{...
	pShowData =  new CShowData;
	pShowData->Create(IDD_SHOWDATA);
	pShowData->ShowWindow(SW_SHOW);
...}

void CShowData::OnCancel() 
{
	// TODO: Add extra cleanup here
	
	CDialog::OnCancel();  //  availd for domodal dialog
	DestroyWindow();
}

void CShowData::PostNcDestroy() 
{
	// TODO: Add your specialized code here and/or call the base class
	CDialog::PostNcDestroy();
	if (AfxGetMainWnd()->IsWindowEnabled())
	{
			delete this;
	}
}
(v ok)

void CShowData::PostNcDestroy() 
{
	// TODO: Add your specialized code here and/or call the base class
	// //InModalState()
	//GetWindowWord(hWnd, GWW_HWNDPARENT);
	//GetParent(); ->IsWindowEnabled()
	//GetParent()->IsWindowEnabled(); v  GetOwner() AfxGetMainWnd()  this->GetParent()
	//或者也可以直接 ::FindWindow( )获取到对话框句柄 ，再::FromHandle( );  if (FromHandle(GetSafeHwnd())->IsWindowEnabled())
	//	if (!((CMsEdit_WendyDlg *)AfxGetMainWnd())->pShowData->IsWindowEnabled())
	if (AfxGetMainWnd()->IsWindowEnabled()) // (v ok)
	{
			delete this;
	}
	CDialog::PostNcDestroy();
}


vc 怎样取得一个模式对话框的指针
https://zhidao.baidu.com/question/554607433533632772.html
这要根据你打开对话框的方式了
比如
CMyDialog* dlg=new CMyDialog();
dlg->DoModal(); //dlg就是模态对话框的指针
或者也可以直接 ::FindWindow( )获取到对话框句柄 ，再::FromHandle( );
BOOL CWnd::IsWindowEnabled() const
{
	ASSERT(::IsWindow(m_hWnd)); 模式状态为真，非模式状态为假出错。
...}
void CShowData::PostNcDestroy() 
{
	// TODO: Add your specialized code here and/or call the base class
	//GetWindowWord(hWnd, GWW_HWNDPARENT);
	//GetParent(); ->IsWindowEnabled()
	//GetParent()->IsWindowEnabled(); v  GetOwner() AfxGetMainWnd()  this->GetParent()
	//或者也可以直接 ::FindWindow( )获取到对话框句柄 ，再::FromHandle( );  if (FromHandle(GetSafeHwnd())->IsWindowEnabled())
	if (!((CMsEdit_WendyDlg *)AfxGetMainWnd())->pShowData->IsWindowEnabled())
	{
			delete this;
	}


MFC获得主窗体和父窗体指针
https://www.cnblogs.com/cxchanpin/p/7306144.html
  MFC编程中经常遇到子窗体向父窗体传递⑹的情况，这就须要获得父窗体的指针。
        例：主对话框CMyMainDlg通过buttonButtonA进入对话框CMyParentDlg。CMyParentDlg在通过buttonButtonB进入对话框CMyChildDlg。如今须要在CMyChildDlg分别L问CMyParentDlg和CMyMainDlg的内容。须要在CMyChildDlg中增加下面两条语句：
        CMyMainDlg    *pMMD = (CMyMainDlg*)AfxGetMainWnd();     //获取主窗体指针
        CMyParentDlg *pMPD = (CMyParentDlg*)this->GetParent();   //获取父窗体指针

        当中，this代表当前窗体指针，指向CMyChildDlg。pMMD和pMPD便是指向主窗体和父窗体的指针。

vc 中如何获得最顶端得窗口指针（也许不是激活状态）
vc 中如何获得最顶端得窗口指针（也许不是激活状态）在vc中的GetForegroundWindow（）可以得到最顶端而且激活的窗口。而我现在需要得到最顶端但不激活的窗口（比如FlashGet的悬浮条）的窗口指针。

vc中如何获得当前窗口句柄 [问题点数：20分，结帖人hbtsm]
https://bbs.csdn.net/topics/20026627
this->m_hWnd;
m_hWnd;
this->GetSafeHwnd

VC中获取窗体句柄的各种方法
https://www.cnblogs.com/mfrbuaa/p/3839822.html

VC父窗口和子窗口
https://blog.csdn.net/rankun1/article/details/51425869
AfxGetMainWnd获取自身窗体句柄

HWND hWnd = AfxGetMainWnd()->m_hWnd;
GetTopWindow
函数功能：该函数检查与特定父窗体相联的子窗体z序（Z序：垂直屏幕的方向，即叠放次序），并返回在z序顶部的子窗体的句柄。
函数原型：HWND GetTopWindow（HWND hWnd）；
⑹：
　　hWnd:被查序的父窗体的句柄。假设该⑹为NULL，函数返回Z序顶部的窗体句柄。
返回值：
    假设函数成功，返回值为在Z序顶部的子窗体句柄。假设指定的窗体无子窗体，返回值为NULL。

GetForegroundWindow
函数功能：该函数返回当前系统的前台窗体的窗体句柄。
函数原型：HWND GetForegroundWindow（VOID）　　
返回值：函数返回前台窗回的句柄。

GetActiveWindow
函数功能：该函数能够获得与调用该方法的线程的消息队列相关的活动窗体的窗体句柄（就是取得当前进程的活动窗体的窗体句柄）。
函数原型：HWND GetActiveWindow（VOID）
返回值：返回值是与调用线程的消息队列相关的活动窗体的句柄。否则，返回值为NULL。

GetSafeHwnd
函数功能：获取某个窗体对象（CWnd的派生对象）指针的句柄（HWND）时，最安全的方法是使用GetSafeHwnd()函数。

IsWindowVisible
函数功能：该函数获得给定窗体的可视状态。

IsWindow：
函数功能：该函数确定给定的窗体句柄是否标示一个已存在的窗体。

FindWindow：
HWND FindWindow(LPCSTR lpClassName,LPCSTR lpWindowName );
⑹：
lpClassName
　　指向一个以null结尾的、用来指定类名的字符串或一个能够确定类名字符串的原子。

SetWindowText：
至于窗体标题的改变，我们能够通过SetWindowText来实现

InModalState
https://baike.baidu.com/item/InModalState/10114789?fr=aladdin
示例编辑
/****************************************************
演示函数原型：pFrame->InModalState();
程序功能说明：将框架设为模式状态。
****************************************************/
//如果框架处于非模式状态
if(!pFrame->InModalState())
{ //获得框架最顶级父窗体
CWnd *pTemp=pFrame->GetTopLevelParent();
BOOL bEnabled=pTemp->IsWindowEnabled();
//如果最顶级父窗体不为活动状态
if(!bEnabled)
{
//将框架设为模式状态
pFrame->BeginModalState();
//激活最顶级父窗体
pTemp->EnableWindow(TRUE);
}
}

2020.03.10

请问如何判断已经显示的窗体是否是模态的? [问题点数：200分，结帖人sonic_andy]
https://bbs.csdn.net/topics/340050646
没有父窗口的模式窗口和非模式窗口还是有区别的
其实真正的模式窗口并非只父窗口被禁用，而是线程内的所有窗口都被禁用
一般情况下，判断某个窗口是否为模式窗口可以这样测试
if iswindowenabled（ Getwindow(hwnd,gw_owner）） ＝0 then 某窗口为模式窗口

其实模态并不是窗口的状态。

模态窗口是这样一组操作的集合：
1 设置调用窗口为主窗口的子窗口
2 将主窗口的Enable设置为False
3 显示调用窗口
你可以用这个思路，获得当前窗口的父窗口，判断它是否Enable。


生粉 编辑 讨论
生粉是食谱中常出现的名词，多是用来勾芡用的，在大陆和台湾使用的生粉是马铃薯粉，在香港使用的生粉为玉米粉。生粉在中式烹调上除了勾芡使食物产生滑润的口感之外，亦常用来做为软化肉质的腌肉料之一。生粉的用途很广，可以作炒菜时的调料，也可以做凉粉，还可以用来摊煎饼，最主要用于肉类原料加工时上浆、勾芡等。
在中餐里就是指淀粉，炒菜时用于勾芡、上浆等， 有多种多样，比如红薯淀粉，川菜中使用的水豆粉，以及玉米淀粉等。生粉就是淀粉，可以有很多种，一般指玉米淀粉。
勾芡的学术概念是：借助淀粉在遇热糊化的情况下，具有吸水、粘附及光滑润洁的特点，在菜肴接近成熟时，将调好的粉汁淋入锅内，使卤汁稠浓，增加卤汁对原料的附着力，从而使菜肴汤汁的粉性和浓度增加，改善菜肴的色泽和味道。

面粉是一种由小麦磨成的粉末。按面粉中蛋白质含量的多少，可以分为高筋面粉、中筋面粉、低筋面粉及无筋面粉。面粉（小麦粉）是中国北方大部分地区的主食。以面粉制成的食物品种繁多，花样百出，风味迥异 。

蓝牙电脑适配器
蓝牙适配器 台式机电脑

羊UDJ J->最简单的没试?

都不是好友，哪里存在黑
---言多必失

你家牛会抽烟不?
许君聪:你有病,你家牛会呀!
那就是着火了

2020.03.09

submit commit

MsEditDlg.cpp

#include "ReadMds.h"
#include "log.h"
#include "Master.h"
#include "DataFile.h"

BOOL g_SendFilePause = FALSE;
CLog g_Log;
Master g_Master;
extern CString logstr;

stdafx.h
https://baike.baidu.com/item/stdafx.h/10326842?fr=aladdin
stdafx的英文全称为：Standard Application Framework Extensions（标准应用程序框架的扩展）。 [1]
编译器通过一个头文件stdafx.h来使用预编译头文件。stdafx.h这个头文件名是可以在project的编译设置里指定的。编译器认为，所有在指令#include "stdafx.h"前的代码都是预编译的，它跳过#include "stdafx. h"指令，使用projectname.pch编译这条指令之后的所有代码。
因此，所有的MFC实现文件第一条语句都是：#include "stdafx.h"。在它前面的所有代码将被忽略，所以其他的头文件应该在这一行后面被包含。否则，你将会得到“No such file or directory”这样让你百思不得其解的错误提示。 [2] 

名称的英文全称为：Standard Application Fram Extend 
stdafx的英文全称为：Standard Application Framework Extensions（标准应用程序框架的扩展）。 [1]

可以看到有3个选项：【创建预编译头】、【使用预编译头】和【不使用预编译头】。

stdafx.cpp肯定选择的是【创建预编译头】

============================================================================

再右击Test.cpp文件，选择【属性】-【C/C++】-【预编译头】-【创建/使用预编译头】

可见，它选择的是【使用预编译头】，下面选的文件是StdAfx.h文件，最下面指明的是pch文件的路径


请问c++中的#include "stdafx.h"是什么意思？
https://blog.csdn.net/lijun5635/article/details/13090341/
编译器认为，所有在指令#include "stdafx.h"前的代码都是预编译的，它跳过#include "stdafx. h"指令，使用projectname.pch编译这条指令之后的所有代码。 因此，所有的MFC实现文件第一条语句都是：#include "stdafx.h"。
当VisualC++编译随后的每个.cpp文件时，它阅读并使用它刚生成的.pch文件。VisualC++不再分析Windowsinclude文件，除非你又编辑了stdafx.cpp或stdafx.h。 
这个技术很精巧，你不这么认为吗？(还要说一句，Microsoft并非是首先采用这种技术的公司，Borland才是。)在这个过程中你必须遵守以下规则： 
当我们使用AppWizard来自动生成某些项目的时候,系统会自动把所需要include的头文件在stdafx.h中先include一下,这样,我们只需要直接include这个stdafx.h文件即可
4 与stdio.h的区别
我们一般用TC或vc编译C程序的时候都要首先包含这个stdio.h头文件，这个头文件里面包含了scanf和printf函数的定义，如果我们不在程序开头include这个文件，那么你调用上面这两个函数就不会成功，它其实和c++中的iostream.h文件的作用差不多的，它们一般都已经在stdafx.h文件中被包含。

stdafx.h
所谓头文件预编译，就是把一个工程(Project)中使用的一些MFC标准头文件(如Windows.H、Afxwin.H)预先编译，以后该工程编译时，不再编译这部分头文件，仅仅使用预编译的结果。这样可以加快编译速度，节省时间。
预编译头文件，把不太变的头文件包含进去，这样以后编译的时候只用编译一次，不变化就不需要重新编译了
如果你的项目设置了“使用预编译头(/Yu)”选项，那么项目中的任何cpp文件的最开头必须要#include stdafx.h，否则编译会出错的，你可以试试
我发现自己养成了一个比较好的习惯，有关编程的事情，一定知其然知其所以然

D:\softs\VC6免安装绿色版\VC6\Common\MSDev98\Bin\MSDEV.EXE (英文版)

Standard Application Fram Extend  
https://blog.csdn.net/mengxiangying504/article/details/4729413
1.你编写的任何.cpp文件都必须首先包含stdafx.h。
1.afxwin.h是MFC编程的必需文件，其中包含如CString，CEdit类运行所必需的头文件，最好保证该句在头文件首行；它还会调用windows.h，改头文件包含有数据类型的定义、API入口点定义和其它有用的参数信息；
3.#define WIN32_LEANAND_MEAN，在windows的头文件中拒绝接受MFC类库，以加速编译时间；
4.afx - afx中的af指的是Application Frame的缩写，曾经有一个技术开发团队专门作Application Frame，后来给这个团队命名用afx，x本身没有含义，只不过构成一个响亮的口号，后来就一直沿用下来。

Fram Extend
FRAM扩展

stdio.h是什么意思？
https://www.php.cn/faq/416714.html
在C语言或C++中，会把用#include的文件的扩展名叫 .h，称其为头文件，stdio.h就是standard input output.header，也就是“标准输入输出头文件”。
stdio.h文件的内容就是一些基本输入输出函数的声明，比如scanf()和printf()函数，你包含了stdio.h，就相当于声明了这些函数，所以你才可以在自己的程序中使用它们。
stdio 就是指 “standard input & output"（标准输入输出）
所以，源代码中如用到标准输入输出函数时，就要包含这个头文件。


include stdafx.h 是什么意思
https://zhidao.baidu.com/question/435733299951089524.html
stdafx.h
1名称的英文全称为：Standard Application Fram Extend

#include "ReadMds.h"
#include "DataFile.h"

class CMsEditDlg : public CDialog
{
// Construction
public:
	CMsEditDlg(CWnd* pParent = NULL);	// standard constructor

	ReadMds* readdlg;
	DataFile* loaddlg;
...
CListBox	m_loglist;
...
	afx_msg void OnReadmds();
	afx_msg void OnLoaddat();
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnDestroy();
}

CMsEditApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CMsEditApp initialization

BOOL CMsEditApp::InitInstance()
{...
	CMsEditDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
...}


MS.cpp (msedit):CMSApp theApp;
MsEdit.cpp (msedit):CMsEditApp theApp;

MsEdit.dsp

*dlg *.dsp

动手调试 E:\wen_test\hanota2 书写会理解得更好

Please Input Num(>0) of Hanoto: Nun = 1
main call hanoi at step cnt = 1
Over cnt = 1 run_time=0.000571us

Please Input Num(>0) = 2
main call hanoi at step cnt = 2
Over cnt = 3 run_time=0.000656us

Please Input Num(>0) = 29
main call hanoi at step cnt = 268435456
Over cnt = 536870911 run_time=17.245971us

Please Input Num(>0) = 30
main call hanoi at step cnt = 536870912
Over cnt = 1073741823 run_time=34.540466us

Please Input Num(>0) = 35
main call hanoi at step cnt = 17179869184
Over cnt = 34359738367 run_time=1099.520271us

Please Input Num(>0) = 36
main call hanoi at step cnt = 34359738368
Over cnt = 68719476735 run_time=2450.936066us

Please Input Num(>0) =

数位顺序表
https://baike.baidu.com/item/%E6%95%B0%E4%BD%8D%E9%A1%BA%E5%BA%8F%E8%A1%A8/10065233?fr=aladdin
正 10的四十次方
载 10的四十四次方
极 10的四十八次方
恒河沙 代表的是10的五十二次方
阿僧 代表的是10的五十六次方
那由它 代表的是10的六十次方
不可思议 代表的是10的六十四次方
无量 代表的是10的六十八次方
大数 代表的是10的七十二次方
古戈尔 代表的是10的一百次方


个十百千万是什么单位
https://zhidao.baidu.com/question/1754804273950261028.html
个十百千万是计数单位。
我们常用的是十进制计数法，所谓“十进制”就是每相邻的两个计数单位之间的关系是：一个大单位等于十个小单位，也就是说它们之间的进率是“十”。

计数单位依次为 个、十、百、千、万、十万、百万、千万、亿、十亿、百亿、千亿 、兆、十兆、百兆、千兆、京、十京、百京、千京、垓、十垓、百垓、千垓、秭、十秭、百秭、千秭、穰、十穰、百穰、千穰、沟、十沟、百沟、千沟、涧、十涧、百涧、千涧、正、十正、百正、千正、载、
十载、百载、千载、极、十极、百极、千极、恒河沙、十恒河沙、百恒河沙、千恒河沙、阿僧祗、十阿僧祗、百阿僧祗、千阿僧祗、那由他、十那由他、百那由他、千那由他、不可思议、十不可思议、百不可思议、千不可思议、 无量大海、十无量大海、百无量大海、千无量大海、大数、十大数、百大数、千大数。

个十百千万后面是什么
https://zhidao.baidu.com/question/43316805.html
个、十、百、千、万、十万、百万、千万、亿后面接着是十亿、百亿、千亿……
数位表：
兆：代表的是10的十二次方。

京：代表的是10的十六次方。

垓：代表的是10的二十次方。

杼：代表的是10的二十四次方。

穰：代表的是10的二十八次方。

沟：代表的是10的三十二次方。

涧：代表的是10的三十六次方。

无量：代表的是10的六十八次方。

大数：代表的是10的七十二次方。


解决typedef unsigned long long DDWORD; 在VC下编译不过问题。
C/C++的64位整型
https://blog.csdn.net/scholety/article/details/22876417
在C/C++中，64为整型一直是一种没有确定规范的数据类型。现今主流的编译器中，对64为整型的支持也是标准不一，形态各异。一般来说，64位整型的定义方式有long long和__int64两种(VC还支持_int64)，而输出到标准输出方式有printf(“%lld”,a)，printf(“%I64d”,a)，和cout << a三种方式。
本文讨论的是五种常用的C/C++编译器对64位整型的支持，这五种编译器分别是gcc(mingw32)，g++(mingw32)，gcc(linux i386)，g++(linux i386)，Microsoft Visual C++ 6.0。可惜的是，没有一种定义和输出方式组合，同时兼容这五种编译器。为彻底弄清不同编译器对64位整型，我写了程序对它们进行了评测，结果如下表。


vc6.0下64位整数_Int64的应用
https://blog.csdn.net/abchcd/article/details/4552004
vc6.0下是不能编译通过long long 的,
欲用64位整型,可以加以下宏
#if defined (_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS  >=  64
typedef signed?? __int64??? int64; 
typedef unsigned  __int64 uint64; 
#else 
#error  __int64?? type?? not?? supported?
#endif 
以下为输出
printf("%I64d",test);


_INTEGRAL_MAX_BITS

C++编译器的预定义宏（WINDOWS版、LINUX版）
http://www.sunyuping.cn/?p=121

Visual C++从入门到实践(配光盘1张)
作者: 葛亮

Visual C++从入门到实践本书源文件
https://download.csdn.net/download/u010565021/6566023

2020.03.06

计算64层汉诺塔需要多长时间？
https://www.zhihu.com/question/48015041
java,最下边有源码圆盘10  移动了1023次    结束时间-开始时间的毫秒数:  0(0-1之间)圆盘20  移动了1048575次   结束时间-开始时间的毫秒数:  2圆盘25  移动了33554431次  结束时间-开始时间的毫秒数:  39圆盘30  移动了1073741823次  结束时间-开始时间的毫秒数:  1386圆盘35  移动次数超出int最大值...(34359738367)  结束时间-开始时间的毫秒数:  38315圆盘40没有尝试,按照这个规律恐怕是在10分钟以上

作者：天子第一号
链接：https://www.zhihu.com/question/48015041/answer/917571616
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


对于汉诺塔问题最快的计算机需要多长时间？ [问题点数：20分，结帖人wangmin_yjitx]
https://bbs.csdn.net/topics/30322935
移动次数是2^64-1，约为16*10^18次。
就算一次移动只需1个机器时间，按目前的万亿次计算机来算（当然啦！这种计算机你是没机会用的。），需要16*10^6秒，（一万亿是十的12次方），所以只要半年就可以了。

但按慢的算，假如用P4 2.4GHz的CPU，每3个指令周期计算一步（访问一次内存就得3个指令周期），则需要2*10^10秒（2.4G/3是8*10^8），也就是634年。

你说的10^9年（你记错了吧？应该是10^11年）是指僧侣搬盘子，按每秒搬一次计算，假如一天24小时，一年365天，不停地搬，需要5.85*10^11年。


把google的分布式系统拿过来算这个，他们的速度可以达到10万亿亿次每秒（当然要改程序啦），30年大概可以计算10的31次方，所以可以计算100阶
https://bbs.csdn.net/topics/60495261

汉诺塔：移动64块需要多少时间
在汉诺塔中，如果要移动60块的，至少要移动多少次才能完成，还有如果假设是一秒移动一次，那需要多少时间来完成？
https://zhidao.baidu.com/question/562976303.html
准确的来说是2的64次方减一次，584,942,417,355年26天7小时15秒
移64层的汉诺塔需2^64 -1=18,446,744,073,709,551,615步
如果是一秒一次的话，那么就是18,446,744,073,709,551,615秒。

error C2632: 'long' followed by 'long' is illegal
https://blog.csdn.net/shine1998/article/details/78701483
原因：

因为 VC6中所使用的编译器是C90标准的，而?long long 型是在C99中新加入的


（longlong int双长整型是C 99扩充的数据类型，同时扩充的还有float_complex，double_complex，long

long_complex，bool等），
故无法实现编译。（――此答案搜索于百度）



解决办法：

将long long 用 _int64 进行替换。

unsigned _int64 cnt;


怎样定义较大的整数，比如1亿 [问题点数：100分]
https://bbs.csdn.net/topics/392392631?page=1	
定义longlong a,b,c.
unsigned long long的最大值：1844674407370955161
long long的最大值：9223372036854775807
最小取值则是负数



c语言中，int型数据，能表示的最大十进制数是多少
https://zhidao.baidu.com/question/554665214323167252.html
除了int类型之外，还有short、long、long long类型可以表示整数。


c语言测试程序执行时间
https://blog.csdn.net/qiuchenl/article/details/8276994

C语言中如何看运行时间 [问题点数：20分]
https://bbs.csdn.net/topics/320067672
GetTickTime  该函数返回系统启动的时间,精确到毫秒

C语言测试程序运行时间――高精度
https://blog.csdn.net/ysz171360154/article/details/88086328

C语言 计算/测程序运行时间（精确到微秒）
https://blog.csdn.net/lizehao1973/article/details/85456872
#include<stdio.h>
#include <Windows.h>
int main() {
	int a[10002];
	int i = 0;
	double run_time;
	LARGE_INTEGER time_start;	//开始时间
	LARGE_INTEGER time_over;	//结束时间
	double dqFreq;		//计时器频率
	LARGE_INTEGER f;	//计时器频率
	QueryPerformanceFrequency(&f);
	dqFreq=(double)f.QuadPart;
	QueryPerformanceCounter(&time_start);	//计时开始
	for( i = 1; i <= 10000; i++)a[i]=i;	//要计时的程序
	QueryPerformanceCounter(&time_over);	//计时结束
	run_time=1000000*(time_over.QuadPart-time_start.QuadPart)/dqFreq;
	//乘以1000000把单位由秒化为微秒，精度为1000 000/（cpu主频）微秒
	printf("\nrun_time：%fus\n",run_time);
	return 0;
}


我想知道我的一段C语言代码执行了多长时间(精确到0.01豪秒) [问题点数：50分，结帖人yyttrr2007]
https://bbs.csdn.net/topics/350239336
可以采取多次循环求平均
#include<stdio.h>
#include<time.h> 
clock_t start = clock();
for(int i = 0; i< 1000; i++)
{
.... yourfunction();
}
clock_t end = clock();

yourtime = (end - start)/1000;
这个肯定能精确到0.01ms


ao3同文网站用本名写黄文
肖战粉丝举报ao3 那些把同人当黄文的,
写黄文的是肖战粉丝，阅读传播的是肖战粉丝，举报的是肖战粉丝，倒霉的是ao3
https://bbs.hupu.com/32795021.html

上百度查下就知道了，发的同人文章又黄又恶心，毒害青少年@阿文

备注：AO3是全世界文人交流的平台，不做任何思想限制，随意发挥创作的一个平台，被称为文学界里面最后的乌托邦。
H文我给大家推荐少妇白洁和《金鳞岂是池中物》，

对于递归有没有什么好的理解方法？
https://www.zhihu.com/question/31412436
用数学代入法来理解就好。
很简单，把式子展开即可：
f(6)
=> 6 * f(5)
=> 6 * (5 * f(4))
=> 6 * (5 * (4 * f(3)))
=> 6 * (5 * (4 * (3 * f(2))))
=> 6 * (5 * (4 * (3 * (2 * f(1)))))
=> 6 * (5 * (4 * (3 * (2 * 1))))
=> 6 * (5 * (4 * (3 * 2)))
=> 6 * (5 * (4 * 6))
=> 6 * (5 * 24)
=> 6 * 120
=> 720
看到递归了吗？
先递进，再回归――这就是「递归」。
以上是 SICP 原文（有删改）。
编辑于 2019-07-07
https://www.zhihu.com/question/31412436/answer/738989709


// hanota.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
//
//int main(int argc, char* argv[])
//{
//	printf("Hello World!\n");
//	return 0;
//}

#include <iostream>
#include <cstdio>
using namespace std;
 
int cnt;
 
void move(int id, char from, char to) // 打印移动方式：编号，从哪个盘子移动到哪个盘子
{
    printf ("step %d: move id=%d from %c->%c\n", ++cnt, id, from, to);
}
 
void hanoi(int n, char x, char y, char z)
{
    if (n == 0)
        return;
    hanoi(n - 1, x, z, y);
    move(n, x, z);
    hanoi(n - 1, y, x, z);
}
 
int main()
{
    int n;
    cnt = 0;
	printf ("Please Input Num(>0) of Hanoto: Nun = ");
    scanf ("%d", &n);
	while(n > 0)
	{
		hanoi(n, 'A', 'B', 'C');

		printf ("\nPlease Input Num(>0) = ");
		scanf ("%d", &n);
		cnt = 0;
	}
    return 0;
}


陈情令

肖战名下工作室均已注销, 代言产品遭网友抵制, 这是怕要凉凉啊!
http://k.sina.com.cn/article_7132918298_1a927b21a00100m4ns.html

肖战227事件怎么回事？王一博肖战著名711事件是什么
http://www.hxnews.com/news/yule/202003/04/1867604.shtml


肖战怎么了？全程回顾“227事件”，看他因何从顶红流量变成全民公敌？
https://new.qq.com/omn/20200304/20200304A0D0V900.html
事情至此，欧美、日韩、动漫、同人文、耽美等等圈子的创作者们揭竿而起，反对肖战粉丝举报创作平台，本来大家的圈地自萌，因为肖战粉丝按下的“举报”键，平衡彻底被打破，一场227圣战的起义，已经在各圈点燃火炬。


汉诺塔问题――递归（时隔9个月，终于懂了）
https://blog.csdn.net/qq_41705423/article/details/82025409

汉诺塔
https://baike.baidu.com/item/%E6%B1%89%E8%AF%BA%E5%A1%94/3468295?fr=aladdin

2020.03.05

C语言怎么把自定义头文件添加到函数库中
https://zhidao.baidu.com/question/757998494001014524.html
你可以把你的头文件复制到 stdio.h 所在的文件夹，并 修改 编译器自带的 stdio.h，
在 stdio.h 的 尾部 加一句 #include 你开发的头文件名 即可。以后，凡使用 stdio.h 就自动有了 你开发的头文件了。
这个操作很简单，但你要有管理员特权，才能修改stdio.h。
如果 可以自己 写 #include ...; 你可以 把自己开发的 头文件写在 自己 的 一个文件夹。把自己的文件夹路径 加入到 环境变量 INCLUDE 中。例如文件夹路径是 d:\my_head 用 命令：
set INCLUDE=%INCLUDE%;d:\my_head
就可加入。 使用头文件 用 #include <my_some.h>
my_some.h 是你开发的头文件之一，存放在 d:\my_head\ 下面。

c语言中如何将自定义库导入到标准库中？ 100
https://zhidao.baidu.com/question/385485520.html
我没试过，这是从别的地方粘过来的，你试试看
1,写文件“*.h”，文件“*.c”，文件.c中为函数实现；文件.h中为文件声明；
2，把该函数编译为.dll的一个入口函数;
3，提供*.lib,*.dll,*.h，三个文件；
4，把*.dll放到Path目录下；
5，把*.lib包含入工程，*.h，include到工程；
6，可以使用你写的函数；
什么编程软件？如果是Tc的话，把自定义的库放入库includ目录中，然后再程序中直接引用就成了，很简单.
直接放到标准库所在的目录即可

C语言中怎样把用户自定义的函数添加到标准函数库中？
https://zhidao.baidu.com/question/11615498.html
把你写的函数保存成*.h文件，用的时候再include
找到系统标准函数库,在其中添加你的函数,当然这不是真的标准函数STDIO.H了

C语言自定义库函数
C 语言自定义库
c语言中如何将自定义库导入到标准库中？
用户函数加入到库函数

常见排序算法
https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/5399605#4

各种排序算法性能比较
https://www.cnblogs.com/alamps/p/8473815.html

各种排序算法比较
https://www.cnblogs.com/lizr-ithouse/p/5839384.html

总结5种比较高效常用的排序算法
https://blog.csdn.net/hl_java/article/details/72499914

为什么快速排序比堆排序要快？
https://blog.csdn.net/nawuyao/article/details/52729518

八种排序算法效率比较
https://blog.csdn.net/m372897500/article/details/51478136

用cl工具编译MFC程序
https://blog.csdn.net/weixin_34015860/article/details/91974225

VC的编译器是cl.exe，这就是说调试器叫什么名字
http://m.myexception.cn/vc-mfc/1313437.html
调试器是devenv.exe。可以在命令行下使用，举例：Devenv.exe /debugexe MyApplication.exe
其实devenv.exe也是IDE，devenv是开发环境的缩写
两者没有分开

使用cl.exe在windows控制台下编译C++程序
https://blog.csdn.net/a10929/article/details/78171483?utm_source=blogxgwz1
工具
cl.exe 是控制 Microsoft C 和 C++ 编译器与链接器的 32 位工具。编译器将.cpp编译，生成中间代码目标文件(.obj)。链接器将目标文件链接，产生可执行文件 (.exe) 或动态链接库文件 (DLL)。

link.exe 是将目标文件和库链接起来以创建 32 位可执行 (.exe) 文件或动态链接库 (DLL) 的 32 位工具。

rc.exe 是将windows资源文件(.rc)编译成资源文件(.res),从而与目标文件链接，一般用于设置exe文件的图标和属性或者dll包含的资源。

lib.exe是将目标文件链接生成静态库文件(.lib)，也可以用于生成dll的lib文件。

环境配置
那么这4个exe文件在哪个目录下呢？我的vs装在了E盘，然后我在 E:\vs2013\VC\bin 目录下找到了cl.exe，link.exe，lib.exe，但是没找到rc.exe，于是我在C盘看了看，结果在C:\Program Files (x86)\Windows Kits\8.1\bin\x64 目录下找到了，后来我又发现这些exe似乎不止一份，在很多目录下都有，真奇怪。。。好吧，找到了后把所在目录加入Path环境变量就可以了。

光这样还不行，还得把一些头文件和lib库也加入环境变量，目录如下：

//这4个加入INCLUDE环境变量
E:\vs2013\VC\include;
C:\Program Files (x86)\Windows Kits\8.1\include\shared 
C:\Program Files (x86)\Windows Kits\8.1\include\um 
C:\Program Files (x86)\Windows Kits\8.1\include\winrt

//这2个加入LIB环境变量
E:\vs2013\VC\lib
C:\Program Files (x86)\Windows Kits\8.1\Lib\winv6.3\um\x64

使用
以生成dll为例：

先用cl命令将.cpp编译成.obj，-c选项的作用：只编译不链接，不然cl还会试图链接生成exe，但dll工程根本没有main函数，没法生成exe，所以就会出错了。
cl -c dllmain.cpp dllclass.cpp
如果有资源文件(.rc)，那么用rc.exe将.rc编译成.res
rc dllsource.rc
用link命令将.obj .rc等文件 链接，生成dll文件及对应的.lib .exp
link -dll dllmain.obj dllclass.obj dllsource.res

gcc 和VC++有什么区别呢，VC++编译时用的编译器 相当于gcc的是什么东西 
https://zhidao.baidu.com/question/241197025937086524.html
vc的编译器是CL 当还有其他的 clang 神马 你没必要搞清楚 你只要知道 vc好用易用 但是要钱买 ，express版、d版除外
gcc 不要钱 、开源、你感觉自己够强了可以去 研究其源代码

VC++和DEV都是集成开发环境，VC++是Windows平台最权威的开发工具，而dev就是新手练手用的。至于Gcc是Gun的一个项目，它是一个编译器，主要用在Linux中，它是跨平台的

C/C++ 开发环境和工具
https://www.iteye.com/blog/yanguz123-2178510

15 款最好的 C/C++ 编译器和集成开发环境
https://www.cnblogs.com/lonelyxmas/p/9083296.html

C/C++开发者必备：十款免费集成开发环境IDE
https://blog.csdn.net/dj0379/article/details/52451837
集成开发环境（IDE，Integrated Development Environment）



Visual Studio c++语言特点：
Visual Studio c++是由Microsoft启动的开发环境。Visual Studio c++可用于在Windows平台上创建Windows应用程序和网络应用程序，以及创建网络服务、智能设备应用程序和Office插件。Visual Studio是最流行的Windows平台应用程序开发环境。
Visual Studio c++6.0之后包括各种增强功能，例如Visual Designer（加速开发使用）。NET Framework 3.5），对Web开发工具的实质性改进，以及语言增强，可以加速所有类型数据的开发和处理。Visual Studio 为开发人员提供了所有相关的工具和框架支持，以帮助创建引人注目、令人印象深刻且支持Ajax的Web应用程序。

开发人员可以使用这些富客户端和服务器端框架轻松构建以客户端为中心的Web应用程序。这些应用程序可以集成任何后端数据提供程序，在任何当前浏览器中运行，并且可以完全访问ASP NET应用程序服务和Microsoft平台。



vc6.0中的dsp,dsw,ncb,opt,clw,plg,aps等文件的简单说明
https://blog.csdn.net/qq_35583007/article/details/81947906

.CLW   文件是VC   Class   Wizard信息文件。存放了Class   Wizard的信息。 

.NCB   文件是分析器信息文件，是由系统自动产生的。 

.OPT   文件是IDE的Option文件。 

.APS   文件是资源文件的二进制版本。 

 

.clw   支持ClassWizard 

.ncb   支持ClassView 

.opt   保存工作空间的配置 

.aps   支持ResourceView

.bsc   浏览器信息文件 

.dsp   项目文件 

.dsw   工作空间文件 

.mak   外部的创建文件 

.plg   建立日志文件 

 

.opt 工程关于开发环境的参数文件。如工具条位置等信息；

.aps (AppStudio File),资源辅助文件,二进制格式,一般不用去管他.

.clw ClassWizard信息文件,实际上是INI文件的格式,有兴趣可以研究一下.有时候ClassWizard出问题,手工修改CLW文件可以解决.如果此文件不存在的话,每次用ClassWizard的时候绘提示你是否重建.

.dsp (DeveloperStudio Project):项目文件,文本格式,不过不熟悉的话不要手工修改.DSW(DeveloperStudio Workspace)是工作区文件,其他特点和DSP差不多.

.plg 是编译信息文件,编译时的error和warning信息文件（实际上是一个html文件）,一般用处不大.在Tools->Options里面有个选项可以控制这个文件的生成.

.hpj (Help Project)是生成帮助文件的工程,用microsfot Help Compiler可以处理.

.mdp (Microsoft DevStudio Project)是旧版本的项目文件,如果要打开此文件的话,会提示你是否转换成新的DSP格式.

.bsc 是用于浏览项目信息的,如果用Source Brower的话就必须有这个文件.如果不用这个功能的话,可以在Project Options里面去掉Generate Browse Info File,可以加快编译速度.

.map 是执行文件的映像信息纪录文件,除非对系统底层非常熟悉,这个文件一般用不着.

.pch (Pre-Compiled File)是预编译文件,可以加快编译速度,但是文件非常大.

.pdb (Program Database)记录了程序有关的一些数据和调试信息,在调试的时候可能有用.

.exp 只有在编译DLL的时候才会生成,记录了DLL文件中的一些信息.一般也没什么用.

.ncb 无编译浏览文件(no compile browser)。当自动完成功能出问题时可以删除此文件。build后会自动生成。



vc6.0中dsp,dsw,ncb,opt,clw,plg,aps等文件的简单说明
https://blog.csdn.net/alongwilliam/article/details/27205701

.CLW文件

VC Class Wizard信息文件，存放了Class Wizard的信息。 ClassWizard信息文件，实际上是INI文件的格式,有兴趣可以研究一下。有时候ClassWizard出问题,手工修改CLW文件可以解决。如果此文件不存在的话,每次用ClassWizard的时候会提示你是否重建。

.NCB文件

无编译浏览文件(no compile browser)，当自动完成功能出问题时可以删除此文件。build后会自动生成。

.OPT文件

IDE的Option文件，工程关于开发环境的参数文件，如工具条位置等信息，保存工作空间的配置 。

.APS文件

资源文件的二进制版本，资源辅助文件，一般不用去管他。

.clw文件

支持ClassWizard。

.ncb文件

支持ClassView。

.aps文件

支持ResourceView。

.bsc文件

浏览器信息文件，用于浏览信息文件，如果用Source Brower的话就必须有这个文件。如果不用这个功能的话,可以在Project Options里面去掉Generate Browse Info File，可以加快编译速度。

.dsp文件

DeveloperStudio Project，项目文件，文本格式，不过不熟悉的话不要手工修改。

.dsw文件

DeveloperStudio Workspace，是工作区文件，其他特点和DSP差不多。

.mak文件

这是MFC项目的项目文件，这也是与NMAKE兼容的文件。如果选择了External make文件可选项，则可人工对它编辑，但不能利用Visual C++许多项目编辑特性。

.plg文件

建立日志文件，是编译信息文件，编译时的error和warning信息文件（实际上是一个html文件），在Tools->Options里面有个选项可以控制这个文件的生成。

.hpj文件

Help Project，是生成帮助文件的工程，用microsfot Help Compiler可以处理。

.mdp文件

Microsoft DevStudio Project，是旧版本的项目文件，如果要打开此文件的话，会提示你是否转换成新的DSP格式。

.map文件

是执行文件的映像信息纪录文件，除非对系统底层非常熟悉，这个文件一般用不着。

.pch文件

Pre-Compiled File，是预编译文件，可以加快编译速度，但是文件非常大。

.pdb文件

Program Database，记录了程序有关的一些数据和调试信息，在调试的时候可能有用。

.exp文件

只有在编译DLL的时候才会生成，记录了DLL文件中的一些信息。

转自：http://lang.9sssd.com/vcpp/art/1455



Source Insight 中文注释为乱码解决办法（完美解决，一键搞定）
Source Insight中文注释为乱码解决办法
https://www.cnblogs.com/jing1617/p/7525823.html
我网上查了一堆解决办法，但是都是2017年以前的，并且都是针对于source insight 3.5及以下版本的解决方案，软件版本都到4.0了，应该有新方法出现。
干货：Source Insight 4 的解决办法(source insight 3.5 及以下版本就到其他地方看看吧)
【解决办法】：

单个文件乱码解决办法：

      菜单栏中【File】 > 【Reload As Encoding...】 > 【Chinese Simplified (GB18030)】 > 选择后，点击load，问题解决！！！

所有文件乱码解决办法：

    我的理解，在做下面操作的时候，先设置，然后关闭所有打开的文件，然后再打开文件即可

    菜单栏中 【Options】 > 【Preferences】 >File标签中，最下面的“Default encod-ing” ：改成System Default(Windows ANSI)
    或者Chinese Simplified(GB2312) CP:936，点击确定，问题解决！！！


source insight 中文乱码的解决方案
https://jingyan.baidu.com/article/ae97a646a5e499bbfc461d54.html

source insight中文注释乱码问题的解决方案
https://cloud.tencent.com/developer/article/1417198
解决方案如下：
一、单个文件转换
对于单个文件，好说，只要将非ANSI码格式的文件转换成ANSI码格式即可，方法如下：
 1、将文件用ultraEdit32打开，选择 文件->转换->UTF-8到ANSI， 然后保存。重新用source insight打开就好了。
或者使用记事本打开非ANSI格式的源代码文件，另存为，在保存选项对话框中，在编码格式一栏中发现是UTF-8，选择ANSI一项，保存，再用Source Insight打开就可以正常显示中文注释了。具体可参考百度经验的一篇文章：source  insight 中文乱码的解决方案。(v ok)

access密码忘了怎么办

https://www.xiazaizhijia.com/news/20171006/132153_all.html
简易APV密码查看.zip
https://dl.pconline.com.cn/download/2283680.html
https://dl.pconline.com.cn/download/2283680-1.html

今天推荐个电视剧给大家，《安家》，孙俪，海清出演(阿文_黄文敏)

公路美人 换一批
https://zhidao.baidu.com/question/749936665102364652.html
《公路美人》作为一部公路题材的纯爱电影，开篇就必须要有一个极大的矛盾冲突，才会使这群人上路，而本片的开场却让人使料未及，以一档名叫《爱上你》的相亲节目开始，美女作家安东妮为了推销新书假装单身参加电视相亲，并与相恋三年的男友曾浩签署了协议。然而安东妮为了追求对浪漫不切实际的憧憬，在节目中违背协议与藏族摄影师秀巴牵手，并且非常任性的选择了不辞而别。一次偶然的劈腿，打开了一条追爱之路。

2020.03.04

怎样查看git本地仓库所有文件目录
盘符根目录下查找 gitk.cache

const关键字及其作用（用法），C语言const详解
http://c.biancheng.net/view/217.html
说 const 定义的是变量，但又相当于常量；说它定义的是常量，但又有变量的属性，所以叫常变量。用 const 定义常变量的方法很简单，就在通常定义变量时前面加 const 即可，如：const  int  a = 10;
const 和变量类型 int 可以互换位置，二者是等价的，即上条语句等价于：
int  const  a = 10;

用 const 定义的变量的值是不允许改变的，即不允许给它重新赋值，即使是赋相同的值也不可以。所以说它定义的是只读变量。这也就意味着必须在定义的时候就给它赋初值。用 const 修饰的变量，无论是全局变量还是局部变量，生存周期都是程序运行的整个过程。

我们知道，局部变量存储在栈中，静态变量存储在静态存储区中，而经过 const 修饰过的变量存储在内存中的“只读数据段”中。只读数据段中存放着常量和只读变量等不可修改的量。const定义的是变量，而define定义的是常量。define定义的宏在编译后就不存在了，它不占用内存，因为它不是变量，系统只会给变量分配内存。但const定义的常变量本质上仍然是一个变量，具有变量的基本属性，有类型、占用存储单元。可以说，常变量是有名字的不变量，而常量是没有名字的。有名字就便于在程序中被引用，所以从使用的角度看，除了不能作为数组的长度，用const定义的常变量具有宏的优点，而且使用更方便。所以编程时在使用const和define都可以的情况下尽量使用常变量来取代宏。


C语言中const用法解析
https://blog.csdn.net/he__yuan/article/details/81607804
一、修饰局部变量
二、常量指针与指针常量
常量指针说的是不能通过这个指针改变变量的值，但是还是可以通过其他的引用来改变变量的值的。
int a=5;
const int* n=&a;
a=6;
(常量指针指向的值不能改变x)，但是这并不是意味着指针本身不能改变，常量指针可以指向其他的地址。
int a=5;
int b=6;
const int* n=&a;
n=&b;
指针常量是指指针本身是个常量，不能在指向其他的地址，写法如下：
int *const n;
需要注意的是，指针常量指向的地址不能改变，但是地址中保存的数值是可以改变的，可以通过其他指向改地址的指针来修改。
int a=5;
int *p=&a;
int* const n=&a;
*p=8;
区分常量指针和指针常量的关键就在于星号的位置，我们以星号为分界线，如果const在星号的左边，则为常量指针，如果const在星号的右边则为指针常量。如果我们将星号读作‘指针’，将const读作‘常量’的话，内容正好符合。int const * n；是常量指针，int *const n；是指针常量。

是以上两种的结合，指针指向的位置不能改变并且也不能通过这个指针改变变量的值，但是依然可以通过其他的普通指针改变变量的值。
const int* const p;
三、修饰函数的参数
四、修饰函数的返回值
五、修饰全局变量


int main(int argc,char*argv[])中argc/argv怎么填写 [问题点数：40分，结帖人zoueryu]
https://bbs.csdn.net/topics/390939712
在IDE中：
VC6：
 工程、设置、Debug、U程序变量：填写命令行参数。
VS20XX：
 项目、属性、配置属性、调试、命令参数：填写命令行参数。

在使用时：
cmd窗口中执行命令：
cd /d 你的程序所在盘符和目录
你的程序 参数1 参数2 "参数 3"

快捷方式、属性、目标：你的程序 参数1 参数2 "参数 3"

相关注册表项：你的程序 参数1 参数2 "参数 3"

百里挑一

关于int main( int argc, char* argv[] ) 中arg和argv参数的解析及调试
https://blog.csdn.net/dgreh/article/details/80985928
一、argc、argv的具体含义 
        argc和argv参数在用命令行编译程序时有用。main( int argc, char* argv[], char **env ) 中 
        第一个参数，int型的argc，为整型，用来统计程序运行时发送给main函数的命令行参数的个数，在VS中默认值为1。 
        第二个参数，char*型的argv[]，为字符串数组，用来存放指向的字符串参数的指针数组，每一个元素指向一个参数。各成员含义如下： 
        argv[0]指向程序运行的全路径名 
        argv[1]指向在DOS命令行中执行程序名后的第一个字符串 
        argv[2]指向执行程序名后的第二个字符串 
        argv[3]指向执行程序名后的第三个字符串 
        argv[argc]为NULL 
        第三个参数，char**型的env，为字符串数组。env[]的每一个元素都包含ENVVAR=value形式的字符串，其中ENVVAR为环境变量，value为其对应的值。平时使用到的比较少。
#include <stdio.h>
using namespace std;
int main(int argc, char ** argv)
{
    int i;
    for (i = 0; i < argc; i++)
        printf("Argument %d is %s\n", i, argv[i]);
    return 0;
}


C语言中的可变参数函数 三个点“…”
https://www.cnblogs.com/sticker/p/9988237.html
问题：运行时才确定的参数 
　　有没有办法写一个函数，这个函数参数的具体形式可以在运行时才确定？ 
　　答案与分析： 
　　目前没有"正规"的解决办法，不过独门偏方倒是有一个，因为有一个函数已经给我们做出了这方面的榜样，那就是main()，它的原型是: 
int main(int argc,char *argv[]); 
函数的参数是argc和argv。 

C语言学习小结--参数个数可变的函数
https://blog.csdn.net/mr_bean_1031/article/details/75912050
观察printf函数的原型，除了一个指向字符型常量地址（刚好是字符串常量的类型）的指针外，还有一个省略号，问题就出在这里。
与可变参数表相关的头文件是标准C库头文件”stdarg.h”，表示standard arguments（标准参数），找到里面几个用到的宏：

宏名称	描述	兼容
va_list	创建一个va_list类型变量	C89
va_start(v,l)	使va_list指向起始的参数	C89
va_arg(v,l)	检阅参数	C89
va_end(v,l)	释放va_list	C89
va_copy(v,s)	拷贝va_list的内容	C99
设一个可变参数表函数void func(int a, ...)。在使用可变参数表前，必须用va_list定义一个变量（假设变量名为ap），然后调用va_start(v,l)令ap指向该参数表的起始地址，va_start的第一个参数是va_list类型的变量ap，第二个参数是省略号前最后一个变量的变量名，初始化完成后就可以调用va_arg(v,l)依次检索参数了。va_arg的第一个参数是va_list类型的变量ap，第二个参数是将要检索的变量的类型名（如int，其本质是在内存中截取int长即2字节的数据赋给返回值后ap指向2字节以后的地址）。在检索完所有的参数后必须调用va_end(v)，使ap指向NULL（空指针），避免越界访问的问题。C99提供额外的宏”va_copy”，它能够复制va_list。而va_copy(v ,s)函数作用为拷贝s到v。

#include <stdio.h>
#include <stdarg.h>
/*用于测试可变参量表的打印函数，仅调用了putchar(int)函数*/
void print_test(char *string, ...);
/*将整数转换成字符串，value为输入的整形变量，s保存转换结果，radix = 10表示十进制，其他输出NULL*/
static char* inter2string(int value, char *s, int radix);
int main()
{
    int a = -67;
    char st[6];
    inter2string(a, st, 10);
    printf("%s\n", st);
    print_test("Tell me %s teleph%cne number:-n153 1418 %d-r188-n", "your", 'o', 1234);
    return 0;
}
/*--------------------------------------
  examples:
  print_test("%d.Sunny-r-nHello", inter);
---------------------------------------*/
void print_test(char *string, ...)
{
    int a;   //用来接收整形变量 
    char iTos[6];  //用来存放字符串型整数 
    char *c = string;  //避免直接使用string，导致string指向的地址发生变化 
    const char *s;  //用来指向指针常量，即字符串 
    va_list ap;  //定义一个va_list类型变量ap
    va_start(ap, string);  //初始化va，使va指向string的下一个地址 
    while(*c != '\0')
    {
        if(*c == '-')  //'-'，自定义的转义字符起始符 
        {
            switch(*++c)
            {
                case 'n':
                    putchar('\n');
                    break;
                case 'r':
                    putchar('\r');
            }
        } 
        else if(*c == '%')  //格式控制符 
        {
            switch(*++c)
            {
                case 'd':
                    a = va_arg(ap, int);  //检索变量
                    inter2string(a, iTos, 10);
                    for(s = iTos; *s != '\0'; s++)
                        putchar(*s);
                    break;
                case 'c':
                    a = va_arg(ap, char);
                    putchar(a);
                    break;
                case 's':
                    s = va_arg(ap, const char*);
                    while(*s != '\0')
                        putchar(*s++); 
            }
        }
        else
        {
            putchar(*c);
        }
        c++;  //指向下一个地址 
    }
    va_end(ap);   //不要忘记关闭ap
}

谁能详细讲解一下参数数量可变的函数 [问题点数：100分，结帖人earlier]
https://bbs.csdn.net/topics/60179018
我来抛砖引玉^_^
va_list是一种用来保存宏va_start,va_arg,va_end需要信息的数据类型，也就说要调用这几个宏就必须先申请一个va_list类型的数据
void va_start( va_list ap, argN ),该宏要在访问被省略的参数(就是...代表的部分啦)前调用，这样就初始化了ap，供后面的va_arg,va_end使用，而argN就是...之前的哪个参数啦
va_arg( va_list ap, type ),这个宏就是从被省略的部分的第一参数开始往后去参数，每调用一次就取得一个参数，ap就是va_start初始化的ap，type就是取得参数的类型，如果type与函数调用提供的参数类型不一致，结果不可预知

const

想睡时，动脑筋？

C 可变参数
https://www.runoob.com/cprogramming/c-variable-arguments.html
请注意，函数 func() 最后一个参数写成省略号，即三个点号（...），省略号之前的那个参数是 int，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 stdarg.h 头文件，该文件提供了实现可变参数功能的函数和宏。
定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。
在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。
使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。
使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。
使用宏 va_end 来清理赋予 va_list 变量的内存。


C语言_宏定义
https://blog.csdn.net/qq_41865229/article/details/86746707
#ifndef xxx //如果没有定义xxx
#define xxx //定义xxx
#endif //结束如果
“##”是一种分隔连接方式，它的作用是先分隔，然后进行强制连接。
宏参数中若包含另外的宏，那么宏参数在被代入到宏体之前会做一次完全的展开，除非宏体中含有#或##。

有如下宏定义：

#define A(y) X_##y
#define B(y) A(y)
#define SIZE 1024
#define S SIZE
1
2
3
4
A(S)会被展开成X_S。因为宏体中含有##，宏参数直接代入宏体。
B(S)会被展开成X_1024。因为B(S)的宏体是A(S)，并没有#或##，所以S在代入前会被完全展开成1024，然后才代入宏体，变成X_1024。

BOOL CLog::RawLogExt( LPCTSTR pszFormat, ... ) 
{
    char buf[1024*2] = "" ;
	va_list arglist;
	va_start(arglist, pszFormat);
    _vsnprintf( buf, 2048, pszFormat, arglist);
	va_end(arglist);

	return RawLog( buf ) ;
	
}

C语言中宏定义的使用
https://blog.csdn.net/imgosty/article/details/81901183#1-%E5%BC%95%E8%A8%80
C 语言提供的预处理功能有三种,分别为==宏定义==、文件包含和条件编译。
在 C 语言中,宏分为 有参数和无参数两种。无参宏的宏名后不带参数,其定义的一般形式为:
// 不带参数的宏定义
#define MAX 10
/*带参宏定义*/
#define M(y) y*y+3*y
/*宏调用*/
k=M(5);
宏定义只有在定义所在文件，或引用所在文件的其它文件中使用。 而全局变量可以在工程所有文件中使用，只要再使用前加一个声明就可以了。换句话说，宏定义不需要extern。
使用带参数的宏定义可完成函数调用的功能，又能减少系统开销，提高运行效率。
宏定义可完成简单的操作，但复杂的操作还是要由函数调用来完成，而且宏定义所占用的目标代码空间相对较大。
宏的定义很容易产生二义性，如：定义==#define S(a) (a)*(a)==，代码==S(a++)==，宏展开变成==(a++)*(a++)==这个大家都知道，在不同编译环境下会有不同结果。
函数体内有Bug，可以在函数体内打断点调试。如果宏体内有Bug，那么在执行的时候是不能对宏调试的，即不能深入到宏内部。
C++中宏不能访问对象的私有成员，但是成员函数就可以。
内联函数和宏的区别在于，==宏是由预处理器对宏进行替代 #80001e==，而==内联函数是通过编译器控制来实现的 #80000f==。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的==展开==，所以取消了函数的参数压栈，减少了调用的开销。可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。

内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样了。
对宏体和给引用的每个参数加括号，就能避免这问题。
通过==do{…}while(0) #80001e==能够解决上述问题
 宏参数重复调用
有如下宏定义：

#define min(X, Y)  ((X) < (Y) ? (X) : (Y))
1
当有如下调用时==next = min (x + y, foo (z));==，宏体被展开成==next = ((x + y) < (foo (z)) ? (x + y) : (foo (z)));==，可以看到，foo(z)有可能会被重复调用了两次，做了重复计算。更严重的是，如果foo是不可重入的(foo内修改了全局或静态变量)，程序会产生逻辑错误。
对自身的递归引用
有如下宏定义：

#define foo (4 + foo)
1
按前面的理解，==(4 + foo)==会展开成==(4 + (4 + foo))==，然后一直展开下去，直至内存耗尽。但是，预处理器采取的策略是只展开一次。也就是说，foo只会展开成==4 + foo==，而展开之后foo的含义就要根据上下文来确定了。

对于以下的交叉引用，宏体也只会展开一次。

#define x (4 + y)
#define y (2 * x)
1
2
x展开成(4 + y) -> (4 + (2 * x))，y展开成(2 * x) -> (2 * (4 + y))。

注意，这是极不推荐的写法，程序可读性极差。
在宏体中，如果宏参数前加个#，那么在宏体扩展的时候，宏参数会被扩展成字符串的形式。如：
#include <stdio.h>


#define PSQR(x) printf("the square of "#x" is %d.\n",((x)*(x)))

#define PSQR2(x) printf("the square of %s is %d.\n",#x,((x)*(x)))


int main() 
{
    
int R=5;

    
PSQR(R);  //the square of R is 25.
    
PSQR2(R); // the square of R is 25.

    
return 0;

}

#include "stdafx.h"
#define PSQR(x) printf("the square of #x is %d.\n",((x)*(x)))
#define PSQR2(x) printf("the square of %s is %d.\n",#x,((x)*(x)))
#define WARN_IF(EXPR)\
do {\
    if (EXPR)\
        fprintf(stderr, "Warning: EXPR \n");\
} while(0)

int main(int argc, char* argv[])
{
	int R=5;
	printf("Hello World!\n");
	PSQR(R);  //the square of R is 25.
    	PSQR2(R); // the square of R is 25.
	WARN_IF(R>0);
 	return 0;
}

可变宏：… 和_VA_ARGS
有些函数(如==prinft() #06906d==)可以接受可变数量的参数。

  int __cdecl printf(const char * __restrict__ _Format,...);
1
实现思想就是在宏定义中参数列表的最后一个参数作为省略号（三个句号）。这样，预定义宏_VA_ARGS就可以被用在替换部分中，以表明省略号代表什么，

可变数量的参数

   __FUNTION__  获取当前函数名 
    __LINE__ 获取当前代码行号 
    __FILE__ 获取当前文件名 
    __DATE__ 获取当前日期 
    __TIME__ 获取当前时间
    __STDC_VERSION__


易中天：别望子成龙，要望子成人 
https://www.sohu.com/a/60126055_356623
第二是善良。善良不是说要你到街头去做什么义工，或者学雷锋的那天去扶老太太过街。善良的底线是恻隐之心。恻隐之心就是不忍之心，不忍心人家受到

无辜的伤害，包括对小动物。所以不但不能行凶杀人，也不能虐待小动物。我们要在法律上保证公民的恻隐之心不受伤害。
第四个就是快乐。快乐是非常重要的。在孔夫子那里，做人的最高境界是仁，做事的最高境界是权（权衡），治学的最高境界是乐。知之者不如好之者，好之者不如乐之者，快乐是最高的境界。其实人很简单，成功不成功，是否出人头地，是否光宗耀祖，都不重要，重要的是你是否快乐。
比方说现在为什么千军万马过独木桥，大家都要去考公务员呢？我非常同情大学生毕业以后挤破脑袋去考公务员，虽然我不赞成，但是我非常理解非常同情，他缺乏的是安全感。
有一个农村来的孩子就这样对记者说的，我也不想考公务员，但是我爸我妈让我考。我爸我妈说，孩子，你要考上公务员，咱在村里就不受欺负了。他要的就是一个安全感。
所以我们的社会应该给每个公民提供足够的安全感，让每个公民有足够的尊严，不管他从事哪个职业，不管他在哪个岗位上，他都是一个安全的、有尊严的人，这样他才能快乐。

美卫生局局长说戴口罩会增加普通人感染风险，呼吁民众停止购买
https://new.qq.com/omn/20200303/20200303A021A300.html?pgv_ref=aio2015&ptlang=2052

source insight的特定变量,宏定义等黑色,怎么办
//public:  //注释掉这个关键字即可.
或 隔离public 十个空白行以上即可(v ok)

微信娱乐看太多，影响计划看书.

2020.03.03

C语言中宏定义的使用
https://blog.csdn.net/imgosty/article/details/81901183?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task

C语言中宏定义的使用
https://blog.csdn.net/imgosty/article/details/81901183


C语言宏定义的几个坑和特殊用法
https://blog.csdn.net/qq997843911/article/details/62042697
宏体换行需要在行末加反斜杠\
宏名之后带括号的宏被认为是宏函数。
展开后的代码有利于CPU cache的利用和指令预测，速度快。缺点是可执行代码体积大。

C语言宏的特殊用法和几个坑
https://blog.csdn.net/miaomao1989/article/details/77481981
AFTERX(BUFSIZE)会被展开成X_BUFSIZE。因为宏体中含有##，宏参数直接代入宏体。
XAFTERX(BUFSIZE)会被展开成X_1024。因为XAFTERX(x)的宏体是AFTERX(x)，并没有#或##，所以BUFSIZE在代入前会被完全展开成1024，然后才代入宏体，变成X_1024。


如下解决在在source insight中，一般即使鼠标点在函数或者变量处，context windows窗口就会显示其定义信息。
其中绿色的变量或者函数，鼠标一点击，就能看到其定义。黑色的则看不到的问题(v ok)

D:\Program Files\Source Insight 3\C.tom
; wendy add
FUNC_DECL(factory_name) DECL_##factory_name

E:\wendy_work\MsEdit_Wendy\ShowData.cpp
#define FUNC_DECL(factory_name) DECL_##factory_name
...
void FUNC_DECL(FactoryA) (void)
{
	int i, j;
	i = 0;
	j = 1;
}

void FUNC_DECL(FactoryB) (void)
{
	int i, j;
	i = 0;
	j = 1;
}
...
int CShowData::op_delay(_tagTTDataFrame *pStFrame)
{
	DECL_FactoryA();
	DECL_FactoryB();
...
}

Source Insight解析Linux内核的c.tom文件内容
https://blog.csdn.net/nust20/article/details/46486947?locationNum=4
在C:\Documents and Settings\XXXX\My Documents\Source Insight目录下的C.tom文件中增加如下内容（需要不断完善，碰到不能解析的宏时添加进来）。
添加后，关闭SourceInsight工程，重新打开，重新同步。


source insight宏定义函数名显示问题 [问题点数：50分]
https://bbs.csdn.net/topics/392500161
本义是一套代码工程内，有多个模块功能类似，但是函数名不同，为了便于快速批量修改函数名，增加了这个宏定义。
这样修改函数名，只需要修改FUNC_DECL宏就行了，即针对T模块，把FUNC_DECL改成： FUNC_DECL(name) T_##name
这样改，编译是通过了，但是在source insight里面，显示不出函数名，如何才能显示出函数名全称，即能够包含模块名称的？
Source Insigh目录，其中有一个C.tom文件。修改该文件，在其中增加一行：
FUNC_DECL
试试

Source Insight 不能识别变量定义怎么解决？ [问题点数：40分，无满意结帖，结帖人Swordsemperor]
https://bbs.csdn.net/topics/392276081?page=1
解决了，因为类声明后面加了个宏定义 SHIT

source insight的特定变量,宏定义等黑色,怎么办
//public:  //注释掉这个关键字即可.(v ok)

/*
!% 
!?CChartingGroup.m_groupCode		[.] 类CChartingGroup属性: 市场代码
*/
	BYTE			m_groupCode ;	

https://zhidao.baidu.com/question/572897720.html
菜单中选择 Project -> Rebuild Project -> Re-Create the whole project from scratch -> OK
然后再看看是否好了.

在source insight中黑色变量的解决办法
https://blog.csdn.net/sishuirensheng66/article/details/35280513
在source insight中，一般即使鼠标点在函数或者变量处，context windows窗口就会显示其定义信息。
如下图所示，其中绿色的变量或者函数，鼠标一点击，就能看到其定义。
黑色的则看不到，可是我的这里面黑色的占了很大一部分比重.
解决方法：
没有同步文件，在“项目”（Project）->“同步文件”（Synchronize Files）。并勾1、2和4项，然后OK。就可以了


source insight 里的函数有时候会突然变黑
https://blog.csdn.net/chen_chuang_/article/details/48462615?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task
找到原因了方法自然就有了：project -> add and remove project files 重新把整个工程的代码添加下，然后同步。ok。

2020.03.02

天眼查
https://www.tianyancha.com/?jsid=SEM-BAIDU-PZ2001-SY-000001
浙江省义乌市廿三里街道通宝路1341号附近公司
实缴资本	100万人民币
法定代表人：杨秋兴 注册资本：100万人民币成立日期：2012-03-13
翁易华


开机黑屏只有鼠标,小编教你电脑开机黑屏只有鼠标箭头怎么解决
http://www.xiaobaixitong.com/win10jiaocheng/25651.html
电脑黑屏是比较容易出现的现象，尤其在一些较老的电脑或组装电脑中。如果你的电脑开机出现了黑屏，但是鼠标箭头可以动，那么可能就是explorer.exe系统文件造成的问题。
在打开的注册表编辑器窗口，依次展开：HKEY_Local_MACHINE\Software\Microsoft
在Microsoft的展开项中再依次展开：Windows NT\CurrentVersion
在CurrentVersion的展开项中找到：Winlogon，并左键单击：Winlogon
在Winlogon对应的右侧窗口，找到Shell，左键双击Shell，如果Shell的数值数据为：explorer.exe，则是正确的，如果不是explorer.exe，则把Shell的数值数据更改为：explorer.exe（如还有其它字符，请删除），再点击：确定

电脑开机后进入不了桌面只显示一个黑屏和鼠标箭头
https://zhidao.baidu.com/question/1241360265800857699.html
同时按“ctrl+shlft+exc”键，调出任务管理器。
点击任务管理器左下角的“详细信息”。
然后点击左上角“文件”里的“运行新任务”。
弹出新窗口，输入“explorer.exe”，然后点击“确定”。
以上就是电脑开机黑屏只有鼠标的解决办法，当然，上述方案不是对所有电脑都有用，因为电脑黑屏的原因有很多种，这里只是其中的几种解决办法。
1、可以直接使用“Ctrl + Shift + Esc”快捷键直接打开任务管理器程序；
2、弹出任务管理器后，在“进程”选项卡中找到“explorer.exe”进程；
3、选中“explorer.exe”点击下方的“结束进程”按钮，关闭资源管理器；
4、然后点击左上角的“文件”打开菜单，选择“新建任务(运行)”；
5、之后会弹出“新建新任务”窗口，输入刚刚关闭的进程名称“explorer.exe”，点击确定即可。

(3)如果通过手动启动explorer资源管理器不起作用，那可能是explorer被破坏了，可到备份中或系统光盘中提取个explorer.exe，或者到网上下载，也可以到其它电脑上复制一个放在C:\Windows下。如果上面的方法还不行，那就只有重做系统了。

做电脑维修多年了，这种情况是因为不正常关闭了桌面系统，造成了开机只有鼠标箭头和黑屏，Explorer可以新建一个。看看行不行，实在不行开视频指导看下。送修也就30-50.


疫情开始在日本全国蔓延？日本为什么不让3000多人下船？
https://baijiahao.baidu.com/s?id=1658756112490425875&wfr=spider&for=pc
考虑之一，这不是日本船
在日本政府看来，如果单放乘客入境，不让船员入关，有歧视之嫌；如果破例放这艘“外国船”自由入关，那么总得对其他邮轮一视同仁，而以日本为目的地的外国邮轮不在少数（2月份原定就有13艘），其中总有途经中国而乘客中出现发热咳嗽的，如果前例一开，后患将无穷――在别国被拒绝入境的邮轮，可能转道直奔日本来求助。事实上，日本2月6日拒绝了经停香港的荷兰“威士特丹”号邮轮的靠泊请求，后者只能在柬埔寨西哈努克港栖身。

考虑之二，日本医疗资源配给跟不上
尽管日本是长寿之国，应对各种灾难事故门儿清，但全国能收治新冠肺炎的病床有限（估计不到2000张）
检测试剂也不可能按需拨给“钻石公主”号，所以马上对邮轮上逾3700人一一检测，以便他们及早下船，就成了不可能的任务。
就算邮轮上的乘客以日本人为主（1200多人），但在检测时也不能单独给日本人开口子，否则有碍国际观瞻，邮轮经营方也不会轻易答应。而如果按照轻重缓急排队检测，那么很大部分被检测者并非日本国民，却要消耗掉日本目前有限的检测资源，这在工作优先度上就会被打折扣――哪怕国际上沸反盈天，日本政府都要先满足已入境的本国国民的需求。
换句话说，假设全体乘客上岸了，同样会被限制在小范围内活动，且服务人员未必有邮轮上那么周到，而日本国的应急医疗资源是向已确诊者倾斜的，普通邮轮乘客还是稍安勿躁为妙。

考虑之三，离日本首都圈近在咫尺
若等绝大多数乘客上岸后再进行甄别和收治，的确可以减少在邮轮密闭空间内的交叉感染概率，但却增加了病毒在日本本土扩散的风险。
尤为重要的是，横滨港背靠人口超过4000万的东京湾城市群，从这里打车去东京羽田机场不过十多分钟。若新冠病毒在这个日本的经济中枢暴发，有可能令日本经济整体陷入瘫痪。
我们还可以对比2011年福岛核电站事故。如果说，陆上核泄露范围相对固定，对首都圈影响不大，那么靠泊在横滨港的这艘英美邮轮，就相当于一座可移动的核电站，在关停之前如果任意移动潜在感染人群，后果将不堪设想。

以上种种思虑，可能主导了日方的“封船”决定。同时，日方也有3点疏忽，受到了诸多批评，所以后来做了某些变通和调整。

首先，负责“接诊”的日本厚生劳动省，动作不够麻利。
日方怀着侥幸心理，在邮轮从香港抵达冲绳时，对每一位乘客与船员测了体温，说是“太平无事”（实际上是潜伏期）；

其次，高估了“钻石公主”号自身的防护、隔离措施。
“公主邮轮公司”所做的，除了提供免费的无线网络和室内娱乐活动，就是退还乘客旅行费用，同时免收隔离期间的餐饮住宿费，再送下次搭乘的优惠券；对于乘务人员，承诺其在乘客隔离期间工作日加薪2倍，以后允许所有船员带薪休假两个月。
钱的确能安抚部分人心，但阻止不了病毒扩散。邮轮上的英美人士，并不像亚洲人那么好说话。来自英国的婚礼策划师大卫・阿贝尔（David Abel），在脸书上定时直播船上情况，一度表示自己与妻子已经超过14小时没有获得食物。

众目睽睽之下，“邮轮惊魂”不仅拷问着日本的“战疫”力，也关系到东京奥运会能否正常举行――目前已有多项奥运预选赛受到疫情影响推迟举行。东京奥运被认为将吸引国内外约1000万游客，如果疫情无法平息，或者海外观感不佳，现有的巨额投入将会打水漂……




借力打力，复这边贴那边......（象棋，微信...）呵呵



电脑开机黑屏只有一个鼠标箭头处理办法
https://jingyan.baidu.com/article/6fb756ec87ce0c241858fb11.html
同时按下shift+alt+delete键或shift+ctrl+esc键调用任务管理器程序。
打开任务管理器，然后选择”进程“选项卡,在进程中找到 explorer.exe 个进程。
点击结束进程按钮，结束该进程。
点击文件-新建任务。
在弹出的对话框中输入”explorer.exe“，点击确定。
计算机中毒了，或是启动项太多了，杀毒，或者实在不行，重新做系统吧
这种情况大多数是系统问题，但出在那没实地看说不清

平凡的世界
https://baike.baidu.com/item/%E5%B9%B3%E5%87%A1%E7%9A%84%E4%B8%96%E7%95%8C/166?fr=aladdin
平凡的世界 （路遥著长篇小说） 编辑 讨论92
《平凡的世界》是中国作家路遥创作的一部百万字的小说。这是一部全景式地表现中国当代城乡社会生活的长篇小说，全书共三部。1986年12月首次出版。
该书以中国70年代中期到80年代中期十年间为背景，通过复杂的矛盾纠葛，以孙少安和孙少平两兄弟为中心，刻画了当时社会各阶层众多普通人的形象；劳动与爱情、挫折与追求、痛苦与欢乐、日常生活与巨大社会冲突纷繁地交织在一起，深刻地展示了普通人在大时代历史进程中所走过的艰难曲折的道路。1991年3月，《平凡的世界》获中国第三届茅盾文学奖。2019年9月23日，该小说入选“新中国70年70部长篇小说典藏”。 [1]

养成想到就做的习惯: 万卷网站. 93VC1 98VC6 200多个类库.4号线和3号线少年宫.wizard typical等.

工程->设置->连接
D:\Johnny\W2T20140130c\DataCenter\bin\MsEdit.exe
工程->设置->调试
D:\Johnny\W2T20140130c\DataCenter\bin\MsEdit.exe

GetModuleFileName
https://baike.baidu.com/item/GetModuleFileName/9585201?fr=aladdin
GetModuleFileName 编辑 讨论
获取当前进程已加载模块的文件的完整路径，该模块必须由当前进程加载。
如果想要获取另一个已加载模块的文件路径，可以使用GetModuleFileNameEx函数。


AI换脸产业链起底,可定制女明星不雅视频,150元打包700部视频

https://baijiahao.baidu.com/s?id=1639369194218993604&wfr=spider&for=pc
不雅视频将女明星AI换脸成主角售卖：迪丽热巴，杨幂，赵丽颖，佟丽娅，刘亦菲，Angelababy......

海关发现男子所带花生不对劲 剥开壳一看直接惊呆
https://wxn.qq.com/cmsid/AUS2020021700606401

一个月！广东口罩日产量从不足十万涨到逾二千万
https://new.qq.com/omn/20200227/20200227A0PXQ900.html?pgv_ref=aio2015&ptlang=2052

2020.02.28 

小米之家维修小米手机基带多少钱
https://zhidao.baidu.com/question/1769392383725435300.html
100～200元左右吧

淘来一个小米8，有通病基带版本未知没信号，拆解我教你修复它
https://www.iqiyi.com/v_19rvxtlw8k.html

网上寄修米8，本来只是基带坏了，他把我整个cpu都修坏了该怎么弄？
http://tieba.baidu.com/p/6115558680
除了官方其他都是坑，修好了还好，修不好就说你咬我呀！我修电脑也遇见过
我现在手机以后除了官方维修其他一律不信，我小米6摔爆屏拿去修，屏幕不是原装，然后手机还留下一些毛病比如闹钟不响，打手机不响等等，边框我记得之前是没痕的，修了以后多了几道深痕，我看十成是换了，后盖也被换了，整台手机怕不是能换都换了，换一些次品给我，我没法只好买小米9了

小米8老是没网，又是无线都断网，而且没有信号，一直无服务状态，这是怎么回事，怎么修理，跪求
http://tieba.baidu.com/p/6076365784?pn=1
贴吧用户_00G9CMt: 修了吗，我的也是，维修说是我摔得问题，要我500块，还没修 2019.12.09
青春染指浮华丶: 我也是一模一样，去售后说我主板坏了要修我主要200还不一定修好卧槽 2019.12.17

求助 小米八有一点发热就断网 数据wifi失灵
http://tieba.baidu.com/p/6494405626?pid=130017305151&cid=#130017305151

维修点地址：深圳市龙华新区和平路宝银坊商场L2-53号（龙华地铁站D出口）深圳市龙瑞贸易商行
售后服务电话：0755-88863922/29560669 预约维修
区域：广东深圳龙华新区
营业时间：10:00-18:00（支持周三晚8点服务）
售后维修产品类型：小米手机维修,小米平板维修,小米笔记本维修,小米扫地机器人,小米全系产品维修


小米8修个基带小米8基带坏了怎么修？（看简介）？
https://www.zhihu.com/question/372920555
这是小米8的通病，有很多小米8用户都出现类似状况。例如WiFi无法打开，sim卡不识别等情况。这一般都是因为基带虚焊引起的，可以修。建议前往当地比较大的修理店。去了直接说手机基带可能虚焊了，价格在150左右。不要被骗换主板！不要被骗换主板！不要被骗换主板！

作者：花自飘零水自流
链接：https://www.zhihu.com/question/372920555/answer/1028844903


小米8没有信号WIFI打不开，设置显示基带版本未知，看大神如何完美修复它
https://www.bilibili.com/video/av89530814/


小米8信号断断续续有时候打电话发不出去，接也接不了。这是卡的问题还是手机的问题啊
http://tieba.baidu.com/p/6074881895
辣鸡小米 我的也一样故障，突然就没信号了，售后说基带坏了，换主板1000多，以后誓死不买小米！售后太辣鸡！


退货服务。 使用服务星期六  499元.

我那时候就看过杨思敏

北京一女子确诊，22日从武汉回京，此前发热多日！她是怎么离开武汉的？
https://mp.weixin.qq.com/s/ayQ33VXBrn4-IQjL9jIuQw
这个北京新冠确诊女人成为撞上风口的猪了。全国人民都看着这头飞上天的飞天猪如何摔下来了。
这新闻还真是疫情期间的一个炸弹。 所有被封城不满的情绪都会发泄在这些关系人身上了。

2020.02.27

查找:A00013 文件:today_A.dat

		if( strcmp( head.fileType, "chartingDayData" )!=0 || ( head.ver!=0.0 && head.ver!=0.1 )  )
			goto ErrExit ;


GroupsMng.dll
Groupmng.dll
查找其中的一部分.问沟通节省研究时间(v ok)

BOOL Master::CreateGroupsMng()
{
	if( m_pGroupsMng!=NULL )
		return TRUE ;
	
	HRESULT ret = CoCreateInstance( CLSID_TTGroupsMng, 
		NULL, CLSCTX_ALL,
		IID_IUnknown, (LPVOID*)&m_pGroupsMng );
	int n=GetLastError();
	if( ret!=S_OK || m_pGroupsMng==NULL )
	{
		m_pGroupsMng = NULL ;
		g_Log.Log("Groupmng.dll load fail!");
		return  FALSE ;
	}
	
	g_Log.Log("Groupmng.dll Ok.");
	CComQIPtr<ITTObject,&IID_ITTObject> pObj(m_pGroupsMng);

缺少组件: Groupmng.dll

2020-02-26 15:12:08(27256416), ==========================Start==========================
2020-02-26 15:12:42(27290424), Groupmng.dll load fail!
2020-02-26 15:22:37(27885724), ==========================Start==========================
2020-02-26 15:22:44(27892058), Groupmng.dll load fail!
2020-02-26 15:28:41(28248863), ==========================Start==========================
2020-02-26 15:28:44(28252358), Groupmng.dll load fail!


int (*a)[10] 和 int *a[10] 的区别
https://blog.csdn.net/u014183456/article/details/80348217
首先,int *a[10]  :   是数组指针,本质上就是数组元素是是个int型指针的一维数组,
int (*a)[10] :   a是指针，指向一个数组。此数组有10个int型元素


结构体的声明，定义及其初始化，C语言结构体完全攻略
http://c.biancheng.net/view/241.html

C/C++ typedef用法详解（真的很详细）
https://blog.csdn.net/andrewniu/article/details/80566324
第一、四个用途
用途一：
定义一种类型的别名，而不只是简单的宏替换。
用途二：
用在旧的C的代码中（具体多旧没有查），帮助struct
用途三：
用typedef来定义与平台无关的类型。
比如定义一个叫 REAL 的浮点类型，在目标平台一上，让它表示最高精度的类型为：
typedef long double REAL; 
在不支持 long double 的平台二上，改为：
typedef double REAL; 
用途四：
为复杂的声明定义一个新的简单的别名。
方法是：在原来的声明里逐步用别名替换一部分复杂声明，如此循环，把带变量名的部分留到最后替换，得到的就是原声明的最简化版。举例：
2. 原声明：void (*b[10]) (void (*)());
变量名为b，先替换右边部分括号里的，pFunParam为别名一：
typedef void (*pFunParam)();
再替换左边的变量b，pFunx为别名二：
typedef void (*pFunx)(pFunParam);
原声明的最简化版：
pFunx b[10];
理解复杂声明可用的“右左法则”：
从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：
int (*func[5])(int *);
func 右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个*，说明func的元素是指针（注意这里的*不是修饰func，而是修饰 func[5]的，原因是[]运算符优先级比*高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指 针，它指向的函数具有int*类型的形参，返回值类型为int。
也可以记住2个模式：
type (*)(....)函数指针 
type (*)[]数组指针
...
同样，可以象下面这样隐藏指针语法：
typedef char * pstr;int mystrcmp(pstr, pstr);
这里将带我们到达第一个 typedef 陷阱。标准函数 strcmp()有两个‘const char *’类型的参数。因此，它可能会误导人们象下面这样声明 mystrcmp()：int mystrcmp(const pstr, const pstr); 
这是错误的，按照顺序，‘const pstr’被解释为‘char * const’（一个指向 char 的常量指针），而不是‘const char *’（指向常量 char 的指针）。这个问题很容易解决：
typedef const char * cpstr; int mystrcmp(cpstr, cpstr); // 现在是正确的
#define与typedef引申谈 
　　1) #define宏定义有一个特别的长处：可以使用 #ifdef ,#ifndef等来进行逻辑判断，还可以使用#undef来取消定义。 
　　2) typedef也有一个特别的长处：它符合范围规则，使用typedef定义的变量类型其作用范围限制在所定义的函数或者文件内（取决于此变量定义的位置），而宏定义则没有这种特性。
 

2020.02.26

 QuickHider(快速隐藏任务栏图标工具)
http://mydown.yesky.com/pcsoft/413546249.html


电影《速度与激情8》详细剧情第1章：多一个朋友很重要
https://www.tvmao.com/movie/YmRnayRe/chapter


骑自行车专心一直向前，转弯或偏移要看旁边（专心）。经理传的项目没复制（向前想）

读MDS数据Dlg->添加文件->删除文件->读取数据->显示结果数据Dlg:
一直显示 search....ListIndex = 0, GetIndex=递增(x no)
void CShowData::OnTimer(UINT nIDEvent) 
{...
	if (InitClistGetHead == FALSE)
	{
		ps = mCListDataFrame.GetHeadPosition();  // wendy
		InitClistGetHead = TRUE;
	}
...}(v ok)

五一之前，不管新闻怎么说，防控怎么降级，尽量减少出门次数，出门带口罩，进门消毒，出去买菜一次多买点，不要天天出去，在家运动，必须上班的，单位和家两点一线，别乱逛，单位工作时刻警惕，口罩带好，别坐公交，别上饭店，别串门，为什么？一、到现在还没有特效药；二、治疗好的出院后还有反复；三、每天还是百人死亡；四、无症状患者的存在；五、病毒发源地不在武汉；六、疫苗最快四月底才临床试验，成功否还要验证半年；七、病毒排查试剂盒有效率才百分之五十；八、最长潜伏期有达到27天的；九、新冠病毒可能会与人类长期共存；十、该病毒不光影响肺部和呼吸，对心脏等其他脏器也有严重影响；十一、其他国家确证人数也在上升；十二、口罩还是买不到，医院除急诊和发热呼吸科外，其他科室都先停诊。以上所说的，希望我的家人们，要保持高度警惕，国家放松控制，允许人员流动，那是考虑国家经济方面，没办法再封村封路封小区，年前各类生产企业屯的库存也即将消耗殆尽，不开始生产，人们的日常生活所需接济不上，要保社会稳定，必须开工复工，但是不代表这场战役结束了，老人们身体弱，有很多基础病，要少出门，在家做运动，这个时候怕生病，医院诊所都不开！
(wx)

2020.02.25

中国各有多少个省和自治区和直辖市
https://zhidao.baidu.com/question/1705615336985242380.html
截至2018年10月1日，中国一共有34个省级行政区，包括23个省、5个自治区、4个直辖市、2个特别行政区。
23个省：河北省、山西省、辽宁省、吉林省、黑龙江省、江苏省、浙江省、安徽省、福建省、江西省、山东省、河南省、湖北省、湖南省、广东省、海南省、四川省、贵州省、云南省、陕西省、甘肃省、青海省、台湾省。
5个自治区：内蒙古自治区、广西壮族自治区、西藏自治区、宁夏回族自治区、新疆维吾尔自治区。
4个直辖市：北京市、天津市、上海市、重庆市。
2个特别行政区：香港特别行政区、澳门特别行政区。


MFC总结之CListCtrl用法及技巧（二） .
https://www.cnblogs.com/lidabo/archive/2012/08/23/2652792.html

MFC总结之CListCtrl用法及技巧（一） .
https://www.cnblogs.com/lidabo/archive/2012/08/23/2652786.html

MFC CListCtrl不响应LVN_GETDISPINFO消息
https://blog.csdn.net/kiss_xq/article/details/51019402?locationNum=11&fps=1
好吧，深呼吸，程序员是不怕坑的。总结一下：
在CListCtrl Create了之后再去设置LVS_OWNERDATA目测是没有用的，必须在Create的时候就把这个style写上。

last和latest做最新的，最近的时有什么区别
https://zhidao.baidu.com/question/100723010.html?qbl=relate_question_5&word=lastest

最新滚动新闻_网易新闻中心
http://news.163.com/latest

读书的方法和技巧 高效读书的10种方法
http://www.gaosan.com/gaokao/227405.html
读书不二法
波浪渐进法
比较品读法
垂直阅读法:因为有些书含金量太少，只用浏览。更快的方法也称之为“跳读“
字斟句酌法:用眼睛来读书只有眼见，用心去读书才有心得。字斟句酌法特别适合读经典。
精华提炼法:读完一本书，如果真能够提炼出几句有用的话来，就算没有白读。
高山仰止法:以欣赏的眼光读书，读出乐趣。
居高临下法
多维研读法
举一反三法:如何把书读活？“我思故我在，我用故我能。”
“我思”的第一个层次是要与作者交流，与作者擦出火花；第二个层次是要讲给别人听、写给别人看，与众人擦出火花。“我用”的第一个层次是理论指导自己的实践，让自己受益；第二个层次是在用中发现新问题，找到新方法，创造出新理论，超越前人。


其实 什么事情 兴趣是最好的老师
https://zhidao.baidu.com/question/8869441.html?sort=11&rn=5&pn=10#wgt-answers
好读书 不求甚解 这是说读书要快 诸葛亮就是这一点 他的知识超过他的两位师兄弟的
一楼刚开始说的是精读 就是慢读书
对于容易理解的东西就一目一行的读 对与不容易理解的 东西就是就精读了
我认为现在学校里的学生不会对教科书赶兴趣

高效快速阅读的四大方法和技巧
https://baijiahao.baidu.com/s?id=1637649005865475992&wfr=spider&for=pc
引导物阅读法
节拍阅读法
压痕阅读法经过反复联系，随着快速阅读能力的提升，将可以做到视点放在中间就可以看清整行甚至几行的文字，从而达到一目一行甚至三五行的效果。
面视阅读法
要达到这一效果，我们在整个阅读过程中，视点都必须始终保持在书页的中轴线做自上而下的垂直运动，利用眼睛的余光将两端的文字置于整个有效视幅范围内，达到快速识别理解阅读内容的目的。
需要强调的是，面视阅读在提高速度的同时一定要保证内容的理解
学以致用，活学活用。阅读的方法和技巧数不胜数，贵在精，难在勤。掌握要领，多读勤练，每天进步一点点，阅读速度的提升自然水到渠成。高效快速阅读，你能行！

如何正确的看书
https://jingyan.baidu.com/article/d3b74d64f4e8141f77e60994.html(MM v ok)
要学会思考问题。看书如果只会麻木的看，就只会增添无用知识罢了，所以不要做个木偶，呆呆的看，要去思考。在看的过程中，要去问自己问题，不懂的话最好要仔细阅读。
不要狼吞虎咽。看书就好比吃饭，如果只顾着吃，却不懂的去品味，那就是个屠夫罢了，对生活并没有多大的帮助。因此，看书要注意，不要为了看几本书而去看，而是为了吸取他的精华而去品味咀嚼，这个是看书很重要的一个思想。
在看书的过程中不要边看边做笔记，这是十分会影响看书氛围的一个行为，虽然很多人看似觉得没什么关系，但是这会将你的思考打断，是不利于你看书的一个行为，所以最好是做好记录，哪里需要做，看完后再做笔记。
看书最好不要超过一个星期。要知道，人的记忆是有限的，如果你一个星期都没把一本书看完，那么里面的很多内容你是很难连接上的，这是很影响看书的。所以，给自己限制一个时间吧，学会约束自己。(v ok)
如果你看的这本书对你来说是十分有价值的，我觉得这本书是值得你读三遍的。因为好书读一遍是很难吸取到它的精华的，所以多读几遍才能将作者想表达的了解的更加透彻。(v ok)

怎样正确的看书
https://jingyan.baidu.com/article/f006222869d1f1fbd3f0c892.html
第一  阅读目录。
第二  阅读序言
第三 阅读正文。一般而言，正文内容比较多。但是。我们需要慢慢的阅读和理解。有些时候，作者为了使得读者理解这本书的内容，还编绘了一些图表，这样可以一目了然。作为读者来说，本书的前几章是比较重要的内容。
第四 精读和泛读。我们要明确哪些书籍需要精读和泛读。但这两者并不矛盾。当我们对一本书精读的时候，需要边阅读边思考。毕竟，思考的内容是自己的。
第五 阅读次数。不是所有的书籍都需要反复阅读。...反复阅读一本书能够使得你有着比较新的认识和理解。

怎么快速又有效的看书
https://jingyan.baidu.com/article/bea41d438bc7c5b4c41be648.html
当今网上卖的书都是很齐全的，可以买一些自己当下特别想升华自己的书籍，一个月最低计划四本书，不然你看这个经验并没有充分吸收到核心的看书方法。
总之，一本书在四至五天之内看完，但不宜看得过多，不然你会有排斥感，这种排斥感将导致你下次不想看书。
再谈速度，你必须明白你到底想在书本上获得什么知识，必须带着重度的目标感看书，这样看书精力集中了，速度提起来了，也不会乏味，不知不觉时间过去了，书也看完了，而且你会有所印象和感受，尽管这种印象不是很深刻，但好像能为你所用了，如果对于核心想关注的知识，再去看相关知识的精准页。
除了目标任务量和速度，你还需要全身心集中精力，切记不能边看书吃东西、听音乐、交谈等，你必须专心，只是看书，其他什么事都不做，当然上厕所和接电话等临时简短时间除外。(v ok)
在这里我就要说说签字笔的作用了，看书不是单纯的翻翻看看，那样不仅无趣，收获效率太低，所以，在你看书的同时，你需要对你感兴趣和目标知识点做勾勾画画，融入自己所思所想写下来，不要嫌刚买的新书就画脏了，你有这种思维本身就是错的，即使你字写得太差也没关系，看书是为了收获知识，并不是买来当收藏品。(拍照)
最后，你需要结合你自己的实际了，理论联系实际，看书不能指导和服务生活，又有什么用，你需要不断联系实际，为自己的世界添加色彩。

怎么提高学习效率
https://jingyan.baidu.com/article/a948d651af91574a2ccd2e0c.html
不要为结果而学习，只注重努力的过程，学习要有信心，养成记笔记的好习惯。

如何高效学习
https://jingyan.baidu.com/article/c35dbcb0b8d49f8916fcbc22.html
获取知识，理解所要学习的材料的内容。
验证知识.(v ok)
(复述所获得的主要内容。
用自己的方式以潜意识的形式复述所学到的知识。
纠错反馈，用所学到的知识解决实际问题。
反思，反思在思考的时候哪里卡了壳，这个过程至关重要。
检验，找一些综合问题来思维风暴一下。)

Source Insight 文件和源代码文件分离，如下填写
New project name: MsEdit_Wendy
Where do you want to store the project data files?
E:\sourceIns\MsEdit_Wendy
project source Directory- the main location of your source files:
E:\wendy_work\MsEdit_Wendy


New project name:project_name
Where do you want to store the project data files?
C:\Users\Wendy\Documents\Source Insight\Projects\project_name

project source Directory- the main location of your source files:(next page)
C:\Users\Wendy\Documents\Source Insight\Projects\project_name

Add and Remove Project Files(next page title)

E:\sourceIns\MsEdit_Wendy\readme.txt: E:\wendy_work\MsEdit_Wendy

2020.02.24

_UNICODE,UNICODE -> _MBCS,

VC++ 6.0中关于UNICODE和_UNICODE的问题总结
https://blog.csdn.net/u012132050/article/details/45113959
在TCHAR.H头文件中总体的结构如下： 
/* For backwards compatibility */为了向后的兼容性
#ifdefine _UNICODE     //如果定义了_UNICODE标识符，字符或字符串则按照宽字符集进行编码
1、在”工程项目“中设置属性，C/C++选项下的Preprocessor definition中，默认是按照多字节字符集进行编码的如图，即没有定义_UNICODE和UNICODE，所以_T(x)将按照x进行编码存储，即按照ASCII码。    MessageBox将按照MessageBoxA()进行输出，即按照ASCII码。 所以他们的编码表是一致的，所以输出正常。
2、如果在Preprocessor definition中添加UNICODE或者_UNICODE中的任何一个则上面的程序就出现乱码或者显示不完全的现象。

  如果添加UNICODE：

     则MessageBox将按照MessageBoxW进行输出，即宽字符输出，但是_T(x)由于没有定义_UNICODE,所以依然按照ASCII进行编码即为x,两个字码表不一致           

     所以就会出现乱码。

  如果添加_UNICODE:（注意前面有下划线）

     则MessageBox()将按照MessageBoxA进行输出，即ASCII或多字节字符集，但是_T(x)会按照L##x，即宽字符进行编码，即一个字符占用两个字节，低字节在前，高字节在后，所以在输出字符时候，比如编码为0x0041,而存储的顺序则为0x41,0x00,所以MessageBox再按照ASCII码进行输出时只会输出一个字符而把0x00当做字符串结束标识。所以最终只会输出一个字符。

     

因此在VC++6.0中需要将两个同时添加到里面才会显示正常，如图。


error C2664: '_wcsicmp' : cannot convert parameter 1 from 'const char *' to 'const unsigned short *'
_UNICODE,UNICODE -> _MBCS, (v ok)

error C2664: “FindFirstFileW”: 不能将参数 1 从“char [260]”转换为“LPCWST
https://blog.csdn.net/jindou910101/article/details/9188029
解决方法：
1、把工程设置里去掉UNICODE宏定义
      项目->XXX属性->配置属性->常规->字符集 改为 “未设置” 就去掉了unicode支持，不过应该回报一个警告
 
      如果实在找不到也可以在#include <windows.h>之前加上一句
      #undef UNICODE
      来解决
2、或者，你全部使用
      TCHAR替换char
      字符串常量用_T()括起来，如_T("*")



#include "..\common\DataProxy.h" 

#include "..\Common\DataProxy_i.c"

(v ok)

SOURCE=..\Common\WTTCommon.idl
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# Begin Source File

SOURCE=..\Common\DataProxy.idl
# ADD MTL /tlb ".\DataProxy.tlb" /h "DataProxy.h" /iid "DataProxy_i.c" /Oicf
# End Source File
# Begin Source File





怎么在VC++6.0环境下编译一个IDL文件？ [问题点数：50分，结帖人firecityplans]
https://bbs.csdn.net/topics/310068194
把接口ITimeBeijing的声明放到 library TimeBeijingLib 内
或者在Project Settings中去掉"MkTypLib compatible"


求助 Regsvr32注册成功 但在注册表CLSID里没有发现该键值 [问题点数：100分，结帖人yanweiqi]
https://bbs.csdn.net/topics/340192507
Bbs1	
谢谢啦--oyljerry
果然是rgs文件的事情，我手工修改了rgs文件后就可以了。

492E31D4-B80D-11D3-AF24-00A0CC23E698 vv
492E31D4-7117-11D3-AF24-00A0CC23E698 xx

0012F77C-33D4-002A-D4F6-12002E509B75 F5 CLSIDFromProgID(OLESTR("Options.TTOptions.1"),&clsid); ??
492E31D4-7117-11D3-AF24-00A0CC23E698 ??

regsvr32 G:\Tele-Trend\Bin\DataProxy.dll 成功但找不到注册表中的相关信息(x no)

怎么样不注册一个ACTIVEX控件就可以使用它呢? [问题点数：100分，结帖人duankuanjun]
https://bbs.csdn.net/topics/30262349
你可以按创建Com对象的方式使用它，你首先将ActiveX这个Dll加载到程序中，然后调用这个Dll的导出函数DllGetClassObject获得该ActiveX的类厂对象，然后通过该类厂对象，在创建你的需要的接口对象，然后调用你需要调用的接口函数。这样你就可以不用注册了!

#import "G:\Tele-Trend\bin\DataProxy.dll" no_namespace
DataProxy.tlh
struct __declspec(uuid("81f75143-6265-11d3-be13-00a0cc23e61b"))
TTDataProxy;
    // [ default ] interface ITTDataProxy
    // [ default, source ] interface _ITTDataProxyEvents

struct __declspec(uuid("8d5dc90e-641f-11d3-be14-00a0cc23e61b"))
ITTDataProxy : IDispatch
{...}

creating a blank workspace and adding the project.

2020.01.21 

IUnKNown接口――QueryInterface函数
https://blog.csdn.net/lixiangminghate/article/details/74165002

用CWnd::CreateControl创建的控件，如何得到它的接口 [问题点数：20分，结帖人yongdu]
https://bbs.csdn.net/topics/20125176
CWnd::GetControlUnknown()可以取得控件的IUnknown接口指针。

怎样动态创建OCX控件 [问题点数：40分，结帖人morrisyuan]
https://bbs.csdn.net/topics/390329334
IClassFactory *pClf = NULL;
//::CLSIDFromProgID(pwszProgID, &clsid);
::CoGetClassObject(clsid, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void**)&pClf);
_DDataSa* pDataSa = NULL;
pClf->CreateInstance(NULL, __uuidof(_DDataSa), (void**)&pDataSa);
//pDataSa->Create((long)this, cPoint.x, cPoint.y);
pDataSa->Release();
CoUninitialize();
终于成功了，可以访问控件里面的方法了，，不过传参数怎么办，比如我要在我VC工程的某个VIEW里面创建这个控件
哪里用这么麻烦，如果你想用这样的方式创建的话用CoCreateInstance都行。怎么不用CAxWindow方法 来创建了
用CWnd m_Wnd;
 m_Wnd.CreateControl(_T("XX.XX.1") ,NULL,WS_CHILD|WS_VISIBLE,CRect(0,0,200,200), this, 1 );


请问CoCreateInstance创建了COM控件后接下来如何在窗口中显示它？ [问题点数：100分，结帖人sproll]
https://bbs.csdn.net/topics/80218253
wshcdr：
IShockwaveFlash是vc根据控件文件自动生成的接口类，没有SHOW方法。
krh2001(边城浪子) ：
如果控件正确注册的话，使用VC7"添加类"->"ActiveX控件中的MFC类"，然后选择根据注册表可以生成一继承自CWnd的类，那就可以用Create，不过我想纯粹使用COM接口或者ATL而不是MFC或者API创建控件。
谢谢firmbird(firmbird) ，loverx(烟花) ，我想你们的方法更接近我要找的。
要动态地加载控件，需要创建一个“AtlAxWin7”宿主窗口并指定此窗口应承载的控件。执行此操作主要有两种方法： 
使用标准窗口创建 API 和 ATL 宿主 API。此技术在知识库文章“Adding ATL Control Containment Support to Any Window”(Q192560) 中进行了描述。可以在 MSDN Library 中或 http://support.microsoft.com 上找到知识库文章。 
按照如下所述使用 CAxWindow 类： 
确保已经调用 AtlAxWinInit。 
AtlAxWinInit();
AtlAxWinInit 初始化控件宿主代码。 
创建一个 CAxWindow 对象： 
CAxWindow wnd;
CAxWindow 是一个从 CWindow 派生的用于创建和操作“AtlAxWin7”窗口的包装。 
通过调用 Create 创建宿主窗口和控件。 
RECT rect = { 0, 0, 100, 100 };
wnd.Create(m_hWnd, rect, _T("MSCAL.Calendar"), WS_CHILD | 
   WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, WS_EX_CLIENTEDGE);
传递给 Create 函数的窗口标题（第三个参数）是一个标识要创建的控件的字符串。该字符串可以是一个 CLSID（带有大括号）、ProgID、URL 或原始 HTML（以 MSHTML: 为前缀）。如果提供了 URL 或原始 HTML，则 Web 浏览器将与此信息一起加载。 



MFC如何动态加载ActiveX控件? 求大腿解答下 [问题点数：40分，结帖人qq_23847507]
https://bbs.csdn.net/topics/391813627
OleCreate就可以了
CreateControlEx

vc6.0 调用ocx控件
https://blog.csdn.net/Road2010/article/details/24515973

最后面我想说的是：使用ActiveX控件并不难，关键在于你对这个控件提供的函数、成员变量了解多少以及能响应的事件等，能灵活应用。
关于Active控件的开发另见其他文章。
转自：http://blog.csdn.net/sllins/article/details/5525580

今天做了一下ActiveX的使用测试，总结一下：
首先使用MFC创建一个activeX的控件譬如ActiveXTest，编译成ocx并注册，然后另外编写一个测试程序来调用该控件，发现有几种方式：
 
1:使用project-->Add to Project-->Components and Controls, 然后选择要加入的ocx或者dll,系统会自动生成.cpp和.h文件.并自动加入AfxEnableControlContainer(),这样就可以使用了.
 
2:由于activeX一般都有界面，所以可以在dialog里面插入控件的方式来使用，该方式是最简单的一种。创建一个dialog，然后点击右键选择Insert ActiveX Control，在控件库里面找到刚才注册的控件，这时在Controls（按钮栏）里面会出现一个ocx的按钮，可以直接拖进去使用。这时MFC会自动产生一个类，就是包含该控件的类（CActiveXTest），同时在InitInstance()方法里面添加控件初始化函数AfxEnableControlContainer();这样就可以直接在dialog使用控件的方法了。譬如定义ocx按钮的名字为actx，则直接调用
     actx->ShowHello();
 
3:利用上述方法产生包含该控件的类（CActiveXTest），不使用dialog，这时必需手工添加包含该控件的窗体。方法是调用控件类的Create（）方法。
CAcitveXText*  actx = new CAcitveXText;
if(!actx->Create("NN", WS_CHILD|WS_VISIBLE, CRect(0,0,0,0), this, IDC_ACITVEXTEXTCTRL, NULL, FALSE, NULL))
{
  TRACE0("Failed to create the FPWT Control\n");
  return;      // fail to create 
}
actx->ShowHello();
 
4:利用class wizard添加该控件时，相对比较麻烦一些。这时要在InitInstance()里面添加初始化函数AfxOleInit();
然后在使用时要调用CreateDispatch（）来创建控件，然后调用。
 
 wchar_t progid[] = L"ACITVEXTEXT.AcitveXTextCtrl.1";
 CLSID clsid;
 CLSIDFromProgID(progid, &clsid);
 COleException *e = new COleException;
 _DAcitveXText dac;   //产生的类名是_DAcitveXText
 if(dac.CreateDispatch(clsid), e)
   dac.ShowHello();
 else
   throw e;
 但是由于这时是将控件当作normal automation server来使用，必需要重载一下IsInvokeAllowed（），让它直接返回true，否则将不成功，被告之是灾难性失败，错误是编号是：8000ffff。该函数在生成ActiveX的时候重载。（不是在测试程序中）In order
 to use an OLE control only as an automation server, you need to override COleControl::IsInvokeAllowed()and return TRUE.If any of the control's properties and methods should not be accessed when invoked as a normal automation server, then
 that automation function could be bypassed and/or an error code can be returned when COleControl::m_bInitialized is FALSE.
 
BOOL IsInvokeAllowed (DISPID)
{
// You can check to see if COleControl::m_bInitialized is FALSE
// in your automation functions to limit access.
――――――――――――――――
版权声明：本文为CSDN博主「Road2010」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Road2010/article/details/24515973



怎样在运行时动态加载ActiveX控件?急!!!!!(70分)
https://wedelphi.com/t/108805/
找到了答案：

如果我们要动态创建任意的ActiveX控件那么该怎么办呢？可以利用OLE Container控件来达到我们的目的！我们可以动态创建TOLEContainer控件，然后OleContainer有可以动态创建任意的对象，例如：
procedure TForm1.Button1Click(Sender: TObject);
begin
OleContainer1.CreateObject(Edit1.Text,False);
OleContainer1.DoVerb(ovShow);
end;
然后我们运行程序，在Edit里面输入'ShockwaveFlash.ShockwaveFlash.1'点击Button1，然后在Edit里面输入Word.Document，然后点击Button，你会发现我们已经能够动态创建任意的ActiveX控件了。 :)。
注意，若目标机器上面没有安装OCX控件，我们可以在程序的最开始使用WinExec或者ShellExecute()运行regsvr32 来注册OCX控件即可，否则可能无法创建控件。



调用DoVerb激活控件总是失败 [问题点数：100分，结帖人youxi3505]
问题如标题
https://bbs.csdn.net/topics/390245182
HRESULT CreateAxControl(HWND hWnd,const wchar_t * ProgId,IUnknown ** ppControlUnknown,IUnknown ** ppContainerUnknown)
{
HRESULT hr;
CLSID cls;
IOleObject * pObject = NULL;
CControlContainer * pContainer = NULL;
hr = CLSIDFromProgID(ProgId,&cls);
if (FAILED(hr)) goto exit1;

hr = CoCreateInstance(cls,NULL,CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER|CLSCTX_LOCAL_SERVER,IID_IOleObject,(void**)&pObject);
if (FAILED(hr)) goto exit1;

pContainer = new CControlContainer(hWnd);
hr = pObject->SetClientSite(pContainer);
if (FAILED(hr)) goto exit1;
///////////////此处总是失败//////////////////
hr = pObject->DoVerb(OLEIVERB_SHOW,0,pContainer,0,hWnd,0);
if (FAILED(hr)) goto exit1;
/////////////////////////////////////////

    pObject->QueryInterface(IID_IUnknown,(void**)ppControlUnknown);
pContainer->QueryInterface(IID_IUnknown,(void**)ppContainerUnknown);
hr = S_OK;
exit1:
if (pObject) pObject->Release();
if (pContainer) pContainer->Release();
return hr;
}

当我调用CreateAxControl载入flash时会成功
HRESULT hr = CreateAxControl(hWnd,L"ShockwaveFlash.ShockwaveFlash",&pControl,&pContainer);
但是当我载入自己写的一个ActiveX控件则会失败
HRESULT hr = CreateAxControl(hWnd,L"MYGAMEX.MyGameXCtrl.1",&pControl,&pContainer);
代码调试发现在激活控件时总返回失败
hr = pObject->DoVerb(OLEIVERB_SHOW,0,pContainer,0,hWnd,0);

紧急求救这是为啥


Win32编程点滴3 - 简单ActiveX控件的使用
https://www.cnblogs.com/xumaojun/p/8528593.html
HRESULT CreateAxControl(HWND hWnd,const wchar_t * ProgId,IUnknown ** ppControlUnknown,IUnknown ** ppContainerUnknown)
{
    HRESULT hr;
    CLSID cls;
    IOleObject * pObject = NULL;
    CControlContainer * pContainer = NULL;
    
    //通过ProgId得到CLSID
    CLSIDFromProgID(ProgId,&cls);
    
    //创建ActiveX控件的对象，顺便得到IOleObject指针
    CoCreateInstance(cls,NULL,CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER|CLSCTX_LOCAL_SERVER,
        IID_IOleObject,(void**)&pObject);
    
    //CControlContainer是实现了IOleClientSite和IOleInPlaceSite接口的类
    pContainer = new CControlContainer(hWnd);
    
    //调用IOleObject::SetClientSite，传入容器指针
    pObject->SetClientSite(pContainer);
    
    //调用IOleObject::DoVerb，显示控件
    pObject->DoVerb(OLEIVERB_SHOW,0,pContainer,0,hWnd,0);
    
    //一些返回的参数
    pObject->QueryInterface(IID_IUnknown,(void**)ppControlUnknown);
    pContainer->QueryInterface(IID_IUnknown,(void**)ppContainerUnknown);

    if (pObject) pObject->Release();
    if (pContainer) pContainer->Release();
    return S_OK;
}


WIN7打印机无法打印显示本地下层文本正在删除
https://zhinan.sogou.com/guide/d316513699185.htm?ch=zn.xqy.related.pc

KEEPING-PC  192.168.0.100

先仿做，尽量不要创做。仿做量变到质变再创做。

MFC 对话框中动态加载OCX控件
https://blog.csdn.net/yumulinxiang/article/details/78385822

MFC OCX三种调用方法
https://blog.csdn.net/fly0413/article/details/86649294
1、以ATL的方式进行调用，ocx的本质是ATL，所以可以用调用ATL的方法进行调用。不过在插入头文件的时候跟ATL不同，需要以文件的形式加载读取他的头文件（因为ocx是控件只会生成在"ActiveX控件中的MFC类"，不会生成在"ATL类型库里面的MFC类"）。
选择完文件之后，即可添加对应的接口类。
void Ctest5Dlg::OnBnClickedTestBt(){	// TODO: 在此添加控件通知处理程序代码	CoInitialize(NULL); 	m_lpOCX = new COFDReaderActiveX();    //加载控件 指定要创建的IDispatch连接对象的类ID。	BOOL bRet = m_lpOCX->CreateDispatch("suwellreaderax.OFDReaderActiveX.1"); 	if(m_lpOCX != NULL)	{		CString csParam1 = "C:\\Users\\lyf\\Desktop\\PDF\\blank.pdf";		CString csParam2 = "C:\\Users\\lyf\\Desktop\\PDF\\blank.ofd";		CString csParam3 = ""; //C:\\Users\\lyf\\Desktop\\PDF\\bmeta.xml		CString csRet = m_lpOCX->getAllCompsiteNames();		MessageBox(csRet);		//BOOL bRet = m_lpOCX->openFile(csParam1);		//BOOL bRet = m_lpOCX->convertFile(csParam1, csParam2, csParam3);		int a = 3;		a = 4;		return;	} 	if(m_lpOCX != NULL)	{		m_lpOCX->ReleaseDispatch();	} 	if(m_lpOCX != NULL)	{		delete m_lpOCX;		m_lpOCX = NULL;	} 	CoUninitialize();}
2、在对话框中插入ActiveX，之后对插入的资源添加变量，即可生成对应的类。该方法创建时候有边框的资源。
3、在类导向中点击 “ActiveX控件中的MFC类”，选取对应的ocx，后可以进行动态添加ocx，或者也可以在资源对话框中创建资源，然后进行添加变量。如有有存在对应的OCX类则，添加变量时不会添加新文件。


tortoisegit 常见错误disconnected no supported authentication methods available(server sent: publickey)
https://blog.csdn.net/yym6789/article/details/53807640
1.安装好小乌龟git后，用小乌龟的pull 从github上拉取项目，遇到错误：
disconnected no supported authentication methods available(server sent: publickey) 
或者是 git did not exit cleanly (exit code 1)
亦或者是 git did not exit cleanly (exit code 128)
多半是因为git和小乌龟有冲突，解决方法：
右键--小乌龟---settings--network--修改ssh client为git的ssh.exe
https://blog.csdn.net/Hello_World_QWP/article/details/82216345


Disconnected: No supported authentication methods available (server send: publickey)


VC6.0中的dsp和dsw文件有什么区别和联系？
https://blog.csdn.net/pursuitbeauty/article/details/9768433
dsp是:Developer studio Project   工程   开发工作室项目
dws是:Developer studio workspace  工作空间   开发工作室空间

VC6.0 cannot find the definition (implementation) of this function解决方法
https://blog.csdn.net/gordennizaicunzai/article/details/78608495
点击VC6.0左侧工作区ClassView窗口中的类中的函数时，出现cannot find the definition (implementation) of this function弹框提示，解决方法是：关闭工程，然后删除工程目录下面的*.opt *.ncb *.plg文件，再打开工程，最后重新编译即可，之前删除的文件会自动再生成。
.ncb文件是无编译浏览文件，当自动完成功能（自动显示成员变量列表）出问题时，可删除它，build 后自动重建。
.opt是开发环境参数（如工具条位置）文件。
.plg是编译信息(如error和warning信息)文件，html格式。
其它文件：
.dsp为工程文件，文本格式，不可丢失或损坏。
.dsw是工作区文件，丢失或损坏时，可点击.dsp文件打开工程，.dsw文件自动重建。
.clw是ClassWizard信息文件，ini格式，ClassWizard出问题时可删除它再重建。
.map是映像信息文件，编制DLL写.def文件时，若不知道函数导出顺序，可在Prject/Settings/Link页中选中“Generate mapfile”，rebuild，用记事本或其它类似程序打开生成的.map文件，里面可看到函数导出表。
.aps是资源辅助文件，二进制格式。
.pch为预编译文件，可加快编译速度，但改文件非常大。
.pdb文件记录程序相关的数据和调试信息。
.exp是dll信息文件，编译dll时才会生成。
.bsc文件用于浏览项目信息，可在Prject/Settings/Link页中勾掉“Generate Browse Info File”，禁止生成.bsc文件，以加快编译速度，但若使用Source Browser的话就必须有这个文件。

Cannot find the definition (implementation) of this function

2020.01.20

几款Git GUI客户端工具
https://www.cnblogs.com/ups216/p/5603199.html
TortoiseGit

使用Git获取最新版本到本地
http://blog.csdn.net/u011127019/article/details/55044061
一、使用Git UI
1.获取远程最新版本
2.合并远程版本到本地
二、使用Git Brush 、
1.带有查看版本变更详细
2、简单方式
git pull：相当于是从远程获取最新版本并merge到本地
git pull origin master



润园四季 蓉悦 海底捞 八合里 

在 ATL 项目中添加新接口
https://docs.microsoft.com/zh-cn/cpp/atl/reference/adding-a-new-interface-in-an-atl-project?view=vs-2017
当将接口添加到对象或控件时，该接口中创建无存根函数为每个方法。 在您的对象或控件，可以添加仅当前在现有类型库中找到的接口。 此外，在其中添加了接口的类必须实现BEGIN_COM_MAP宏或，如果项目属性化，它必须具有coclass属性。

若要在类视图中使用代码向导将接口添加到现有对象或控件
在中类视图，右键单击一个控件的类名。 例如，完全控制或复合控件或在其标头文件中实现 BEGIN_COM_MAP 宏的任何其他控件类。
在快捷菜单上，单击外，然后单击实现接口。
选择要在中实现的接口实现接口向导。 如果接口不存在任何可用的类型库中，然后你必须将其添加手动到.idl 文件。
若要手动添加新接口
将新接口的定义添加到.idl 文件。
派生对象或从接口的控件。
创建一个新COM_INTERFACE_ENTRY接口或者，如果项目属性化，添加coclass属性。
该接口上实现方法。

若要手动添加新接口
1,将新接口的定义添加到.idl 文件。
2,派生对象或从接口的控件。
3,创建一个新COM_INTERFACE_ENTRY接口或者，如果项目属性化，添加coclass属性。
4,该接口上实现方法。

ATL如何添加一个新接口？如何用简便的方法添加？ [问题点数：20分，结帖人sinall]
https://bbs.csdn.net/topics/60191735
new 一个atl object
这是新增一个类。虽然可以增加接口，但不属于原来的类。类包括多个接口。
vc6好象只能用手工添加，至少我是这样。

idl文件
在原来的那个后添加一个
[
object,
uuid(xxxxxxxxxxx),
helpstring("xxxx Interface"),
pointer_default(unique)
]
interface xxxx : Ixxxxxxxx
{
};


library xxxxxxxxLib
{
coclass xxxxx
{
添加
interface xxxx;
};
}

h文件里
主类从Ixxxx派生,加句public Ixxxx


BEGIN_COM_MAP(Cxxx)
加
COM_INTERFACE_ENTRY(Ixxx)
END_COM_MAP()


SVN和Git比较，哪个好用，适用？
https://jingyan.baidu.com/article/676629976401a154d51b8430.html
SVN 和 Git 哪个更适用于项目管理？
      首先说一下，我是一个研发团队的项目经理，SVN和Git我都用过，SVN更适用于项目管理， Git仅适用于代码管理。
     一个研发队伍的成员正常包括：需求分析、设计、美工、程序员、测试、实施、运维，每个成员在工作中都有产出物，  包括了文档、设计代码、程序代码，这些都需要按项目集中进行管理的。SVN能清楚的按目录进行分类管理， 使项目组的管理处于有序高效的状态。


svn、git的区别，优缺点，使用范围
https://www.jianshu.com/p/e0072bba0b33
转载自：https://blog.csdn.net/mine_song/article/details/70770467

简单总结：

GIT是分布式的，SVN不是
GIT把内容按元数据方式存储，而SVN是按文件
GIT分支和SVN的分支不同
GIT没有一个全局的版本号，而SVN有
GIT的内容完整性要优于SVN
为什么要用GIT而不是SVN？
转载自：https://blog.mimvp.com/article/47.html
使用了近一年的git之后，再使用svn，发现自己svn这种版本管理工具是十分低效的，主要原因有以下几个方面：

从使用者角度分析：

1） svn下载源代码慢。在git中一个几G的版本库，一般一二十分钟就能下载完毕，但是在svn中要一个小时左右；

2）svn随时都得要与服务器交互，无论是查看log，还是查看以往的版本，你必须跟服务器相连，并且速度奇慢务必，而git做这些几乎是瞬间的事；

3）各个分支之间的补丁迁移麻烦，在git上只要两三个命令就可以完事的(其实一个命令，因为需要查找与分支切换)，但是在svn上你必须要下载每个分支的代码，然后比较修改，再上传；

4）git查看历史版本速度快，并且不需要联网，保存在本地.git目录下。svn必须跟服务器相连才能取得版本、日志等信息，并且取版本非常慢；

5）git自带有优化过的grep，使得我们查询相关字符串的效率大大提高

下面从服务器角度说为什么要用git

1）git版本库占用空间小（几乎是svn的分支数之一也就是说如果有四个分支，svn的版本库的体积将接近git的四倍），SVN每个分支都是一份代码的copy，而git每个分支只是各个提交点的hash值的集合，分支几乎不占用什么空间；

2）git是分布式管理系统，我们完全可以不对代码进行备份，但SVN不行，一旦你服务器的硬盘挂掉你整个代码库就完了；

3）git不用时时联网查询，并且对文件进行压缩，使得文件体积大大减小，并且传输速度快，svn是单个文件，git是压缩后的，在使用svn时我已经碰到过好几次服务器无响应了。由于git很多都可以在本地操作的，所以大大降低了客户端对服务器的连接，出现这种情况的概率会大大减小；

4）如果客户端离服务器端非常远，在网速糟糕的情况下，用svn下代码简直是个噩梦

0人点赞
git github cmd


作者：吾爱真理更爱葛巾
链接：https://www.jianshu.com/p/e0072bba0b33
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


Git与SVN区别，各自优缺点
https://blog.csdn.net/zhezhebie/article/details/82563568
Git优点：

1、分布式，每个参与开发的人的电脑上都有一个完整的仓库，不担心硬盘出问题； 
2、在不联网的情况下，照样可以提交到本地仓库，可以查看以往的所有log，等到有网的时候，push到远程即可； 
3、非常强大的分支管理功能。 
4、Git的内容的完整性要优于SVN: GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。

Git缺点：

权限管理不是很方便，需要安装插件gitolite，配置有点麻烦，或者直接使用gitlab管理。

SVN优点

1、较好的权限管理功能，可以精确控制每个目录的权限； 
2、使用相对git要简单一点。

SVN缺点

1、集中式，如果中心服务器出现问题，所有人都不能正常干活，恢复也很麻烦，因为SVN记录的是每次改动的差异，不是完整文件； 
2、分支功能没有git强大； 
3、速度没有git快，如果有五个分支，是把五个分支的文件全部拷下来； 
4、必须联网才能commit。
――――――――――――――――
版权声明：本文为CSDN博主「SHUIPING_YANG」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zhezhebie/article/details/82563568


浅谈为什么Git没有取代SVN
https://blog.csdn.net/u013519551/article/details/52485487
在做开发的过程中，发现Git对于代码的版本控制和管理也是挺好用的，但是为什么还有很多软件公司一直在用svn呢？本人做了一下简单的分析：
1.一般的非纯技术开发公司更倾向于svn；
2.公司一直使用svn，所以公司的项目团队和员工也需要使用；

3.svn的安全控制和权限管理相较于Git更好。git 下，如果一个人clone以后，所有代码和历史都泄漏了。而 svn 有细致的按照目录级的权限控制；
4.源代码管理工具，还是 svn 更强；
5.Git 有一定的学习成本，分布式的工作方式，需要转换思维方式；

6.服务器公司统一控制管理；
7.安全机制, 不会每个人都拷贝一份, 可以对组员限制, 也可以分配不同组；
8.团队合作开发起来传递的数据量不会过大, Git因为都是镜像, 如果有个美工传个500mb的psd, 不相关的人员也要去下载, 很浪费流量和更新时间；
9.每个人的电脑大小不一定能装下特别大的项目, 对于svn来讲, 公司配备一个足够大的服务器硬盘就好了, 而且哪个项目完成, 直接删掉本地目录就好, 完全没有保留的必要；
10.网游公司, 广告公司这些需要大量媒体设计混合到程序的项目中, 很需要svn这样的服务器；
11.svn相对于Git分支确实弱爆了, 但是并不能通过鄙视svn就能把所有人的习惯改过来；
12.Git在这方面来讲更倾向于开源和纯代码开发；
13.毕竟svn使用的最普及和广泛，很多项目团队和个人都用的很顺手，改掉习惯也是需要时间的；
――――――――――――――――
版权声明：本文为CSDN博主「独家记忆0408」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u013519551/article/details/52485487


SVN与Git比较的优缺点差异
https://blog.csdn.net/baidu_38661691/article/details/94456873
优缺点比较
SVN优缺点
优点：
1.管理方便，逻辑明确，符合一般人思维习惯。
2.易于管理，集中式服务器更能保证安全性。
3.代码一致性非常高。
4.适合开发人数不多的项目开发。
缺点：
1.服务器压力太大，数据库容量暴增。
2.如果不能连接到服务器上，基本上不可以工作，看上面第二步，如果服务器不能连接上，就不能提交，还原，对比等等。
3.不适合开源开发（开发人数非常非常多，但是Google app engine就是用svn的）。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。
Git优缺点
优点：
1.适合分布式开发，强调个体。
2.公共服务器压力和数据量都不会太大。
3.速度快、灵活。
4.任意两个开发者之间可以很容易的解决冲突。
5.离线工作。
缺点：
1.学习周期相对而言比较长。
2.不符合常规思维。
3.代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。




Git 版本回退的几种操作方法
https://www.cnblogs.com/revel171226/p/11360844.html
1， 结合使用 git reset --hard <commit id> , git reset --hard HEAD^,  git reflog , git log

　　1) 使用 git log 查看你需要回退版本的commit id, 如果git log显示的结果看着不舒服可以多加一个参数 --pretty=oneline (git log --pretty=oneline)

　　2)  使用git reset  --hard <commit id>

　　3)  在第2)的时候需要找到对应的commit id， 

　　　　Scenario 1 : 你已经回退到某个你指定的版本，但是你这时后悔了想再次回到最新的版本，可以通过 git reset --hard HEAD^ 实现。

　　　　Scenario 2 : 你已经回退到你指定的A版本，但是你实际上应该回退到A版本后面的B版本，你这是又无法通过 git log查看commit id；这时你可以执行git reflog找到B版本的commit id。

　　　　　　　　　　这时你可以通过第2）步的命令来实现。

 PS : 这种方法是不会再当前比较粗暴的方式，因为他不会保留你已经回退的版本之后版本的log（有点拗口），下面我们介绍一种回退到你指定的某个版本，并且保留log的方法

 

 

2，结合使用git checkout  <commit id> -- <paths>, git reflog, git commit -m 'xxxxxxx'

　　1) 使用git log 或者 git reflog 找到你想要回到的哪个版本的commit id

　　2) 使用 git checkout <commit id> -- <paths> 返回到你想要返回的版本， <paths>参数代表的是你想要指定哪个或者哪几个文件 

　　3) 执行完第2)步之后需要执行git commit -m '' 命令提交你当前的修改


git pull 提示 There is no tracking information for the current branch
https://blog.csdn.net/qq_28351609/article/details/86165502
在执行git pull的时候，提示当前branch没有跟踪信息
是因为本地分支和远程分支没有建立联系 (使用git branch -vv 可以查看本地分支和远程分支的关联关系) .
对于这种情况有两种解决办法，就比如说要操作master吧，一种是直接指定远程master：
git pull origin master
另外一种方法就是先指定本地master到远程的master，然后再去pull：
git branch --set-upstream-to=origin/master master
git pull
这样就不会再出现“There is no tracking information for the current branch”这样的提示了。


git pull出现There is no tracking information for the current branch
https://blog.csdn.net/MyheartMylove/article/details/78863973
问题是指本地的分支和远程的分支之间需要建立联系。如：本地master对应远程的master
git branch --set-upstream-to=origin/master master


git强制覆盖本地代码（与git远程仓库保持一致）
https://blog.csdn.net/jal517486222/article/details/82663177
 git fetch --all
 git reset --hard origin/master
 git pull


git强制覆盖：
    git fetch --all
    git reset --hard origin/master
    git pull
git强制覆盖本地命令（单条执行）：
    git fetch --all && git reset --hard origin/master && git pull
https://www.cnblogs.com/pinganzi/p/11593189.html


git放弃修改&放弃增加文件
https://blog.csdn.net/qq_40713392/article/details/86653082

1. 本地修改了一堆文件(并没有使用git add到暂存区)，想放弃修改。 
 单个文件/文件夹： 
$ git checkout  filename1

所有文件/文件夹： 
$ git checkout .1

2. 本地新增了一堆文件(并没有git add到暂存区)，想放弃修改。 
 单个文件/文件夹： 
$ rm filename / rm dir -rf1

所有文件/文件夹： 
$ git clean -xdf1

// 删除新增的文件，如果文件已经已经git add到暂存区，并不会删除！

3. 本地修改/新增了一堆文件，已经git add到暂存区，想放弃修改。 
 单个文件/文件夹：
$ git reset HEAD filename1

所有文件/文件夹：
$ git reset HEAD .1

4. 本地通过git add & git commit 之后，想要撤销此次commit 
$ git reset commit_id1

这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位 
// 撤销之后，你所做的已经commit的修改还在工作区！ 
$ git reset --hard commit_id1

这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位 
// 撤销之后，你所做的已经commit的修改将会清除，仍在工作区/暂存区的代码不会清除！ 




git gui 提交整个目录

git 提交 全部文件
https://blog.csdn.net/lan861698789/article/details/90928715
原文：https://www.cnblogs.com/smuxiaolei/p/7484678.html 
1. git add . 
git add xx命令可以将xx文件添加到暂存区，如果有很多改动可以通过 git add -A .来一次添加所有改变的文件。注意 -A 选项后面还有一个句点。 git add -A表示添加所有内容， git add . 表示添加新文件和编辑过的文件不包括删除的文件; git add -u 表示添加编辑或者删除的文件，不包括新添加的文件
2. git commit -m "提交注释"
3. 
git push origin  分支名称，一般使用：git push origin master
正常来说这三部就够了


https://github.com/hwdcxm/wendy_work.git
git@github.com:hwdcxm/wendy_work.git

https://github.com/-> sign in or https://github.com/login
name: hwdcxm or 23465028@qq.com
passwd: o + birthday

Git GUI可视化操作教程
https://www.cnblogs.com/zhoumiao/p/8018249.html


之后，只要本地做了修改提交，就可以使用git push origin master命令进行文件推送。
https://www.cnblogs.com/imyalost/p/8762522.html

git commit 报 "Changes not staged for commit:"是怎么回事? - ...
https://segmentfault.com/q/1010000004428943?_ea=613759
你 git add 了吗
我今天也遇到这个问题了，但是还不太一样，这个是很有可能会踩得坑 所以想分享一下：
我是clone了一个文件夹下来，然后想把这个文件夹添加上去，使用了git add .，但是一直报Changes not staged for commit的错误，并且那个文件夹后面有(modified content)，解决如下：
因为是clone下来的文件，所以有.git文件，将.git文件删除就ok啦
git commit -am "modified Cheatsheet.html"
-a 表示 add
git commit -am 管用
-a 表示 all
git commit -am "modified Cheatsheet.html"
我用了git add. git commit -m "",出现了这样的Changes not staged for commit:提示，后来发现时我提交时路径错了


1 git add "文件名" //用户添加文件
2 git add . //可以用来添加当前目录下的所有文件
3 git commit -m "提交的内容" //提交版本信息
4 git push //这一步才是真正的上传




环境部署（六）：Git关联github
https://www.cnblogs.com/imyalost/p/8777684.html
我们使用Git进行版本管理，前面的博客也介绍了Linux下安装Git以及Git基础教程，这篇博客，简单介绍下如何使用Git关联github。。。
更多关于Git的内容，可参考下列内容：
Git官方文档
深入理解学习Git工作流
1、拥有github账号
由于本地仓库和远程的github仓库需要关联，首先需要登录github，注册一个账号，然后建立一个仓库。
注册链接：https://github.com/join?source=header-home
成功注册后，登录github，首页如下：
2、创建SSH Key
Git和github之间是通过SSH加密的，因此需要执行下面的操作：
①、在本地主目录查找，是否有.ssh目录，如果有，打开该目录，一般会有这两个文件：id_rsa和id_rsa.pub，如果有的话，直接跳过，如果没有的话，打开命令行，输入如下命令：
ssh-keygen  -t rsa CC “youselfemail@email.com”（你自己的邮箱地址，推荐和注册github的邮箱保持一致）, 我本地已经有了这些文件，如下所示：
PS：如果本地还未生成SSK key，可以通过该命令生成： ssh-keygen -t rsa -C "youremailaddress@mail.com" 
②、登录github，右上角：设置→settings-SSH and GPR keys→New SSH key，然后输入你的标题，输入上面的公钥，然后点击保存。
3、创建仓库
点击右上角，添加→New repository，按照下图所示创建仓库：
然后进入创建的仓库，点击Clone or download，找到你的仓库地址：
然后通过命令:git remote add origin https://github.com/zwg481026/APITest.git，
将本地仓库和github仓库连接就好了。

 git remote add origin https://github.com/hwdcxm/wendy_work.git



https://github.com/hwdcxm/wendy_work.git
git@github.com:hwdcxm/wendy_work.git

Git命令行添加整个文件夹及目录
https://blog.csdn.net/xinqingwuji/article/details/79391453
git add 文件夹/            添加整个文件夹及内容
git add *.文件类型       添加目录中所有此文件类型的文件
git放弃本地修改：
放弃所有修改
git checkout .
放弃某个文件的修改
git checkout -- filepathname

Git基础使用教程
https://www.cnblogs.com/imyalost/p/8762522.html
一、Windows上安装Git
一般我们工作的电脑都是Windows系统，要使用git首先要进行安装。从软件管家或者其他平台找到git的安装包，下载后默认安装即可。
安装成功之后，可以在开始菜单里面找到git：
或者在桌面右键，也可以看到：
其中GUI为用户界面模式，Bash为命令行模式，这里就以Bash为例子介绍git的基本使用方法（其实相比于GUI，个人觉得Bash更容易学习理解）。
二、设置
由于git是分布式管理工具，需要输入用户名和邮箱以作为标识，因此，在命令行输入下列的命令：
PS：注意git config  --global参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱，根据个人情况设置。
三、工作原理
安装好之后，在使用前先来了解一下Git的工作原理，是很有必要的一件事，下面是Git的工作流程和简化原理图：
1、Git工作流程
2、Git简化原理图
四、基本用法
1、创建版本库
版本库就是我们所说的“仓库”，英文名repository，你可以理解为一个目录，这个目录里面的所有文件都可以被Git管理，文件的修改，删除Git都能跟踪，
以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。
下面是在我的电脑→D盘→TEST文件下，创建一个名为lianxi的版本库：
命令解析：
cd：进入某个目录
mkdir：创建一个文件
pwd：显示当前的目录路径
2、添加文件到版本库
要添加文件到版本库，首先需要将这个目录变为git可以管理的仓库，命令如下：
然后，在lianxi目录下创建一个文件，这里我创建的文件为0409.txt，内容为123456
使用下列的命令，将创建的文件添加到暂存区，然后提交到仓库：
命令解析：
git add：将文件提交到暂存区
git commit -m：将暂存区文件提交到仓库（单引号内为注释）
3、检查是否有未提交的文件
通过下面的命令，检查该版本库是否有文件未提交：
命令解析：
git status：检查当前文件状态us
4、检查文件是否被修改
修改0409.txt的文件，然后重新检查状态：
修改文件后，通过命令git status发现，文件已经被修改，但是未提交，如果要检查文件修改了什么内容，可以通过上图中的命令来查看，发现文件的第二行增加了666666的内容。
检查无误后，继续提交修改后的文件，提交命令和上面一样。
命令解析：
git diff：查看文件修改的内容
再次修改文件内容，第三行增加233333的内容，然后保存提交：
现在已经修改了2次文件，可以通过如下命令查看历史修改记录：
如上图所示：每次提交都会有自己的版本号，当然，入过觉得这样看起来比较费事，可以使用命令，获得精简版本的日志记录。
命令解析：
git log：获得历史修改记录
git log --pretty=oneline：使记录只显示主要的内容，一行显示
6、版本回退
首先通过命令行查看当前的文件内容：
然后通过下列的命令，执行版本回退：
可以看到内容已经回退到上一个版本，通过git log查看修改记录，发现最近的一次233333内容的记录已经看不到了，如果想回到最新的版本，可以通过如下命令进行回退：
从上图可以看到，文件版本又回退到了最新的状态。
命令解析：
cat：查看文件内容
git reset --hard HEAD^：回退到上一个版本
git reflog：获取历史版本号
git reset --hard 版本号：回退到该版本号对应的版本
PS：如果要回退到上上个版本，可以使用git reset --hard HEAD^^命令，但是这样稍显麻烦，如果回退到100个版本之前，只需要执行这个命令即可：git reset --hard HEAD~100；
五、将本地文件推送到github仓库
PS：关于Git和github关联，可以参考这篇博客：Git关联github，这里跳过不细说。
检查文件是否还有未提交或者修改的，然后将文件提交到github仓库，命令如下：
命令解析：
git remote add origin https://github.com/zwg481026/APITest.git是将你本地的仓库和github仓库进行关联，在操作时候，需要将github地址替换为自己的，否则无法推送！
然后执行下面的命令：
第一次推送master分支时，加上了 Cu参数，Git会将本地的master分支内容推送的远程新的master分支，还会把2个master分支关联起来，在以后的推送或者拉取时就可以简化操作。
推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了，登录你的github，从仓库中查看：
之后，只要本地做了修改提交，就可以使用git push origin master命令进行文件推送。
六、其他
关于git的命令还有很多，后续会不断更新，敬请期待。。。
https://www.cnblogs.com/imyalost/p/8762522.html

2020.01.17

Git的安装和使用
https://blog.csdn.net/wangligong/article/details/53591593

C:\Users\Wendy\.gitconfig
[user]
	name = wendy
	email = 23465028@qq.com


Git 中文详细安装教程
https://blog.csdn.net/sishen47k/article/details/80211002

Git的安装与使用（超详细版教程）
https://blog.csdn.net/u010074690/article/details/80209635

Git客户端下载及安装
Git客户端安装过程
1.双击安装程序“Git-2.10.2-64-bit.exe”，显示截图如下：
https://blog.csdn.net/zzfenglin/article/details/53147604


源代码管理工具 一一 Git-介绍与SVN的对比
https://blog.csdn.net/m0_37989980/article/details/79067733

常用源代码管理软件 及 比较
常用源代码管理软件

全称

出处

CVS

Concurrent Versions System

Open Source

SVN

Apache Subversion

Open Source

VSS

Visual Source Safe

Microsoft

TFS

Team Foundation Server

Microsoft

P4

Perforce

Perforce

Git

Git, 中文蠢货，作者自嘲之意

Open Source

CC

ClearCase

IBM Rational

https://www.cnblogs.com/dancewithautomation/archive/2012/01/12/2320793.html

几种代码管理工具比较
笔者有幸接触过以下几种常用的配置管理工具：VSS、SVN、Clearcase，在此做一个小小的总结
https://blog.csdn.net/isscollege/article/details/78404272

https://git-scm.com/downloads/

git for windows(32+64)
ditto_zhou：可以用，再次下载
https://download.csdn.net/download/ghy110523/10959355

Git软件　Git-2.18.0-64-bit软件.exe
官网下载太慢，感谢楼主
https://download.csdn.net/download/qq_27262727/10633734

为什么说 Git 将取代 SVN 做软件版本控制？
如果你不能理解“分布式”，那么我们看一个简单例子：假如你把开发任务从公司带回家，晚饭后突然有了灵感，要对代码进行修改，不巧家里的电脑不能连接到公司的文件库，你怎么下载要修改的文件？即使你将文件用优盘带回去了，那么修改之后，又怎样提交？SVN 对这种情况没有解决方案，而 Git 可以！因为 Git 在每个用户硬盘上都创建了完整的文件库，不需要、也不存在一个“中心服务器”，你只要能连接上任何一个团队成员的电脑，就能将代码提交到文件库去（有点像 P2P）。  顺便说一下，Git 是由“Linux之父”  Linus Torvalds 创建的。因为他发现找不到满意的方案来管理 Linux Kernel 联合开发的版本控制，就自己写了 Git。

Git 有什么优势？  从网上的用户评价来看，Git 最大的优势就是“快”！对于大型的联合开发项目，用 SVN 进行版本控制管理时速度很慢，但是用 Git 就快很多。  还有一个说法是：SVN 有的功能 Git 都有，而 Git 的某些特色 SVN 根本做不到。  这就足够打动我了。我不是开发人员，无需关心更细节的比较了。如果你有兴趣深入了解，请 Google 之。
――――――――――――――――
版权声明：本文为CSDN博主「QQ_370566617」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/begtostudy/article/details/6024788

假如你们已经在用 SVN 了，那么建议你参考一下 SVN+Git 鱼与熊掌兼得 这篇文章，可以同时使用 SVN 和 Git，这样也方便团队成员完成平稳过渡。  下载 TortoiseGit for Windows 32-bit Git版本控制系统客户端软件   原帖：http://www.joomlagate.com/article/joomla-review/why-subversion-will-be-replaced-by-git-for-version-control/

https://blog.csdn.net/begtostudy/article/details/6024788


	COM_INTERFACE_ENTRY(ITTObject) (v ok)
END_COM_MAP()


关闭return全部分ITTObject接口包括函数PutByID.
关闭构造函数
CTTOptions::CTTOptions() 
{
	return;  // wendy test
..}
关闭OnCreate函数
LRESULT CTTOptions::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	return 0;  // wendy test
...}
关闭OnSize函数
LRESULT CTTOptions::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	// TODO : Add Code for message handler. Call DefWindowProc if necessary.

	return 0; // wendy test
...}
w2t.exe不出错显示白色界面.


[14:57:35.983]:CTTOptions::CTTOptions() b 
[14:57:36.043]:CTTOptions::MakeFutCode()  
[14:57:36.043]:CTTOptions::ReadExpiryDateListFile()  
[14:57:36.043]:CTTOptions::GetExpiryTime()  
[14:57:36.043]:CTTOptions::GetExpiryDays()  
[14:57:36.113]:CTTOptions::CTTOptions() e 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID(nID=1000,VARIANT* pVar) b 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID() e S_OK 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID(nID=3301,VARIANT* pVar) b 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID() e S_OK 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID(nID=3188,VARIANT* pVar) b 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID() e S_OK 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID(nID=3409,VARIANT* pVar) b 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID() e S_OK 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID(nID=2024,VARIANT* pVar) b 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID() e S_OK 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID(nID=4004,VARIANT* pVar) b 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID() e S_OK 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID(nID=2060,VARIANT* pVar) b 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID() e S_OK 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID(nID=1017,VARIANT* pVar) b 
[14:57:52.583]:STDMETHODIMP CTTOptions::PutByID() e S_OK 
[14:57:52.583]:STDMETHODIMP CTTOptions::PutByID(nID=1110,VARIANT* pVar) b 
[14:57:52.583]:STDMETHODIMP CTTOptions::PutByID() e S_OK 
[14:57:52.583]:STDMETHODIMP CTTOptions::PutByID(nID=3306,VARIANT* pVar) b 
[14:57:52.583]:STDMETHODIMP CTTOptions::PutByID() e S_OK 
[14:57:52.583]:STDMETHODIMP CTTOptions::PutByID(nID=3307,VARIANT* pVar) b 
[14:57:52.583]:STDMETHODIMP CTTOptions::PutByID() e S_OK 




tooltip.cpp line 234
void CToolTipCtrl::UpdateTipText(LPCTSTR lpszText, CWnd* pWnd, UINT nIDTool)
{
	ASSERT(::IsWindow(m_hWnd));
...}


	// 协议API.
	BOOL  AdviseDataProxy(BOOL bAdvise);
	STDMETHOD( OnNewFrame)(short wDataType,IStream* pIStream,unsigned long dwID) ;
	void ReadDSFrame(IStream* pIStream);	// 解析'DS'(Tele) 协议	
	void ReadDOFrame(IStream* pIStream,unsigned long dwID);	// 解析Options 协议	
	void ReadDPFrame(IStream* pIStream);    //解析'DP'不同itemcode+date市价 协议  2017.9.28 ben
	void SendRequestFrame() ;				// 请求所有数据.
	void SendEndFrame() ;					// 请求断开与DO连接.  ??
	void SendMonthRequestFrame() ;			// query month list.

	HRESULT ReadDFFrame(IStream *pIStream);
	void SendDFChlFrame( BOOL bConnect ); 
	void SendDFRequestFrame();



	BOOL SubmitRQ(IStream* pIStream, short wDataType = 'DO'); // helper function, call ITTDataProxy::TranslateQueryFrame()


BOOL CTTOptions::SubmitRQ(IStream* pIStream, short wDataType)
{
	if(m_pDataProxy == NULL)
	{
		AtlTrace(_T("OptionsTab: Can't get DataProxy!\n"));
		return FALSE;
	}
	CComQIPtr<ITTDataProxy> pObj(m_pDataProxy);
	if(pObj == NULL)
	{
		AtlTrace(_T("OptionsTab: Can't get interface ITTDataProxy!\n"));
		return FALSE;
	}	
	
	HRESULT hr = pObj->TranslateQueryFrame(wDataType, pIStream, m_dwID);
	return (hr == S_OK);
}


BOOL CTTOptions::SendUpdateRQ(BOOL bConnect)
{
	if( bConnect )
		m_fBF = 0.0;

	FrameLen    framelen;
	FrameHead	framehead;
	FrameID		frameid;
	unsigned short	wElemType;

	framelen = sizeof(FrameHead) + sizeof(FrameID) + sizeof(short); // +sizeof(char);
	memset(&framehead, 0, sizeof(framehead));
	framehead.wFrameType = 'DO';
	frameid.cbGroupCode = m_cbGroupCode;
	memcpy(frameid.szItemCode,m_szItemCode,G_GENCODELEN);  //这是发给OptionsDO的,仍然使用Itemcode
	frameid.lTransdate = m_lTransdate;
	wElemType = bConnect ? 'UC' : 'UD';

	CComPtr<IStream> pIStream;
	CreateStreamOnHGlobal(NULL,TRUE,&pIStream);
	ULARGE_INTEGER size;
	size.QuadPart = framelen + sizeof(framelen);
	pIStream->SetSize(size);
	SeekFromBegin(pIStream, 0);

	HRESULT hr = pIStream->Write(&framelen, sizeof(framelen), NULL);
	hr = pIStream->Write(&framehead, sizeof(framehead), NULL);
	hr = pIStream->Write(&frameid, sizeof(frameid), NULL);
	hr = pIStream->Write(&wElemType, sizeof(wElemType), NULL);
	
	return SubmitRQ(pIStream);
}

void CTTOptions::SendRequestFrame()
{
	SendUpdateRQ(TRUE);
	SendHistoryRQ();
	//SendHistoryRI();
//	SendHistoryRQ();
//	SendUpdateRQ(TRUE);
	SendTeleHisRQ();
	SendTeleUpdateRQ(TRUE);
	
}

STDMETHODIMP CTTOptions::PutByID(int nID, VARIANT* pVar)
{...
	case TTPID_SystemObject:
		{...
VARIANT *pVar1;
			VARIANT var;
			var.vt = VT_UNKNOWN;
			VARIANT *pVar1;
			pVar1= &var;
			pObj->GetByID(TTPID_DataProxy,&pVar1);
			m_pDataProxy = pVar1->punkVal;
			if(m_pDataProxy == NULL)
			{
				AtlTrace(_T("OptionsTab: Can't get DataProxy from SystemObject\n"));
				CLogout("STDMETHODIMP CTTOptions::PutByID() e4 S_FALSE \r\n");
				return S_FALSE;
			}
			var.vt = VT_I4;
			pVar1= &var;
			pObj->GetByID( TTPID_ObjGlobalID,&pVar1);
			m_dwID = pVar1->lVal;
			var.vt = VT_UNKNOWN;
			pVar = &var;
			pObj->GetByID(TTPID_GroupsMng,&pVar1);
			if(pVar1->punkVal == NULL)
				{
				CLogout("STDMETHODIMP CTTOptions::PutByID() e5 S_FALSE \r\n");
				return S_FALSE;
				}
			m_pGrpMng = pVar1->punkVal;
			pObj->GetByID(TTPID_MainFrame,&pVar1);
			if(pVar1->punkVal == NULL)
				{
				CLogout("STDMETHODIMP CTTOptions::PutByID() e6 S_FALSE \r\n");
				return S_FALSE;
				}
			m_pMainFrm = pVar1->punkVal;
...}

	// ITTObject相关数据.
	IUnknown*		m_pDataProxy;
	IUnknown*		m_pSystemObj;	
	IUnknown*		m_pGrpMng;
	IUnknown*		m_pMainFrm;

void CTTOptions::OnSelectItemCode()
{...

			//andy add 2003.10.16  先断开原先的请求,包括DO和DS
			SendEndFrame();
			//andy add 2003.10.16
...}

void CwndBgn::OnSelectItemCode() 
{
	CLogout("CwndBgn::OnSelectItemCode()  \r\n");
	if( m_pOwner!=NULL )
	{
		m_pOwner->m_bSelectWin = 0;
		m_pOwner->OnSelectItemCode() ;
	}

}

Windows7修改文件默认图标
Windows7下没有提供修改文件默认图标的工具，只能通过注册表修改。

1.  进入注册表，在 HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\下找到相应后缀的文件

2. 在第二个地址中的OpenWithProgids目录下，存在一个二进制值，通常是 后缀名_auto_file(如 rp_auto_file)
3. 在注册表中搜索 后缀名_auto_file ，在 HKEY_CLASSES_ROOT 下找到该项，它的第一个子项通常是 shell 

4. 在 HKEY_CLASSES_ROOT\后缀名_auto_file 下新建一个名为 DefaultIcon 的项。在该目录下会自动生成一个字符串。双击该字符串，在数值数据里面输入你想要的图标地址（如 D:\img\xxx.ico）
5. 注销系统后，完成修改
https://blog.csdn.net/jianzhanger/article/details/45369039

VisualStudio.dsw.10.0
C:\Program Files\Microsoft Visual Studio 10.0\VC\vcpackages\VCProject.dll,8 (x no)

%SystemRoot%\system32\SHELL32.dll

win7中，如何修改文件的图标。
经过观察发现，现在显示的图标是【exe程序 Moc.exe】那一组图标中的第一个。
我是这么更改图标的。
1.创建这个exe程序的快捷方式。
2.更改这个快捷方式的图标。
3.然后选择打开方式，选择这个修改图标的快捷方式打开。
https://bbs.csdn.net/topics/360219137?list=lz


计算机\Registered ActiveX Controls
计算机\Developer Studio Components

关于Registered ActiveX Controls问题？？？？？？
https://www.cctry.com/thread-50862-1-1.html

小弟我的VC++6.0程序文件夹里面的gallery的文件夹下面什么都没有
我的VC++6.0程序文件夹里面的gallery的文件夹下面什么都没有
由于需要添加一个Windows media player的控件。
可是打开之后发现这个文件是空的~~~
我们宿舍用的都是同一个VC++~~~他们都有，就我没有~
我是WIN7的~~宿舍也有好几台WIN7的~~
我之前恢复过系统。。。
今天装了几遍都没有。。。。跪求办法~~
http://m.myexception.cn/vc-mfc/1354513.html

解决Visual C++无法使用ActiveX 控件，Gallery目录下没有Registered ActiveX Controls问题
https://blog.csdn.net/h532600610/article/details/51823313

vc++ 6.0链接数据库 使用控件 registered activex controls 灾难性故障
正常安装后，C:\Microsoft Visual Studio\Common\MSDev98\Gallery\Registered ActiveX Controls文件夹下为空。之前程序里使用过一个ActiveX 控件无法运行，且出现：ActiveX控件“{6262D3A0-531B-11CF-...}”没有在此计算机中注册.注册控件然后再试.!
这个时候我们再检查控件列表，发现多了一个控件，那个控件就是我们要添加的控件。
https://zhidao.baidu.com/question/682145165034791612.html



D:\Program Files\Microsoft Visual Studio\Common\MSDev98\Gallery

MFC如何添加自定义控件
project->add to project->components and controls
在Registered ActiveX Controls下找到你注册的自定义控件就可以了
https://blog.csdn.net/weixin_30629977/article/details/97149377

关闭return大部分ITTObject接口函数留PutByID.

w2t.exe可以显示界面, 但不能显示有些按钮和刷新数据.

ActiveX Container中加载却出错 Microsoft ActiveX Control Test Container 已停止工作
void CHeaderCtrlOptions::OnPaint()
{...
//dc.DrawText(this->m_HChar[i],&tRect,nFormat);  // wendy test
...}
可显示
void CTTOptions::OnSelectItemCode()
{

	CLogout("CTTOptions::OnSelectItemCode()  \r\n");
	
	AFX_MANAGE_STATE(AfxGetStaticModuleState( )) 

	if(m_pGrpMng == NULL)
		return ;
	//CComQIPtr< ITTGroupsMng,&IID_ITTGroupsMng> pGrp(m_pGrpMng);  // wendy test
	//if(pGrp == NULL)
	//	return ;
...

//			pGrp-> FindItem('A',(BYTE*)szItemCode,&lID); // wendy test
			TCHAR szName[30];
//			if( m_iLangType==0 )
//				pGrp->GetItemPara(lID,ItemID_Lang1Descrip,(BYTE*)szName,30);
//			else
//			if( m_iLangType==1 )
//				pGrp->GetItemPara(lID,ItemID_Lang3Descrip,(BYTE*)szName,30);
//			else
//			if( m_iLangType==2 )
//				pGrp->GetItemPara(lID,ItemID_Lang2Descrip,(BYTE*)szName,30);
...} 
按钮可弹出对话框

BOOL CTTOptions::SendTeleUpdateRQ(BOOL bConnect)
{...
	hr = pIStream->Write(&wElemType, sizeof(wElemType), NULL);
	BOOL bSucc = SubmitRQ(pIStream, 'DS');   /////////cash
...}
按确定后出错
BOOL CTTOptions::SubmitRQ(IStream* pIStream, short wDataType)
{
	if(m_pDataProxy == NULL)
	{
		AtlTrace(_T("OptionsTab: Can't get DataProxy!\n"));
		return FALSE;
	}
	CComQIPtr<ITTDataProxy> pObj(m_pDataProxy);
..}
template <class T, const IID* piid = &__uuidof(T)>
class CComQIPtr
{
public:
	typedef T _PtrClass;
	CComQIPtr()
	{
		p=NULL;
	}
	CComQIPtr(T* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComQIPtr(const CComQIPtr<T,piid>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	CComQIPtr(IUnknown* lp)
	{
		p=NULL;
		if (lp != NULL)
			lp->QueryInterface(*piid, (void **)&p);
	}
	~CCom
...}

SystemObject Module 已停止工作

使用MIDL编译IDL文件
一、先在CMD下运行vcvarsall.bat
a.在CMD中cd到VS的vc的安装路径：cd C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC
b.接着输入vcvarsall.bat X86
二、编译你的idl
a.在CMD中cd到你的idl所在的目录：cd E:\testForwork\ComWorkPlace\OutofProc\DictPrxy
b.接着输入：MIDL Dictionary.idl
结果就会出现在你的idl目录下。
――――――――――――――――
版权声明：本文为CSDN博主「Red fog」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/BooleanWater/article/details/103317474

MIDL示例
MIDL编译器将生成XX.H XX_.C XX_P.C DLLDATA.C几个文件，其作用分别为：
XX.H       一个同C和C++兼容的，包含IDL中所描述的所有接口声明的头文件；
XX_.C     一个定义有IDL文件中所用的所有GUID的C文件
XX_P.C     一个实现IDL文件中接口的代理及残根的C文件
DLLDATA.C 一个包含代理和残根的DLL的C文件
https://blog.csdn.net/sunshine1314/article/details/1562376

MIDL_INTERFACE

本站提供特别信息:仅供参考!^_^
Visual Assist X v10.1.1301 Final 正式版
Name：SSG Team
Code：xdaRF G4bKE Ic87U J7pF8 /XGEV Iz/oP YcNmg JVjaU GqzkI M1QtN ZRg9V Q 

2020.01.16

memmove
memmove 编辑 讨论
memmove用于拷贝字节，如果目标区域和源区域有重叠的话，memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，但复制后源内容会被更改。但是当目标区域与源区域没有重叠则和memcpy函数功能相同。
函数简介编辑
原型：void *memmove( void* dest, const void* src, size_t count );
头文件：<string.h>
功能：由src所指内存区域复制count个字节到dest所指内存区域。
相关函数：memset、memcpy
程序示例编辑
// memmove.c
#include <stdio.h>
#include <string.h>
int main(void)
{
char s[]="Golden Global View";
memmove(s,s+7,strlen(s)+1-7);
printf("%s",s);
getchar();
return 0;
}
程序输出结果：Global View
MSDN上也有相关示例。
*注意：这里的拷贝长度strlen(s)+1-7表示把字符串结尾的'\0'也拷贝进来。
https://baike.baidu.com/item/memmove/5494877?fr=aladdin

error C2065: 'getch' : undeclared identifier
包含头文件加一个conio.h
#include <conio.h>
或者把getch
这个函数改成 getchar函数。
https://zhidao.baidu.com/question/537125299.html?fr=iks&word=error+C2065%3A+%27getch%27+%3A+undeclared+identifier&ie=gbk


: 'printf' : undeclared identifier
未声明定义，缺少printf函数的头文件
#include<stdio.h>
https://zhidao.baidu.com/question/175997549107882044.html

Open HKStock2.occ failed

2020.01.15

template <class T>
class ATL_NO_VTABLE IOleObjectImpl : public IOleObject
{
public:
...
		switch (iVerb)
		{
		case OLEIVERB_PRIMARY:
			hr = pT->DoVerbPrimary(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_SHOW:
			hr = pT->DoVerbShow(lprcPosRect, hwndParent);
			break;
...}

---->

	HRESULT DoVerbShow(LPCRECT prcPosRect, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbShow();
		if (SUCCEEDED(hr))
		{
			hr = pT->InPlaceActivate(OLEIVERB_SHOW, prcPosRect);
			if (SUCCEEDED(hr))
				hr = pT->OnPostVerbShow();
		}
		return hr;
	}
--->

inline HRESULT CComControlBase::InPlaceActivate(LONG iVerb, const RECT* /*prcPosRect*/)
{...
		if (!m_bWndLess)
		{
			if (m_hWndCD)
			{
				ShowWindow(m_hWndCD, SW_SHOW);
				if (!::IsChild(m_hWndCD, ::GetFocus()))
					::SetFocus(m_hWndCD);
			}
			else
			{
				HWND h = CreateControlWindow(hwndParent, rcPos);
				ATLASSERT(h != NULL);	// will assert if creation failed
				ATLASSERT(h == m_hWndCD);
				h;	// avoid unused warning
			}
		}
...}

--------->
template <class T, class WinBase =  CWindowImpl< T > >
class ATL_NO_VTABLE CComControl :  public CComControlBase, public WinBase
{
public:...
	}
	virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos)
	{
		T* pT = static_cast<T*>(this);
		return pT->Create(hWndParent, rcPos);
	}
..}

----->

class ATL_NO_VTABLE CWindowImpl : public CWindowImplBaseT< TBase, TWinTraits >
{
public:
	DECLARE_WND_CLASS(NULL)

	HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			UINT nID = 0, LPVOID lpCreateParam = NULL)
	{
		if (T::GetWndClassInfo().m_lpszOrigName == NULL)
			T::GetWndClassInfo().m_lpszOrigName = GetWndClassName();
		ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);

		dwStyle = T::GetWndStyle(dwStyle);
		dwExStyle = T::GetWndExStyle(dwExStyle);

		return CWindowImplBaseT< TBase, TWinTraits >::Create(hWndParent, rcPos, szWindowName,
			dwStyle, dwExStyle, nID, atom, lpCreateParam);
	}
};
--->

template <class TBase, class TWinTraits>
HWND CWindowImplBaseT< TBase, TWinTraits >::Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName,
		DWORD dwStyle, DWORD dwExStyle, UINT nID, ATOM atom, LPVOID lpCreateParam)
{
	ATLASSERT(m_hWnd == NULL);

	if(atom == 0)
		return NULL;

	_Module.AddCreateWndData(&m_thunk.cd, this);

	if(nID == 0 && (dwStyle & WS_CHILD))
		nID = (UINT)this;

	HWND hWnd = ::CreateWindowEx(dwExStyle, (LPCTSTR)MAKELONG(atom, 0), szWindowName,
		dwStyle, rcPos.left, rcPos.top, rcPos.right - rcPos.left,
		rcPos.bottom - rcPos.top, hWndParent, (HMENU)nID,
		_Module.GetModuleInstance(), lpCreateParam);

	ATLASSERT(m_hWnd == hWnd);

	return hWnd;
}

---->

template <class TBase, class TWinTraits>
LRESULT CALLBACK CWindowImplBaseT< TBase, TWinTraits >::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CWindowImplBaseT< TBase, TWinTraits >* pThis = (CWindowImplBaseT< TBase, TWinTraits >*)hWnd;
	// set a ptr to this message and save the old value
	MSG msg = { pThis->m_hWnd, uMsg, wParam, lParam, 0, { 0, 0 } };
	const MSG* pOldMsg = pThis->m_pCurrentMsg;
	pThis->m_pCurrentMsg = &msg;
	// pass to the message map to process
	LRESULT lRes;
	BOOL bRet = pThis->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, 0);
...}


--->

BEGIN_MSG_MAP(Cfullctr)
	MESSAGE_HANDLER(WM_CREATE, OnCreate)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	CHAIN_MSG_MAP(CComControl<Cfullctr>)
ALT_MSG_MAP(1)
--->

	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		RECT rc;
		GetWindowRect(&rc);
		rc.right -= rc.left;
		rc.bottom -= rc.top;
		rc.top = rc.left = 0;
		m_ctlEdit.Create(m_hWnd, rc);
		m_ctlEdit.SetWindowText("测试foptions.fullctr");
		return 0;
	}
....


File could not be opened 3

ATL com组件的OnCreate不会被调用 [问题点数：40分，结帖人my_aa]
发现this->m_hWnd为NULL(我那构造函数中有m_bWindowOnly = TRUE)
https://bbs.csdn.net/topics/390152995


在ATL无窗口ACTIVEX控件中响应timer消息
https://blog.csdn.net/gxulg/article/details/311057

使用VC2008创建基于ATL的ActiveX控件,不自动调用OnCreate函数
为什么ATL控件的OnCreate进不去
atl控件的oncreate进不去?

用ATL编写窗口程序 [问题点数：0分]
https://bbs.csdn.net/topics/230864

ATL如此显示窗口及对话框
https://blog.csdn.net/AsongWam/article/details/2505155?utm_source=blogxgwz1

ATL和MFC创建ActiveX控件的区别
https://www.cnblogs.com/huhewei/p/6202804.html

如何使用ATL OBJECT WIZARD 
https://bbs.csdn.net/topics/314998

BEGIN_MSG_MAP(CLitctr)
	MESSAGE_HANDLER(WM_CREATE, OnCreate) (v ok)
ATL Object Wizard 属性->Miscellaneous->Add control base on: Edit or Button or xxxx

使用ATL来写个简单的窗口程序
https://blog.csdn.net/superleolx/article/details/4896045

使用ATL 窗口类
https://blog.csdn.net/lan354898254/article/details/7556686

VC++ ATL 学习总结
https://blog.csdn.net/bcbobo21cn/article/details/69055605

ATL窗口(1) (转)
，当你创建一个基于Windows控制的ATL控制，ATL Object Wizard产生代码如下：
BEGIN_MSG_MAP(CMyButton)
     MESSAGE_HANDLER(WM_CREATE, OnCreate)
     MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
     CHAIN_MSG_MAP(CComControl) file://看这里
    ALT_MSG_MAP(1)
 END_MSG_MAP()
https://blog.csdn.net/dragoo1/article/details/48789639


ATL窗口(2) (转)
https://blog.csdn.net/JoySwing/article/details/11592


ATL窗口添加功能的5种方法[转]
https://blog.csdn.net/weixin_34269583/article/details/94740793

ATL问题集(转载）
#9 如何做一个简单的控件容器?
http://blog.sina.com.cn/s/blog_5c68ccb801017rwz.html
https://blog.csdn.net/fengrx/article/details/4171629
https://blog.csdn.net/fengrx/article/details/4175278
https://www.cnblogs.com/zhehan54/p/4705989.html

ATL ActiveX控件的OnCreate函数不能执行
你的控件是复合控件吗？只有复合控件才会有窗口，有窗口才会有WM_CREATE
检查一下m_hWnd是否为空如果组件有窗口，则需要在构造函数里，
m_bWindowOnly = TRUE;
这样，组件的m_hWnd句柄就不是NULL了
https://www.debugease.com/vc/2225152.html


为什么ATL控件的OnCreate进不去？
当然添加了啊，我用向导生成的，我的是ATL复合控件，构造函数里已经把m_bWindowOnly置为TRUE了啊~
https://bbs.csdn.net/topics/300057406



m_bWindowOnly = TRUE; 为何在VC对话框编辑器中插入我的控件的时候还是没有窗口句柄 OnCreate 也
ActiveX控件测试容器 踪发现在VC的对话框中插入控件的时候并没有调用 CComControlBase::InPlaceActivate 
https://bbs.csdn.net/topics/90064077
我在创建的时候在ATL向导中选择了 WindowOnly 属性, 控件类的构造函数中确实也有 m_bWindowOnly = TRUE; 这一句. 在ActiveX控件测试容器中和IE中也都正常, 能够得到控件的窗口句柄, 但是在VC的对话框编辑器中取得的窗口句柄却为NULL, ATLTRACE 发现控件的 OnCreate 消息响应函数根本就没有被调用! 
对话框上的控件显示为一个白框.
之后在控件的方法中设置断点, 查看 m_bWindowOnly 确实为 TRUE , 而 m_hWnd 和 m_hWndCD 还有 *m_phWndCD 均为 NULL .
为何控件窗口没有被创建呢, ATL中具体创建控件窗口代码又是在哪里呢?

总算有人关注了:) 我还以为我的问题很火星, 没人理我呢:)
昨天又试了一下, 使用 ATL 向导选择 Full Control 生成的ActiveX控件(除了m_bWindowOnly = TRUE之外没做其他修改), 在VC的对话框编辑器中插入也不会创建控件窗口. 因为代码全部由向导生成, 因此排除是我添加的代码的问题. 那么到底是什么问题呢? 还望高手解答!

解决办法是在控件类的 OnDraw 中判断是 DesignTime 还是 Runtime:
如果是 Runtime 进行正常的界面绘制;
如果是 DesignTime 就直接使用 ATL_DRAWINFO& di 参数中的 DC 绘制出界面.
可用如下代码判断是 Runtime 还是 DesignTime
BOOL CYTNetCameraCtrl::InDesignTime()
{
ATLTRACE("InDesignTime\n");

BOOL bUserMode = TRUE;
HRESULT hr = GetAmbientUserMode(bUserMode);
if ( FAILED(hr) || bUserMode ) // run-time
{
return FALSE;
}
return TRUE; // design-time
}


atl OnCreate m_bWindowOnly 百度


OBJECT_ENTRY 映射
其中OBJECT_ENTRY映射为--->
#define OBJECT_ENTRY(clsid, class) {&clsid, class::UpdateRegistry, class::_ClassFactoryCreatorClass::CreateInstance,  －－－－组件类厂创建class::_CreatorClass::CreateInstance,   －－－－组件实例创建NULL, 0, class::GetObjectDescription, class::GetCategoryMap, class::ObjectMain },
其中的_ClassFactoryCreatorClass和_CreatorClass定义如下(都为创建类－－CComCreator)：#define DECLARE_CLASSFACTORY() DECLARE_CLASSFACTORY_EX(ATL::CComClassFactory)#define DECLARE_CLASSFACTORY_EX(cf) typedef ATL::CComCreator< ATL::CComObjectCached< cf > > _ClassFactoryCreatorClass;
#define DECLARE_AGGREGATABLE(x) public:/ typedef ATL::CComCreator2< ATL::CComCreator< ATL::CComObject< x > >, ATL::CComCreator< ATL::CComAggObject< x > > > _CreatorClass;
――――――――――――――――
版权声明：本文为CSDN博主「Tianyu-liu」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/wishfly/article/details/2069595
https://blog.csdn.net/wishfly/article/details/2069595

初学ATL，BEGIN_OBJECT_MAP 搞不定 ？？ [问题点数：100分，结帖人okmnjizc]
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
CComModule _Module;
#include <atlcom.h>
知道了，要把
CComModule   _Module;
写在
#include <atlcom.h>
的上面........... =.=
https://bbs.csdn.net/topics/370267251

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TTOptions, CTTOptions)
END_OBJECT_MAP()

MFC对话框的创建和销毁顺序
了解了理论过后，下面我们就可以用代码实现一下非模态对话框的创建和销毁过程:
建立：
//主框架中，即调用/创建非模态对话框的对话框/窗体：
CTestDlg *pDlg=new CTestDlg;
 pDlg->Create(IDD_TESTDLG,this);
 pDlg->ShowWindow(SW_SHOW);
 //非模态对话框中：
void CTestDlg::OnCancel()
 {
      DestroyWindow();
 }
 void CTestDlg::PostNcDestroy()
 {
      CDialog::PostNcDestroy();
      delete this;
 }
如果要在点击按钮的情况下，销毁非模态对话框，只需要把按钮的事件映射到OnCancel函数即可。
https://blog.csdn.net/leaf6094189/article/details/7609185

OnDestroy 和 DestroyWindow 的区别

虚拟函数DestroyWindow()和视窗消息OnDestroy()的区别在何处？ [问题点数：35分，结帖人xujialin_xjl
这两个函数可以理解成一个是主动的, 另一个是被动的.
用户主动调用DestroyWindows来关闭窗口, 而当窗口被关闭时OnDestroy函数 被 调用!
所以你上面说的现象是正常的... 
你调用DestroyWindow(),那么系统就会发一个WM_DESTROY的消息,这个消息会调用OnDestroy()函数.
DestroyWindow会自动delete ，你再删有可能出错
DestroyWindow()  ------> WM_DESTROY+ WM_NCDESTROY ------>OnDestroy()
                 发消息                          响应消息映射
https://bbs.csdn.net/topics/274198


mfc 关闭对话框的各种消息与方法
以下是对话框关闭时发送的不同消息：
   1）点击OK按钮：OnOk-WM_DESTROY
   2) 点击Cancel按钮：OnCancel－WM_DESTROY
   3) 点击×按钮：WM_CLOSE－ONCANCEL－WM_DESTROY
   4) 键盘ESC按键：OnCancel-WM_DESTROY
   5）调用EndDialog（IDCANCEL），直接到WM_DESTROY消息
这些方式都可以的，要是你的关闭没有成功，那么一定是出现内存泄漏，你需要在WM_DESTROY消息中释放资源，应为WM_DESTROY消息是所有销毁方式都要发送的。
-----------------------------
下面的据说也可以，没有试过。
PostQuitMessage(0)和exit(0)和ExitProcess()
https://blog.csdn.net/wchengshen/article/details/24535151

总结：MFC中一个对话框的关闭过程
说起来挺简单的，一个对话框关闭时要依次调用该类的DestroyWindow-OnDestroy-PostNcDestroy，根据关闭的方法不同，在这些函数之前会调用OnOK、OnCancle或者OnClose。
这里要说的是，模态对话框的消息循环要到调用了PostNcDestroy之后才真正的结束，即ContinueModal循环在这里才结束，然后类的析构函数将被调用，这个对话框才真正的被销毁了。
如果一个模态对话框还有一个模态的子对话框，那就更要注意了。如果子对话框还在显示的时候，父对话框由于某种原因关闭了(如从其他线程接收到了WM_CLOSE消息)，父对话框在执行完OnClose函数后会等到，直到子对话框销毁了，才会继续执行自己的如第一段所说的关闭过程。
 
https://blog.csdn.net/andy5zhu/article/details/17322373

MFC使用Create创建创建窗体后释放内存的方法
//结束时
        delete pTd;
        pTd = NULL;
        这样的写法就会出现的Warning: calling DestroyWindow in CDialog::~CDialog --,正确的做法如下：
        //结束时应该
        if(pTd)
        {
            pTd->DestoryWindow();
            pTd = NULL;
        }
        //在后生成的窗口类中加如下代码
//添加消息PostNcDestory 
        void CTestDlg ::PostNcDestroy()
        {
            // TODO: 在此添加专用代码和/或调用基类
            delete this;//这个一定要
            CDialog::PostNcDestroy();
        }
――――――――――――――――
版权声明：本文为CSDN博主「爷就是这个范儿」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/syytem004/article/details/43526055
这样的写法就会出现的Warning: calling DestroyWindow in CDialog::~CDialog --,正确的做法如下：

MFC非模态对话框内存释放
非模态对话框的内存释放：
第一步：在OnClose() 函数中添加DestroyWindow() ；
第二步：在PostNcDestroy() 中添加delete this。
https://blog.csdn.net/qq_32561069/article/details/71249296

MFC DestroyWindow
DestroyWindow会发送WM_NCDESTROY；

5.       WM_NCDESTROY对应的消息处理函数是OnNcDestroy；


6.       OnNcDestroy最后会调用PostNcDestroy；

7.       PostNcDestroy经常被用户重载以提供释放内存操作。
例如可以使用delete this；
通过这种方式，窗口对象对应的窗口和窗口对象本身都被释放了。
――――――――――――――――
版权声明：本文为CSDN博主「工程师WWW」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weiwangchao_/article/details/7031011
https://blog.csdn.net/weiwangchao_/article/details/7031011

为什么微软的MFC源代码中，有大量的delete this? [问题点数：40分，结帖人medeel]
https://bbs.csdn.net/topics/370002679

delete this 的使用及注意事项
https://blog.csdn.net/nie2314550441/article/details/76880711

在类中调用delete this问题
https://blog.csdn.net/kuimzzs/article/details/81517451

为什么MFC自动生成的类，没有析构函数的声明
默认的析构函数
在mfc中CDialog的析构函数
CDialog::~CDialog()
{
if (m_hWnd != NULL)
{
TRACE0( "Warning: calling DestroyWindow in CDialog::~CDialog --\n ");
TRACE0( "\tOnDestroy or PostNcDestroy in derived class will not be called.\n ");
DestroyWindow();
}
而你创建的这个对话框类是继承于CDialog。
}
https://zhidao.baidu.com/question/238238619.html


MFC对话框什么找不到析构函数？自己定义又提示错误“已定义”。。。。急
因为由于不在头文件中声明析构函数，编译器会自动生成一个析构函数；我觉得你的问题是因为你没有在头文件中声明析构函数，而直接在cpp文件定义了析构函数。由于头文件中没有声明，编译器已经帮你定义了一个了，你再次定义时，就会出错，显示函数体已经存在了。
https://zhidao.baidu.com/question/492775435.html?sort=11&rn=5&pn=0#wgt-answers

C++中类对象的创建与释放过程
在C++的学习过程中，来分享类对象的创建过程与释放过程，即类对象的构造函数与析构函数；
//********************************************
创建过程：
       分配内存（对象）-> 父类构造函数-> 成员的构造函数-> 自己的构造函数
父类构造的顺序：按照继承表从左到右依次构造。
成员构造的顺序：按照声明顺序从上至下依次构造
释放过程：
       自己的析构函数 -> 成员析构函数-> 父类析构函数-> 释放内存（对象）
析构成员的顺序：按照声明顺序从上至下依次析构
析构父类的顺序：按照继承表从左到右依次析构
//*********************************************
实现的C++代码：
――――――――――――――――
版权声明：本文为CSDN博主「芥末味鸭肠」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_43505112/article/details/99705745
https://blog.csdn.net/weixin_43505112/article/details/99705745

浅谈new/delete和malloc/free的用法与区别
三.new和malloc的区别
a.属性

　　new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持c。

b.参数

　　使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。

c.返回类型

　　new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

e. 分配失败

　　new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。
https://www.cnblogs.com/maluning/p/7944231.html



启用内存泄漏检测
https://www.cnblogs.com/itdef/p/9883497.html

简单内存泄漏检测方法 解决 Detected memory leaks!
Detected memory leaks!
Dumping objects ->
{98500} normal block at 0x05785AD0, 152 bytes long.
 Data: << N       N x 7 > 3C AC 4E 10 00 00 00 00 BC A4 4E 10 78 B6 37 00
Object dump complete.
而且每次退出都是一样的.泄漏的内存块都是98500.

解决方法:

1. 在程序开始启动的地方(足够前的地方,只要在泄漏的内存分配的前面,比如在一个大的工程中的app类的构造函数中)使用代码:

_CrtSetBreakAlloc(98500); //98500为上面内存泄漏的块号.

2. 然后debug运行,程序自动断点在"内存块98500"分配的位置:

if (_crtBreakAlloc != -1L && lRequest == _crtBreakAlloc)
    _CrtDbgBreak();
3 .我们已经找到了泄漏的那块内存分配的底层操作的地方了(好拗口!).

这个时候我们利用 "调试" C> "退出" ,快捷键为:"Shift + F11" .

跳出当前函数..然后一直往"上"跳,边跳边查看调用栈.直到看到了自己写的代码,例如我的

std::ifstream* origStream = new std::ifstream();
4 .这个时候我已经可以判断 origStream 分配了内存,但是没有合理释放.处理后再次运行就没有出现内存泄漏了.

5.最后,记得把_CrtSetBreakAlloc(98500); 这句话删除掉,不然每次都断点,岂不是烦死..

----------------------------------------------------------------------------------------------------------

写在后面:

关于内存泄漏检测,有一个Visual Leak Detector ,按照它的介绍的确很不错,可以直接具体到代码行指出内存泄漏,但是个人使用了一下,发现debug的速度太慢了,不知道是不是我个人程序的问题.......像上面的泄漏,我用CrtSetBreakAlloc这种简单的方法就足够了....
https://www.cnblogs.com/dorothychai/archive/2012/03/22/2412031.html

最快速度找到内存泄漏
有没有可能，我们让程序运行到第52次内存分配操作的时候，自动停下来，进入调试状态？所幸，crtdbg确实提供了这样的函数：即 long _CrtSetBreakAlloc(long nAllocID)。我们加上它：
https://blog.csdn.net/qq_33826977/article/details/79750294


VC检测内存泄漏（Detected memory leaks!）
Detected memory leaks!
Dumping objects ->
{98500} normal block at 0x05785AD0, 152 bytes long.
Data: << N       N x 7 > 3C AC 4E 10 00 00 00 00 BC A4 4E 10 78 B6 37 00
Object dump complete.
解决方法:
在程序开始启动的地方(足够前的地方,只要在泄漏的内存分配的前面)使用代码:
_CrtSetBreakAlloc(98500); //98500为上面内存泄漏的块号,然后在堆栈窗口即可知道哪里allocated的memory未释放。
https://www.cnblogs.com/bigfi/p/7682416.html


2020.01.14

leaks

VC++获取文件大小集锦
WIN32_FIND_DATA fileInfo;
HANDLE hFind;
DWORD fileSize;
const char *fileName = 文件的路径及名字;
hFind = FindFirstFile(fileName ,&fileInfo);
if(hFind != INVALID_HANDLE_VALUE)
fileSize = fileInfo.nFileSizeLow;
FindClose(hFind);
https://blog.csdn.net/feidegengao/article/details/8231554

MFC 两种创建状态栏方法以及在状态栏实时显示时间
一、创建状态栏的两种方法
创建状态栏有两种方法，分别使用CStatusBarCtrl和CStatusBar两个类来完成
方法一：
1.添加成员变量CStatusBarCtrl m_StatusBar;
2.在OnInitDialog()中加入：
                  m_StatusBar.Create(WS_CHILD|WS_VISIBLE|SBT_OWNERDRAW, CRect(0,0,0,0), this, 0);

                  int strPartDim[3]= {100, 200, -1}; //分割数量
                  m_StatusBar.SetParts(3, strPartDim);

                  //设置状态栏文本                  m_StatusBar.SetText("分栏一", 0, 0);                  m_StatusBar.SetText("分栏二", 1, 0);                  m_StatusBar.SetText("分栏三", 2, 0);                  //下面是在状态栏中加入图标                  m_StatusBar.SetIcon(1,                                 SetIcon(AfxGetApp()->LoadIcon(IDR_MAINFRAME),

                                FALSE));//为第二个分栏中加的图标

方法二：
1.添加成员变量CStatusBar m_wndStatusBar;
2.在OnInitDialog()中加入：
                  static UINT indicators[] =
                  {
                                ID_SEPARATOR,                        // status line indicator
                                ID_INDICATOR_CAPS,              //CAP lock indicator.
                                ID_INDICATOR_NUM,               //NUM lock indicator.
                                ID_INDICATOR_SCRL,              //SCRL lock indicator.
                  };

                  if (!m_wndStatusBar.Create(this) ||
                                !m_wndStatusBar.SetIndicators(indicators,
                                  sizeof(indicators)/sizeof(UINT)))
                  {
                                TRACE0("Failed to create status barn");
                                return -1;         // fail to create
                  }

                  UINT nID;        //控制状态栏里面的分栏
                  m_wndStatusBar.SetPaneInfo(0,nID,SBPS_STRETCH|SBPS_NOBORDERS,100);      //返回值存nID中
                  m_wndStatusBar.SetPaneText(0,"就绪");

                  m_wndStatusBar.SetPaneInfo(1,nID,SBPS_NORMAL,100);
                  m_wndStatusBar.SetPaneText(1,"大写");

                  m_wndStatusBar.SetPaneInfo(2,nID,SBPS_POPOUT,100);
                  m_wndStatusBar.SetPaneText(2,"数字");

                 //----------------让这个状态栏最终显示在对话框中-------------                  RepositionBars(AFX_IDW_CONTROLBAR_FIRST,AFX_IDW_CONTROLBAR_LAST,0);
――――――――――――――――
版权声明：本文为CSDN博主「HW140701」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/HW140701/article/details/53995464
https://blog.csdn.net/HW140701/article/details/53995464

VC中获取文件大小
#include <io.h>
int getfilesize01()
 {
     int fp;
     fp=_open(__FILE__,_O_RDONLY);
     if(fp==-1) 
         return NULL;
     return _filelength(fp);
     //return NULL;
 }
https://blog.csdn.net/qq_23992597/article/details/52162740

在基于对话框的MFC创建状态栏以及添加时间显示
https://blog.csdn.net/Cowry5/article/details/79618339

MFC在状态栏实时显示系统时间
1.定义状态栏句柄
HWND Statu;
2.窗口初始化函数中创建状态栏
statu = CreateStatusWindow(WS_CHILD|WS_VISIBLE,"音乐播放器v1.0",this->m_hWnd,IDI_ICON_LOGO);
3.时钟响应函数
void CPracticalplayerDlg::OnTimer(UINT_PTR nIDEvent)
{
 CTime t = CTime::GetCurrentTime();
 CString str;
 str.Format("%04d/%02d/%02d  %02d:%02d:%02d",t.GetYear(),t.GetMonth(),t.GetDay(),t.GetHour(),t.GetMinute(),t.GetSecond());
 ::SetWindowText(statu,str);
 CDialogEx::OnTimer(nIDEvent);
}
4.窗口初始化函数中设置时钟
SetTimer(1,1000,NULL);
――――――――――――――――
版权声明：本文为CSDN博主「九月丫头」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/wangwenjing90/article/details/8481638
https://blog.csdn.net/wangwenjing90/article/details/8481638

MFC之对话框 添加状态栏 实时显示时间
https://blog.csdn.net/i_likechard/article/details/77508571

C语言中%f表示的是什么，为什么有时小数点后保留6位，有时小数点后保留1位
printf("%f", fVal ); //这是浮点默认输出格式，小数点保留6位
printf("%.1f", fVal ); //.1是说明，小数点保留1位，对其后的数据进行四舍五入
printf("%.2f", fVal ); //.2是说明，小数点保留2位，对其后的数据进行四舍五入，你想保留几位，就用点几
printf("%10f", fVal ); //输出宽度为10个字符，右对齐，前补空格，小数点保留6位
printf("%10.2f", fVal ); //输出宽度为10个字符，右对齐，前补空格，小数点保留2位
https://zhidao.baidu.com/question/938443103429394372.html

VC/MFC 如何使列表控件（CListCtrl）可编辑
五、（注意）要显示的控件和列表控件的ID号必须相连，并且列表ID大于显示控件ID,处理方法为：在对话框中依次按下“CTRL+D”组合键，如图：按照顺序依次点击相应控件重新对控件进行排序。
（注意）要显示的控件和列表控件的ID号必须相连，并且列表ID大于显示控件ID,处理方法请参考第五步
https://jingyan.baidu.com/article/e75057f2f438f8ebc91a89a7.html

在VC中改变TAB顺序的方法
用VC来写MFC程序的时候，多数情况下，会发现TAB顺序和预期的顺序不一致，那么这时就有必要重新调整TAB顺序，
来适应我们所写的程序。
    调整TAB顺序的方法有两种：
    1.在当前的界面或对话框下按“Ctrl+D”键，就会出现各个控件的TAB序号，我们只需
要操作鼠标点击，即可调整出我们想要的顺序了。
    2.打开资源视图文件(*.rc)，找到相应的BEGIN...END 模块里边，把对CSpinButtonCtrl
所定义的属性描述剪切到所要关联控件属性描述后边，即可。
https://blog.csdn.net/weixin_34332905/article/details/85694139


VC6 注册表DevStudio

VC6 修改资源默认语言

【MFC】 多国语言设置
设置方法： 
1、准备好中文对话框 
2、在资源视图中右键中文对话框，选择“插入副本”，选择目标语言。 
3、在对话框副本中修改成对应的目标语言 
4、判断系统语言类型

LANGID lid = GetSystemDefaultLangID();1

5、根据获取到的系统语言设置对应语言的应用程序



 //多国语言支持
    LANGID lid = GetSystemDefaultLangID();
    if(LANGUAGE_EN == lid)
    {
        //英语 0x0809
        SetThreadUILanguage( MAKELCID( MAKELANGID( LANG_ENGLISH , SUBLANG_ENGLISH_US ) , SORT_DEFAULT ) );
    }
    else
    {
        //中文 0x0804
        SetThreadUILanguage( MAKELCID( MAKELANGID( LANG_CHINESE , SUBLANG_CHINESE_SIMPLIFIED ) , SORT_DEFAULT ) );
    }
12345678910111213

将上述代码放置到MFC工程中的InitInstance()函数中即可。

语言表可以参考： 
https://msdn.microsoft.com/en-us/library/windows/desktop/dd318693(v=vs.85).aspx

测试：系统设置中修改区域和语言，下载并安装语言包，重启电脑。
――――――――――――――――
版权声明：本文为CSDN博主「brunomarss」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/brunomarss/article/details/54411006
https://blog.csdn.net/brunomarss/article/details/54411006

在VC 中实现多国语言切换 - 豆丁网
http://www.docin.com/p-1297243905.html

VC的若干实用小技巧(-)
Visual C++6.0(5.0)开发工具功能非常强大，但是对于初学者来说，却有很多细节的问题需要注意。作者搜集整理了以下一些实用小技巧，希望对初学者有所帮助。 
1:使用vc开发项目时，常会遇到这种情况： 
即明明只改动了一个文件，却要把整个项目全部重新编译连接一次。刚刚连接好，一运行，又提示重新编译连接一次，非常讨厌。这是因为出现了未来文件的缘故。 
解决方法： 
找出对应文件夹下的debug目录，将未来文件全部delete, 再rebuild all一次。(未来 文件即其创建和修改时间都比系统时间靠后） 
2:有时，workspace中的classview显示混乱。其表现如下： 
(1):添加的成员变量或函数不能显示； 
(2):即使显示出来了变量或函数，双击后不能跳至正确的位置。 
解决方法： 
删除.ncb文件，再rebuild all. 
3:如何干净的删除一个类？ 
1:先从workspace中的FileView中删除对应的.h和.cpp文件。 
2.再关闭项目，从实际的文件夹中删除对应的.h和.cpp文件。 
3.灾删除.clw文件。 
打开项目，rebuild all。 
4:初学者常有这样的疑惑： 
直接望工程文件里加入一个CPP原文件再编译连接的话老是提示没有找到预编译头 
解决方法： 
#include "stdafx.h" 
5:如何向项目中加入自己定义的类? 
方法很多，介绍一个简便的： 
选择Insert/New Class菜单 
弹出对话框； 
选择Class Type为generic; 
输入类名。 
当然，也可以自己决定该类的基类 
6:如何在工作区(Workspace)导入多个项目(Project)? 
在打开一个项目(*.dsp文件)后，在利用“Project” 菜单下Insert Project into Workspace 子菜单选择另一个项目文件（*.dsp文件），可插入另一个项目。 
在ClassView 视图中，右键可以激活其中某个项目，工作区插入多个项目能方便不同项目间拷贝代码、资源等。 
7: 在ClassView 视图中类太多如何整理? 
我们可以在ClassView 视图中右键新建文件夹（New Folder），再把具有相近性质的类拖到对应的文件夹中，使整个视图看上去清晰明了。 
8：如何快速删除项目下Debug 文件夹中临时文件? 
在FileView视图中选中对应项目，右键Clean即可。 
9: 打开一个源文件较大的项目编辑操作非常慢，怎么办? 
不要打开项目文件(*.dsp文件)，直接打开要编辑的单个源文件（*.h或*.cpp）进行编辑，要快得多。 
10:如果想把整个项目拷贝到软盘，那些文件可以删掉? 
除了项目文件夹中debug文件夹可以删除外，.ncb,.clw,.opt 等文件也可以删除，这些文件Rebuilt all后可以重新生成。 
――――――――――――――――
版权声明：本文为CSDN博主「ShowMan」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/ShowMan/article/details/9158


VC6 修改资源默认语言
DevStudio

VC6开发环境、调试、语言的若干实用小技巧【转】
https://www.baidu.com/s?wd=VC6%20%E4%BF%AE%E6%94%B9%E8%B5%84%E6%BA%90%E9%BB%98%E8%AE%A4%E8%AF%AD%E8%A8%80&pn=10&oq=VC6%20%E4%BF%AE%E6%94%B9%E8%B5%84%E6%BA%90%E9%BB%98%E8%AE%A4%E8%AF%AD%E8%A8%80&ie=utf-8&rsv_idx=1&rsv_pq=a57fa0a900676731&rsv_t=2a47XSsDu8uHl5EFUgy8fi7%2FAaZEyPTRkpT2LgGZiDCafOXwqtEXQTZ0jQM

VC6.0的若干实用小技巧 
　1:使用vc开发项目时，常会遇到这种情况： 　 　　即明明只改动了一个文件，却要把整个项目全部重新编译连接一次。刚刚连接好，一运行，又提示重新编译连接一次，非常讨厌。这是因为出现了未来文件的缘故。 　 　　解决方法： 　 　　找出对应文件夹下的debug目录，将未来文件全部delete, 再rebuild all一次。(未来 文件即其创建和修改时间都比系统时间靠后） 　　 　　2:有时，workspace中的classview显示混乱。其表现如下： 　 　　(1):添加的成员变量或函数不能显示； 　 　　(2):即使显示出来了变量或函数，双击后不能跳至正确的位置。 　 　　解决方法： 　　 　　删除.ncb文件，再rebuild all. 　 　　3:如何干净的删除一个类？ 　　 　　1:先从workspace中的FileView中删除对应的.h和.cpp文件。 　 　　2.再关闭项目，从实际的文件夹中删除对应的.h和.cpp文件。 　 　　3.灾删除.clw文件。 　 　　打开项目，rebuild all。 　 　　4:初学者常有这样的疑惑： 　 　　直接望工程文件里加入一个CPP原文件再编译连接的话老是提示没有找到预编译头 　 　　解决方法： 　 　　#include "stdafx.h" 　 　　5:如何向项目中加入自己定义的类? 　 　　方法很多，介绍一个简便的： 　 　　选择Insert/New Class菜单 　 　　弹出对话框； 　 　　选择Class Type为generic; 　 　　输入类名。 　 　　当然，也可以自己决定该类的基类 　 　6:如何在工作区(Workspace)导入多个项目(Project)? 　 　　在打开一个项目(*.dsp文件)后，在利用“Project” 菜单下Insert Project into Workspace 子菜单选择另一个项目文件（*.dsp文件），可插入另一个项目。　 　　在ClassView 视图中，右键可以激活其中某个项目，工作区插入多个项目能方便不同项目间拷贝代码、资源等。 　　 　　7: 在ClassView 视图中类太多如何整理? 　 　　我们可以在ClassView 视图中右键新建文件夹（New Folder），再把具有相近性质的类拖到对应的文件夹中，使整个视图看上去清晰明了。 　　8：如何快速删除项目下Debug 文件夹中临时文件? 　 　　在FileView视图中选中对应项目，右键Clean即可。 　 　　9: 打开一个源文件较大的项目编辑操作非常慢，怎么办? 　 　　不要打开项目文件(*.dsp文件)，直接打开要编辑的单个源文件（*.h或*.cpp）进行编辑，要快得多。 　 　　10:如果想把整个项目拷贝到软盘，那些文件可以删掉? 　 　　除了项目文件夹中debug文件夹可以删除外，.ncb,.clw,.opt 等文件也可以删除，这些文件Rebuilt all后可以重新生成。 　　 　　11：怎样快速生成一个与现有项目除了项目名外完全相同的新项目? 　 　　利用File菜单下生成新项目中的Custom AppWizard ，选择 An existing Project ,然后选择现有项目的项目文件名（*.dsp）Finish,编译后就生成一个可以生成与现有项目相同但可以重新取名的项目的AppWizard。你可以象用MFC AppWizard一样用它。如果不想用了，可以在VC 安装目录下Common/MSDev98/Template目录中删除该Wizard中.awx和 .pdb文件。 　　 　　12:如何在源文件中定位光标到对称的{ }和 #if, #endif ? 　　 　　前者使用Ctrl和 “} ”键 ，后者使用Ctrl和“K”键。
            　13：如何在VC中设置头文件和库文件？ 　　 　　除了VC缺省头文件和库文件外，如果经常要用到第三方的头文件和库文件可以在Tools Options 的Directories中设置。如果只是本项目要用到，可以在Project Setting->Link Object/library Modules中设置库文件。 　 　　14:如果让控制台应用程序支持MFC类库？ 　 　　可以在控制台应用程序中include 来引入MFC库，但是控制台应用程序缺省是单线程的，MFC是多线程的，为解决该矛盾，在Project Setting->C/C++ 选项，选择Code Generation,在Use Run-Time Library 下拉框中选择Debug Multithread。 　 　　15:如何为一个MFC应用程序添加ODBC功能？ 　 　　（1）在文件Stdafx.h文件末尾添加下面一行： 　　 　　#include // MFC ODBC database classes 　　 　　（2）在文本模式下编辑RC文件（利用File->Open As text 方式） 　 　　在下面的程序行（共有两处） 　　 　　#include "l.chs/afxprint.rc" // printing/print preview resources 　 　　添加下一行： 　 　　#include "l.chs/afxdb.rc" // Database resources 　　 　　16：数据库表修改后，如何快速更新一个绑定到表的CrecordSet记录集？ 　 　　利用ClassWizard 中 Member Variables标签下选中记录集类后，利用UpdateColoumns和Bind All。 　 　　17：如何汉化只有可执行代码的.exe 文件？ 　 　　在NT 下利用VC Open File 以Resources方式打开*.exe 文件，直接修改资源文件，然后保存即可。 　　 　　以上只是初学VC者常遇到的一些小问题，希望和大家共同学习。
――――――――――――――――
版权声明：本文为CSDN博主「Micro_lee」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Micro_lee/article/details/837620


VC++ 修改资源页面语言
选中 资源文件，在“属性”页面中更改 “language”选项：
资源视图中：
属性 页面中：
https://www.cnblogs.com/pangkang/p/5852690.html

VC6 你的资源使用的语言是默认

列表编辑框右键不弹出复制菜单原因调试.(v ok)
VC/MFC 如何使列表控件（CListCtrl）可编辑
五、（注意）要显示的控件和列表控件的ID号必须相连，并且列表ID大于显示控件ID,处理方法为：在对话框中依次按下“CTRL+D”组合键，如图：按照顺序依次点击相应控件重新对控件进行排序。
（注意）要显示的控件和列表控件的ID号必须相连，并且列表ID大于显示控件ID,处理方法请参考第五步
https://jingyan.baidu.com/article/e75057f2f438f8ebc91a89a7.html

2020.01.13

3963之前都没有详细数据.


VC控件与变量绑定,赋值，获取方式总结
一. 不绑定变量的赋值和获取方法一
GetDlgItem(IDC_EDIT1)->GetWindowText(变量)；
 如果是数组->GetWindowText(数组名，长度)
GetDlgItem(IDC_EDIT1)->SetWindowText(变量)；
二. 不绑定变量的赋值和获取方法二
CString str;
SetDlgItemText(IDC_EDIT1,"1");
GetDlgItemText(IDC_EDIT1,str);
 
三. 绑定value型变量（一共4处）获取，赋值
 
<1处>***Dlg.h : 头文件
class C***Dlg : public CDialog
{
// 构造
public:
 C***Dlg(CWnd* pParent = NULL); // 标准构造函数
// 对话框数据
 enum { IDD = IDD_***_DIALOG };
 protected:
 virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持
// 实现
protected:
 HICON m_hIcon;
 // 生成的消息映射函数
 virtual BOOL OnInitDialog();
 afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
 afx_msg void OnPaint();
 afx_msg HCURSOR OnQueryDragIcon();
 DECLARE_MESSAGE_MAP()
public:
 afx_msg void OnBnClickedOk();
 CString edit1;    //定义了该变量
};

<2处> ***Dlg.cpp : 实现文件
C***Dlg::C***Dlg(CWnd* pParent )
 : CDialog(C***Dlg::IDD, pParent)
 , edit1(_T(""))
{
 m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}
参数列表跟了m_edit1

<3处> ***Dlg.cpp : 实现文件
void C***Dlg::DoDataExchange(CDataExchange* pDX)
{
 CDialog::DoDataExchange(pDX);
 DDX_Text(pDX, IDC_EDIT1, m_edit1);
 }
DDX_Text(pDX, IDC_EDIT1, m_edit1);  变量与控件关联
 
<4处>//应用之处
UpdateData(TRUE) ；
edit1="你要赋值的";
 UpdateData(FALSE) ；

通过调用 UpdateData(TRUE)  UpdateData(FALSE) 将控件数据取到变量或将变量数据显到控件
如果 变量赋值语句写在对话框构造函数里，则UpdateData(FALSE)可省略，会被自动调用

三. 绑的是control型变量

代码与上方一样,看m_edit2
但只有两处涉及
CEdit m_edit2;
DDX_Control(pDX, IDC_EDIT2, m_edit2);
程序里只需要   m_edit2.GetWindowText(变量);
               m_edit2.SetWindowText(变量);就可以用了
除了赋值,还能干很多事情.
――――――――――――――――
版权声明：本文为CSDN博主「qinxiaoli1204」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qinxiaoli1204/article/details/6901462

https://blog.csdn.net/qinxiaoli1204/article/details/6901462

MFC EnableMenuItem_使能菜单
MSDN是最佳的查找解决办法的工具,但是他不是万能的
CMenu* mmenu =GetMenu();
CMenu* submenu =mmenu->GetSubMenu(0);
submenu->EnableMenuItem(ID_FILE_NEW,MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
使menu菜单不可选,变灰,........
MSDN的代码例子都给出来了,可是使用却无法成效.句柄都获得,返回0,也没出错.
https://blog.csdn.net/autumn20080101/article/details/8802326

//struct _Frame_e  // get from _tagTTDataFrame
//{
//	int nLength;
//	time_t lTime;
//	BYTE btGroupCode;
//	char arItemCode[8];
//	BYTE btTransCode;
//	int nTransDataLength;
//	void * pTransData;

//	DWORD	dwVal;
//	WORD	BrokerNo;
//	WORD	TradeTime;
//	DWORD   TradeTime2; 
//	WORD	Key;
//	float	Price;
//	unsigned long Quantity;
//	BYTE	TyadeType;
//	DWORD	lTemp;
//	BYTE	byTmp;
//};



vc右键菜单
CMenu menu ,* pSubMenu;//定义下面要用到的cmenu对象
?menu.LoadMenu(IDR_POPMENU);//装载自定义的右键菜单

?pSubMenu = menu.GetSubMenu(0);//获取第一个弹出菜单，所以第一个菜单必须有子菜单

?CPoint oPoint;//定义一个用于确定光标位置的位置
?GetCursorPos( &oPoint);//获取当前光标的位置，以便使得菜单可以跟随光标

?pSubMenu->TrackPopupMenu (TPM_LEFTALIGN, oPoint.x, oPoint.y, this); //在指定位置显示弹出菜单
――――――――――――――――
版权声明：本文为CSDN博主「sevene2015」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/aGan2007/article/details/1693599
https://blog.csdn.net/aGan2007/article/details/1693599

VC 添加右键菜单
void CGVideoDlg::OnContextMenu(CWnd* /*pWnd*/, CPoint point)
{
	// TODO: 在此处添加消息处理程序代码
	CRect rect;
	GetDlgItem(IDC_PLAYER)->GetWindowRect(&rect);
	if (rect.PtInRect(point))
	{
		CMenu menu;
		VERIFY(menu.LoadMenuW(IDR_MENU1));
 
		CMenu *pPopup = menu.GetSubMenu(0);
		ASSERT(pPopup != NULL);
		pPopup->TrackPopupMenu(TPM_LEFTALIGN|TPM_LEFTBUTTON, point.x, point.y, this);
	}
}
https://blog.csdn.net/ljz9425/article/details/6877935

VC 添加对话框右键菜单方法
给对话框添加右键菜单有好多方法，下面简单介绍两种。
一、响应WM_RBUTTONDOWN消息
在响应函数中添加以下代码
//右键菜单
CMenu menu;
menu.LoadMenu(IDR_MENU);
ClientToScreen(&point);
menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN|TPM_LEFTBUTTON,point.x,point.y,this);
//end
二、响应WM_CONTEXTMENU消息
在响应函数中添加以下代码
//右键菜单
CMenu menu;
menu.LoadMenu(IDR_MENU);
menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN|TPM_LEFTBUTTON,point.x,point.y,pWnd);
//end
https://blog.csdn.net/u010258235/article/details/9945707


VC 创建弹出式菜单
void CMy82Dlg::OnRButtonUp(UINT nFlags, CPoint point)
{
	// TODO: 在此添加消息处理程序代码和/或调用默认值
	CMenu *pMenu = m_Menu.GetSubMenu(0);			//获得菜单句柄
	CRect rect;
	ClientToScreen(&point);							//将客户坐标转换为屏幕坐标
	rect.top = point.x;								//将鼠标当前横坐标作为弹出菜单的左上角坐标
	rect.left = point.y;							//将鼠标当前纵坐标作为弹出菜单的左上角坐标
	pMenu->TrackPopupMenu(TPM_LEFTALIGN|TPM_RIGHTBUTTON|TPM_VERTICAL,rect.top,rect.left,this,&rect);		//显示弹出菜单
	CDialogEx::OnRButtonUp(nFlags, point);
}
https://blog.csdn.net/homechao/article/details/8571910


MFC点击按钮弹出菜单
CMenu menu,*pMenu;
menu.LoadMenu(IDR_MENU_MANAGE);
CRect pt;
GetDlgItem(IDC_BUTTON)->GetWindowRect(&pt);
pMenu = menu.GetSubMenu(0);
pMenu->TrackPopupMenu(TPM_LEFTALIGN,ppt.left,ppt.bottom,this);  
https://blog.csdn.net/rundll64/article/details/24860865

void CShowData::OnRclickListData(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// TODO: Add your control notification handler code here
	
	NM_LISTVIEW*   pNMListView   =   (NM_LISTVIEW*)pNMHDR;  
	CRect CEret;
	CRect offset;
	if(m_list_data.GetSubItemRect(pNMListView->iItem, pNMListView->iSubItem, LVIR_LABEL, CEret))//取得指定单元格大小
	{
		m_list_data.GetWindowRect(&offset);   
		ScreenToClient(&offset);   
	}
	CPoint point;
	point.x = offset.TopLeft().x + CEret.TopLeft().x + 2;
	point.y = offset.TopLeft().y + CEret.TopLeft().y + 2;

	ClientToScreen(&point);

	CMenu menu;//菜单
	CMenu* pPopupMenu;//菜单指针
	menu.LoadMenu(IDR_MENU1);//加载ID为IDR_MENU1的菜单
	pPopupMenu = menu.GetSubMenu(0);   //获取弹出菜单的第一层子菜单的类指针
	pPopupMenu->TrackPopupMenu(TPM_BOTTOMALIGN,point.x,point.y,this,NULL); //point.x,point.y TPM_BOTTOMALIGN  TPM_LEFTALIGN

	*pResult = 0;
}



VC++实现弹出菜单(转)
void CPopupMenuDlg::OnLButtonDown(UINT nFlags, CPoint point)
{
 // TODO: 在此添加消息处理程序代码和/或调用默认值
 CMenu menu;//菜单
 CMenu* pPopupMenu;//菜单指针
 CBitmap m_bitmap1;//位图
 
 menu.LoadMenu(IDR_MENU1);//加载ID为IDR_MENU1的菜单
 m_bitmap1.LoadBitmap(IDB_BITMAP1);//加载ID为IDB_BITMAP1的位图

 pPopupMenu = menu.GetSubMenu(0);   //获取弹出菜单的第一层子菜单的类指针

//为菜单的第一和第三项设置图标
 pPopupMenu->SetMenuItemBitmaps(0,MF_BYPOSITION,&m_bitmap1,&m_bitmap1); 
 pPopupMenu->SetMenuItemBitmaps(2,MF_BYPOSITION,&m_bitmap1,&m_bitmap1);

 ClientToScreen(&point);//将鼠标单击处的坐标转换为屏幕坐标

//弹出菜单函数，第一个参数表示快捷菜单的下边界与由参数y指定的坐标对齐 

//第二和第三个为x、y坐标，第四个表示拥有此菜单的窗口句柄，

//第五个默认为NULL,表示当用户在菜单以外的区域按鼠标键时，菜单会消失

pPopupMenu->TrackPopupMenu(TPM_BOTTOMALIGN,point.x,point.y,this,NULL);

 CDialog::OnLButtonDown(nFlags, point);
}
https://blog.csdn.net/adu285041555/article/details/8608543

vc6 右键菜单

vc6 对话框右击弹出菜单

FONT 8, "MS Sans Serif", 0, 0, 0x1

FONT 10, "System"

1 invalid_records=3848, records=32424...AHMFC    , tradeticker-- TickTime:17041 92802, key: 9, price:28271.0000, share:1, total:4119, BrokerNo:0
1 invalid_records=3848, records=32425...AHMF20   , tradeticker-- TickTime:17041 92802, key: 7, price:28271.0000, share:1, total:4117, BrokerNo:0
The thread 0x1D50 has exited with code 0 (0x0).

32737

1 invalid_records=3848, records=31862...ACUF20   , tradeticker-- TickTime:17023 92726, key: 0, price:6.9673, share:3, total:20, BrokerNo:0
1 invalid_records=3848, records=31863...ACUF20   , tradeticker-- TickTime:17023 92726, key: 1, price:6.9673, share:1, total:21, BrokerNo:0


1 invalid_records=3848, records=32445...AHIF20   , tradeticker-- TickTime:17042 92804, key: 3, price:28271.0000, share:6, total:6505, BrokerNo:0
1 invalid_records=3848, records=32446...AHMFC    , tradeticker-- TickTime:17042 92804, key: 0, price:28270.0000, share:1, total:4120, BrokerNo:0
1 invalid_records=3848, records=32447...AHMFC    , tradeticker-- TickTime:17042 92804, key: 1, price:28270.0000, share:1, total:4121, BrokerNo:0

frame_e_count = 28889

32737

1 invalid_records=3848, records=32708...AHIF20   , tradeticker-- TickTime:17046 92812, key: 12, price:28268.0000, share:1, total:6570, BrokerNo:0
1 invalid_records=3848, records=32709...AHIF20   , tradeticker-- TickTime:17046 92812, key: 13, price:28268.0000, share:3, total:6571, BrokerNo:0
The thread 0x7E0 has exited with code 0 (0x0).

32737


1 invalid_records=3848, records=31682...AHIF20   , tradeticker-- TickTime:17018 92716, key: 5, price:28280.0000, share:1, total:6314, BrokerNo:0
1 invalid_records=3848, records=31683...AHMFC    , tradeticker-- TickTime:17018 92716, key: 2, price:28281.0000, share:1, total:4032, BrokerNo:0
The thread 0x179C has exited with code 0 (0x0). 35531

32737


1 valid_records=0, records=31749...AHIFC    , tradeticker-- TickTime:17020 92720, key: 4, price:28286.0000, share:1, total:6328, BrokerNo:0
1 valid_records=0, records=31750...AHIFC    , tradeticker-- TickTime:17020 92720, key: 5, price:28286.0000, share:1, total:6329, BrokerNo:0
1 valid_records=0, records=31751...AHIFC    , tradeticker-- TickTime:17020 92720, key: 6, price:28286.0000, share:1, total:6330, BrokerNo:0
The thread 0x628 has exited with code 0 (0x0).


1 valid_records=0, records=31820...AHEF20   , tradeticker-- TickTime:17021 92722, key: 1, price:11224.0000, share:1, total:781, BrokerNo:0
1 valid_records=0, records=31821...AHIFC    , tradeticker-- TickTime:17022 92724, key: 0, price:28285.0000, share:1, total:6339, BrokerNo:0
1 valid_records=0, records=31822...AHIF20   , tradeticker-- TickTime:17022 92724, key: 0, price:28285.0000, share:1, total:6339, BrokerNo:0
1 valid_records=0, records=31823...AHIFC    , tradeticker-- TickTime:17022 92724, key: 1, price:28286.0000, share:1, total:6340, BrokerNo:0
The thread 0x1AD4 has exited with code 0 (0x0).



valid	英[?v?l?d]
美[?v?l?d]
adj.	(法律上) 有效的; (正式) 认可的; 符合逻辑的; 合理的; 有根据的; 确凿的; 有效的; 系统认可的;
[例句]They put forward many valid reasons for not exporting
他们提出了很多不出口的正当理由。

available	英[??ve?l?bl]
美[??ve?l?bl]
adj.	可获得的; 可购得的; 可找到的; 有空的;
[例句]Since 1978, the amount of money available to buy books has fallen by 17%
自1978年以来，可用于采购图书的经费已经减少了17%。

invalid
英[?n?v?l?d , ??nv?l?d]
美[?n?v?l?d , ??nv?l?d]
adj.	(法律上或官方) 不承认的; 无效的; 无充分事实的; 站不住脚的; 不能识别的;
n.	病弱者; 久病衰弱者;
v.	(因伤病) 令…退役;
[例句]I hate being treated as an invalid.
我讨厌被人当作伤病号对待。
[其他]	第三人称单数：invalids 复数：invalids 现在分词：invaliding 过去式：invalided 过去分词：invalided


struct BargRecord
{
public:
	// Stream API.
	BOOL LoadFile( FILE* pFile ) ;
	BOOL SaveFile( FILE* pFile ) ;

	BOOL operator == ( const BargRecord& record ) const ;

public:
	unsigned short m_iBrokerNo ;
	unsigned short m_iTickerTime ;
	unsigned short m_iTransactionKey ;
	float	m_fPrice ;
	long	m_lQuantify ;
	char	m_cTradeType ;
	char	m_cReserve ;

};

Process_t

Process_e

HandleFrame_e

分析并处理e数据

BrokerNo

HandleFrame_t

列表编辑框右键不弹出复制菜单原因调试.
VC/MFC 如何使列表控件（CListCtrl）可编辑
五、（注意）要显示的控件和列表控件的ID号必须相连，并且列表ID大于显示控件ID,处理方法为：在对话框中依次按下“CTRL+D”组合键，如图：按照顺序依次点击相应控件重新对控件进行排序。
（注意）要显示的控件和列表控件的ID号必须相连，并且列表ID大于显示控件ID,处理方法请参考第五步
https://jingyan.baidu.com/article/e75057f2f438f8ebc91a89a7.html

2020.01.10

datacount = 299 2709
datacount = 453 0574 
datacount = 1148 7481
190617X.MDS 339,576 KB

datacount = 271 7545  
200102.MDS 88,725 KB


在VC6中实现多语言支持
随着计算机在各种行业的普及，以及我国软件行业的发展，国产软件在不断的走出国门，所以各种软件的多语言支持也被越来越多的程序员所关注。对于一个软件程序为了支持不同语言，而创建不同的源程序显然不是一个很好的方法。本文主要介绍如何在VC6环境下通过创建支持多语言的资源文件来实现多语言支持。

首先创建一个支持简体中文的工程项目Test，对该工程中的所有资源项使用 Insert Copy命令创建支持英文的资源项；

打开该工程的.rc文件，将该文件中的3 TEXTINCLUDE DISCARDABLE部分改写为：

3 TEXTINCLUDE DISCARDABLE

BEGIN

??? "#define _AFX_NO_SPLITTER_RESOURCES/r/n"

??? "#define _AFX_NO_OLE_RESOURCES/r/n"

??? "#define _AFX_NO_TRACKER_RESOURCES/r/n"

??? "#define _AFX_NO_PROPERTY_RESOURCES/r/n"

??? "/r/n"

??? "#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)/r/n"

??? "#ifdef _WIN32/r/n"

??? "LANGUAGE 4, 2/r/n"

??? "#pragma code_page(936)/r/n"

??? "#endif //_WIN32/r/n"

??? "#include ""res//Test.rc2""? // non-Microsoft Visual C++ edited resources/r/n"

??? "#include ""l.chs//afxres.rc""????????? // Standard components/r/n"

??? "#endif/r/n"

??? "#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)/r/n"

??? "#ifdef _WIN32/r/n"

??? "LANGUAGE 9, 1/r/n"

??? "#pragma code_page(1252)/r/n"

??? "#endif //_WIN32/r/n"

??? "#include ""res// Test .rc2""? // non-Microsoft Visual C++ edited resources/r/n"

??? "#include ""afxres.rc""???????? // Standard components/r/n"

??? "#endif/r/n"

??? "/0"

END

将该文件末尾的Generated from the TEXTINCLUDE 3 resource.部分改写为：

#define _AFX_NO_SPLITTER_RESOURCES

#define _AFX_NO_OLE_RESOURCES

#define _AFX_NO_TRACKER_RESOURCES

#define _AFX_NO_PROPERTY_RESOURCES


?

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)

#ifdef _WIN32

LANGUAGE 4, 2

#pragma code_page(936)

#endif //_WIN32

#include "res/PhTools.rc2"? // non-Microsoft Visual C++ edited resources

#include "l.chs/afxres.rc"????????? // Standard components

#endif

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)

#ifdef _WIN32

LANGUAGE 9, 1

#pragma code_page(1252)

#endif //_WIN32

#include "res/PhTools.rc2"? // non-Microsoft Visual C++ edited resources

#include "afxres.rc"???????? // Standard components

#endif

这样该工程项目的资源就可以支持中文和英文了。从Project菜单选择Setting…选项，打开Project Settings对话框，选择Resources 选项卡，在“Preprocessor definitions”追加“, AFX_TARG_ENU,AFX_RESOURCE_DLL”，对工程进行编译就可生成支持英文的程序，如果不加入“, AFX_TARG_ENU,AFX_RESOURCE_DLL”，对工程进行编译可生成支持中文的程序。

点赞
――――――――――――――――
版权声明：本文为CSDN博主「zzgff」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zzgff/article/details/31588

https://blog.csdn.net/zzgff/article/details/31588

转载：VC在一个工程中实现多语言版本
前段时间笔者因为做一个程序，客户要求要有中英文版本，开始以为要做二个工程，只是资源文件不同，但是发现这样一个工程更新另外一个也要更新，实在是很麻烦 ，后来经过网上查找资料与自己亲身实验，发现其实只要在一个工程中就可以实现。但是这个工程中要有两个资源文件，当编译不同版本时，程序可以自动链接不同资源文件 。下面把具体的方法写出来。供大家参考一下。

第一步、创建中英文版本资源文件

我们先创建第一个中文版本工程，假设工程名称为 Example，在向导第一步的“What language would you like you resource in” 选择中文 (如下图)，其它使用缺省值。



然后在工程中把 Example.rc 删除，这里虽然删除了文件，但实际上在工程文件目录文件还是存在的。进入工程目录下把资源文件名改成Example_Ch.rc，再在 VC 编译器中加入 Example_Ch.rc 文件 ，关闭工程。

然后再创建一个同名的英文版本工程。也就是在选择资源语言时选择英语(可以保存在不同的目录下)



创建完后，把英文版本目录下的 Example.rc 文件拷贝到中文工程的目录下，其实我们就只是要这个资源文件。并把名称改为 Example_En.rc。

第二步、在工程中设置版本信息

打开中文件工程，把英文资源文件添加进工程，在添加时会有提示出现，不要理会，按确认就行。

选择菜单 Build->Configurations，增加一个工程配置，在Configuration中输入 Debug English 在 Copy Setting from 中选择 Debug 就可以(见下图)，使用相同的方法，再增加一个 Debug Chinese 配置，并把原来的 Debug 删除。



第三步、设置工程信息

选择菜单 Project->Settings，在左边的 Setting For 中选择 Debug Chinese 在 Generatl 属性页的 Intermediate files 中输入 Debug Chinese，在 Output files 中输入 Chinese。在 Resource 属性页的 Resource file name 中输入 Debug Chinese/Example_Ch.res，(见下图)其它缺省就行。

用同样的方法在来设置英文版本信息。在左边的 Setting For 中选择 Debug Enghlis 在 Generatl 属性页的 Intermediate files 中输入 Debug Enghlis，在 Output files 中输入 Enghlis。在 Resource 属性页的 Resource file name中输入 Debug English/Example_En.res，其它缺省就行。

本程序在 WIN2000+VC6。0环境下通过。



第四步、修改 DSP 文件，用记事本打开工程下的 Example。dsp 文件

找到如下行:

01.
SOURCE=.\Example_ch.rc
02.
 
03.
# End Source File
04.
# Begin Source File
05.
 
06.
SOURCE=.\Example_en.rc
07.
# PROP Exclude_From_Build 1
08.
 
09.
# End Source File
10.
# Begin Source File
在SOURCE=.\Example_ch.rc行后面加入下面代码

01.
SOURCE=.\Example_ch.rc
02.
 
03.
!IF  "$(CFG)" == "Example - Win32 Debug English"
04.
 
05.
# PROP Exclude_From_Build 1
06.
 
07.
!ELSEIF  "$(CFG)" == "Example - Win32 Debug Chinese"
08.
 
09.
!ENDIF
在SOURCE=.\Example_en.rc行后面加入下面代码：

1.
!IF  "$(CFG)" == "Example - Win32 Debug English"
2.
 
3.
!ELSEIF  "$(CFG)" == "Example - Win32 Debug Chinese"
第五步、现在打开工程，按照不同的要求编译不同版本就行了，比如这个时候我们要英文版本

在编译时选择 Builder->Set Active configuration 中选择 Win32 Debug English 即可，如果要中文版本 ， 在编译时选择 Builder->Set Active configuration 中选择 Win32 Debug Chinese 即可。

结论

如果以后要添加资源，只要在 Resourch。h 文件中定义资源号，然后在中英文资源文件中添加相应的资源串就行，当然这个时候不能直接在工作区的 Resourc 中添加 ，而要用记事本等工具打开资源文件再添加哟。

本程序在Win2000，VC++6.0英文版本下编译通过。

作者信息：

朱勤武

联络电话：057783122865

电子信箱：qingwuzhu@163。net

通讯地址：广东省深圳市福田区上梅新村 159 栋 703

邮编：518049
https://blog.csdn.net/chunyexiyu/article/details/22381063


vc如何产生有效的随机数
int no;
srand((unsigned)time(NULL));
no=rand()%(n)；

例:
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
intmain(void)
{
int i;
time_t t;
srand((unsigned) time(&t));
printf("Ten random numbers from 0 to 99\n\n");
for (i=0; i<10; i++)
printf("%d\n", rand()%100);
return 0;
}
这时运行程序，会发现每次产生的随机数都不一样。这是因为这里采用了时间作为种子,而时间在每时每刻都不相同,所以就产生了"随机"的随机数了。
所以，要想产生不同的随机数，在使用rand之前需要先调用srand。
――――――――――――――――
版权声明：本文为CSDN博主「yueyaquanBoy」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/yueyaquanBoy/article/details/22848281

https://blog.csdn.net/yueyaquanBoy/article/details/22848281

地址: 福田区深南中路1025号新城大厦1楼外文书店 地图 公交 电

选中编辑框后右键没弹复制等菜单.(x no) (v ok)
VC/MFC 如何使列表控件（CListCtrl）可编辑
五、（注意）要显示的控件和列表控件的ID号必须相连，并且列表ID大于显示控件ID,处理方法为：在对话框中依次按下“CTRL+D”组合键，如图：按照顺序依次点击相应控件重新对控件进行排序。
（注意）要显示的控件和列表控件的ID号必须相连，并且列表ID大于显示控件ID,处理方法请参考第五步
https://jingyan.baidu.com/article/e75057f2f438f8ebc91a89a7.html

CString 与数字之间的转换
将字符转换为整数，可以使用atoi、_atoi64或atol。
https://blog.csdn.net/u010025211/article/details/25917957

CString 与 int的互相转换
CString to int:
CString a = "123";
int b;
b = _ttoi(a);
……
int to CString:
b = 123;
a.Format( "%d", b );
https://blog.csdn.net/smallshell7220/article/details/25025293

0x737280001

1578521700

1578530700
1578521700
int CShowData::op_item(_tagTTDataFrame *pStFrame)
{
	int strcount = pME_WD->m_item.GetLength();
	if (strcount == 0)
		return 1;
	else
	{
		for(int i = 0; i< 8-strcount; i++)
		{
			pME_WD->m_item = pME_WD->m_item + ' ';
		}
		if (memcmp(&(pStFrame->arItemCode),pME_WD->m_item,sizeof(char)*8)==0)
			return 1;
		else
			return 0;
	}
}


VC CString 字符串处理函数的应用.doc
https://download.csdn.net/download/zhengyanfeng/3195324

实现MFC CListCtrl控件的可编辑功能(v ok)
https://download.csdn.net/download/shen8686/1472794

VC/MFC 如何使列表控件（CListCtrl）可编辑
https://jingyan.baidu.com/article/e75057f2f438f8ebc91a89a7.html

CListCtrl控件详解
https://blog.csdn.net/milanleon/article/details/29195657

表格控件GridCtrl
https://download.csdn.net/download/yzhuang/3331073

【MFC】CListCtrl列表控件右键复制内容到粘贴板
在列表控件属性中，增加对NM_RCLICK消息处理。
https://blog.csdn.net/sunriver2000/article/details/100134074

listctrl中的cell如何支持被复制
听说grid控件，自带可被复制功能，同时数据又不会被修改，后面可以学习一下该控件的使用。
https://blog.csdn.net/weixin_30399797/article/details/95668148

六种查找算法效率比较
接着上次的排序算法讨论，这次谈的是六种查找算法，分别是：顺序查找、折半查找、二叉树查找、索引查找、开地址哈希查找方法、拉链法哈希查找方法。
https://blog.csdn.net/fangyonghao/article/details/37875373

内存比较函数 - CompareMem（文件、数组等比较）
https://blog.csdn.net/haiou327/article/details/6647162

数据比较函数（内存比较）
https://blog.csdn.net/dongtuoc/article/details/79099485

字符串和内存数据比较函数
https://blog.csdn.net/zhghost/article/details/5286310

关于字符串比较的一点讨论---strcmp与memcmp的效率及实现原理
至此，也明白了为什么这两个函数会有效率的差别，strcmp比较的字符串，而memcmp比较的是内存块，strcmp需要时刻检查是否遇到了字符串结束的 /0 字符，而memcmp则完全不用担心这个问题。另一个区别是
strcmp在比较四字节是逐字节比较，而memcmp是用了字符串比较指令，感觉用字符串比较指令比用逐字节比较好，不知道strcmp为什么比较四字节时不用。感觉memcmp倒是可以用来实现strncmp函数的功能。
遗留的问题有内存字节对齐的问题，以及两处mov edi,edi和一处nop指令的问题。交给以后吧。
――――――――――――――――
版权声明：本文为CSDN博主「jcwKyl」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/jcwKyl/article/details/2217428

strcmp和memcmp两个字符串比较函数
strcmp函数： 
函数原型：int strcmp(const char * s2,const char * s2)；
功能：比较字符串s1和字符串s2的大小。
返回值： 
s1大于s2，返回值大于零 
s1等于s2，返回值等于零 
s1小于s2，返回值小于零
特点：两个字符串之间是逐个按照它们的ASIIC大小来比较的，一旦发现其中一个大于或小于另一个时，比较结束，返回一个值，不然就一直比较到’\0’为止。 
memcmp函数: 
函数原型： 
int memcmp(const void *buf1, const void *buf2, unsigned int count)；
功能：比较内存区域buf1和buf2的前count个字节。
返回值： 
s1大于s2，返回值大于零 
s1等于s2，返回值等于零 
s1小于s2，返回值小于零
特点：memcmp函数也是按ASICC码逐个比较，在strcmp的基础上多加了个功能，他能比较字符串中前count字节的大小。如果count == strlen(s1)，那就是比较字符串中全部字符。
https://blog.csdn.net/Tianzez/article/details/78151454

00:26.97 datacount=271,7545 datainterval=271 ListIndex=32737 ListIndex_bak=0
if (mStFrame.btTransCode == 'e')

00:24.19 datacount=271,7545 datainterval=271 ListIndex=32737 ListIndex_bak=0
		// FindIndex(GetIndex) && ListIndex < ListIndex_bak+100  ps = mCListDataFrame.FindIndex(GetIndex)
		for( ps = mCListDataFrame.GetHeadPosition(); (ps) ; mCListDataFrame.GetNext(ps))  //mCListDataFrame.GetNext(ps)
		{
			//pME_WD->m_TransCode.GetBuffer(2)
			mStFrame = mCListDataFrame.GetAt(ps);
			if (mStFrame.btTransCode == 'e')
			{
				itoa(ListIndex+1,string,10);
				m_list_data.InsertItem(ListIndex,string,0);
				ListIndex++;
			}

//
//			memcpy(GroupCodeString,&mStFrame.btGroupCode,1);
//			m_list_data.SetItemText(ListIndex,1, GroupCodeString);



00:32.13 datacount=271,7545 datainterval=271 ListIndex=1003 ListIndex_bak=1000
SetTimer( 1, 10, NULL ) ;

00:30.48 datacount=271,7545 datainterval=271 ListIndex=3
//			mStFrame = mCListDataFrame.GetAt(ps);
//			itoa(ListIndex+1,string,10);
//			m_list_data.InsertItem(ListIndex,string,0);

// && ListIndex < ListIndex_bak+100
00:35.10 datacount=271,7545 datainterval=271 ListIndex=1003
//			mStFrame = mCListDataFrame.GetAt(ps);
//			itoa(ListIndex+1,string,10);
//			m_list_data.InsertItem(ListIndex,string,0);

c语言中的'\0'的数值是多少 
c语言中“\0”是空字符串。 是字符常量，NULL 字符，ASCII码数值0，用作字符串结尾符。
https://zhidao.baidu.com/question/555056392654487652.html

c语言memset初始化结构体问题
https://zhidao.baidu.com/question/601474806.html?qbl=relate_question_1&word=memset%20%C8%E7%B9%FB%BD%E1%B9%B9%CC%E5%D6%D0%D3%D0%CA%FD%D7%E9%B5%C4%BB%B0%BB%B9%CA%C7%D0%E8%D2%AA%B6%D4%CA%FD%D7%E9%B5%A5%B6%C0%BD%F8%D0%D0%B3%F5%CA%BC%BB%AF%B4%A6%C0%ED%B5%C4

strlen和sizeof有什么区别?
1、sizeof是算符，strlen是函数。 数组做sizeof的参数不退化，传递给strlen就退化为指针了。strlen所作的仅仅是一个计数器的工作，它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，直到碰到第一个字符串结束符'\0'为止，然后返回计数器值(长度不包含'\0')。
2、sizeof操作符的结果类型是size_t，它在头文件中typedef为unsigned int类型。该类型保证能容纳实现所建立的最大对象的字节大小。
https://zhidao.baidu.com/question/12033577.html

memset
另外memset()是一个库函数函数,需要加头文件#include<string.h>
memset是计算机中C/C++语言初始化函数。作用是将某一块内存中的内容全部设置为指定的值， 这个函数通常为新申请的内存做初始化工作。
void *memset(void *s, int ch, size_t n);
函数解释：将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。
memset：作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法 [1]  。
memset()函数原型是extern void *memset(void *buffer, int c, int count) buffer：为指针或是数组,c：是赋给buffer的值,count：是buffer的长度
常见错误
第一：memset函数按字节对内存块进行初始化，所以不能用它将int数组初始化为0和-1之外的其他值（除非该值高字节和低字节相同）。
第二：memset(void *s, int ch,size_t n);中ch实际范围应该在0~~255，因为该函数只能取ch的后八位赋值给你所输入的范围的每个字节
第三： 搞反了 ch 和 n 的位置.一定要记住如果要把一个char a[20]清零，一定是 memset(a,0,20*sizeof(char));而不是 memset(a,20*sizeof(char),0);
第四： 过度使用memset.
char buffer[4];
memset(buffer,0,sizeof(char)*4);
strcpy(buffer,"123");
//"123"中最后隐藏的'\0'占一位，总长4位。
这里的memset是多余的. 因为这块内存马上就被全部覆盖，清零没有意义.
第五：
int some_func(struct something *a)
{memset(a,0,sizeof(a));}
其实这个错误严格来讲不能算用错memset，但是它经常在使用memset的场合出现。这里错误的原因是VC函数传参过程中的指针降级，导致sizeof(a)，返回的是一个something*指针类型大小的的字节数，如果是32位，就是4字节。

int main()
{
    char *s="GoldenGlobalView";
    clrscr();
    memset(s,'G',6);                //这里没有问题，可以编译运行
                    //单步运行到这里会提示内存访问冲突
                     //肯定会访问冲突，s指向的是不可写空间。
    printf("%s",s);
    getchar();
    return 0;
}
一般情况下，清空stTest的方法：
stTest.csName[0]={'\0'}; // question
另外：
如果结构体中有数组的话还是需要对数组单独进行初始化处理的。 // question
https://baike.baidu.com/item/memset/4747579?fr=aladdin

初始化字符串 char[]

2020.01.09

Findwindow

这个关键是要一个主窗口句柄嘛，使用AfxGetMainWnd()这个函数就可以了。
CMyMainDlg *pMMD = (CMyMainDlg*)AfxGetMainWnd();
然后就是
pMMD.ShowWindow(SW_SHOW);

如何判断Dialog窗口

C++多线程――线程同步
#include <Windows.h>
#include <iostream>
using namespace std;

typedef struct  _STRUCT_DATA_
{
	int id; //用于标识出票id
	int tickets;
}_DATA, *_pDATA;

HANDLE g_hEvent;
DWORD WINAPI Fun1(LPVOID lpParam);
DWORD WINAPI Fun2(LPVOID lpParam);

void main()
{
	HANDLE hThread1;
	HANDLE hThread2;

	_DATA stru_data;
	stru_data.id = 0;
	stru_data.tickets = 20;

	g_hEvent = CreateEvent(NULL, FALSE, FALSE, L"Ticket");
	if (g_hEvent) { 
		if (ERROR_ALREADY_EXISTS == GetLastError()) { 
			cout << "the instance is exist!" << endl;			
			return; 
		} 
	}
	
	hThread1 = CreateThread(NULL, 0, Fun1, &stru_data, 0, NULL);
	hThread2 = CreateThread(NULL, 0, Fun2, &stru_data, 0, NULL);

	CloseHandle(hThread1);
	CloseHandle(hThread2);

	SetEvent(g_hEvent);
	Sleep(4000);
	CloseHandle(g_hEvent);
}

DWORD WINAPI Fun1(LPVOID lpParam)
{
	_pDATA data = (_pDATA)lpParam;
	while (TRUE)
	{
		WaitForSingleObject(g_hEvent, INFINITE);
		if (data->tickets > 0)
		{
			Sleep(1);
			cout << "fun1: " << data->id++ ;
			cout << "thread 1:sell ticket: " << data->tickets-- << endl;
			SetEvent(g_hEvent);
		}
		else {
			SetEvent(g_hEvent);
			break;
		}
	}
	return 0;
}

DWORD WINAPI Fun2(LPVOID lpParam)
{
	_pDATA data = (_pDATA)lpParam;
	while (TRUE)
	{
		WaitForSingleObject(g_hEvent, INFINITE);
		if (data->tickets > 0)
		{
			Sleep(1);
			cout << "fun2: " << data->id++ ;
			cout << "thread 2:sell  ticket: " << data->tickets-- << endl;
			SetEvent(g_hEvent);
		}
		else {
			SetEvent(g_hEvent);
			break;
		}
	}
	return 0;
}



https://blog.csdn.net/qq_41498261/article/details/83624326

想问一下POSITION这个变量到底是什么类型，我想将他记录到数据库中，可是… [问题点数：20分，结帖
POSITION变量应该是C++里容器类的迭代器的一个封装吧，如果你想用int来代的话，一般有个FindIndex(int)可以返回第int个元素对应的POSITION变量，如果没有该元素的话，返回NULL
https://bbs.csdn.net/topics/40081562

DataCount = 271 7547


00:08.16秒 counts=1906240
//mCListDataFrame.AddHead(*pStFrame);
mCListDataFrame.AddHead(*pStFrame);
200102.MDS 88,752K

01:28.45秒 counts=19650000
//mCListDataFrame.AddHead(*pStFrame);
mCListDataFrame.AddTail(*pStFrame);
			counts ++;
			if (counts % 10000 == 0)
			{
				TRACE("CUnpacker_TTFrame::InputData counts=%d \n",counts);
			}
181214.MDS 1,118,643K

TRACE("CUnpacker_TTFrame::InputData counts=%d \n",counts);
// 添加打印会变慢很多

CList使用说明
// #include "stdafx.h"
// #include "test.h"
#include <afxtempl.h>
#include <iostream>
using namespace std;
class Point
{
public:
    Point()
    {
        m_x = 0;
        m_y = 0;
    }
    Point(int x, int y)
    {
        m_x = x;
        m_y = y;
    }
	bool operator==(const Point& src) const
    {
        return ( (m_x == src.m_x) && (m_y == src.m_y) );
    }
public:
    int m_x;
    int m_y;
};
typedef CList<Point, Point&>  CPntLst;
int main()
{
    CPntLst     lst;
    Point       point, elem1, elem2;
    elem1.m_x = 52;
    elem1.m_y = 102;
    elem2.m_x = 14;
    elem2.m_y = 1621;
	
    // add a element from tail, certainly, also can from head
    lst.AddTail(elem1);
    lst.AddTail(elem2);
    // print the point count
    cout<< "count: "<<lst.GetCount()<<endl;
    // traverse the whole list
    cout << "First time:\n";
    size_t index = 0;
    POSITION ps;
	
    for( ps = lst.GetHeadPosition();ps;lst.GetNext(ps) )
    {
		// extract the point according the current position
		point = lst.GetAt(ps);
		printf("index: %d, m_x = %d, m_y = %d\n", index++, point.m_x, point.m_y);
    }
    // search the point which is equal to elem1
    ps = lst.Find(elem1);
    point = lst.GetAt(ps);
    printf("elem1: m_x = %d, m_y = %d\n", point.m_x, point.m_y);
    Point elem3(123, 123123);
    // insert elem3 into the list after elem1
    lst.InsertAfter(ps, elem3);
    cout << "Second time:\n";
    for( ps = lst.GetHeadPosition();ps;lst.GetNext(ps) )
    {
		// extract the point according the current position
		point = lst.GetAt(ps);
		printf("index: %d, m_x = %d, m_y = %d\n", index++, point.m_x, point.m_y);
    }
    // remove elem1
    ps = lst.Find(elem1);
    lst.RemoveAt(ps);
    cout << "Third time:\n";
    for( ps = lst.GetHeadPosition();ps;lst.GetNext(ps) )
    {
		// extract the point according the current position
		point = lst.GetAt(ps);
		printf("index: %d, m_x = %d, m_y = %d\n", index++, point.m_x, point.m_y);
    }
    // remove all the rest
    lst.RemoveAll();
    cout << "Fourth time:\n";
    for( ps = lst.GetHeadPosition();ps;lst.GetNext(ps) )
    {
		// extract the point according the current position
		point = lst.GetAt(ps);
		printf("index: %d, m_x = %d, m_y = %d\n", index++, point.m_x, point.m_y);
    }
    return 0;
}
https://blog.csdn.net/liups/article/details/42567035


CList如何使用，用法举例
int main()
{

??? CPntLst???? lst;

??? Point?????? point, elem1, elem2;

??? elem1.m_x = 52;

??? elem1.m_y = 102;

??? elem2.m_x = 14;

??? elem2.m_y = 1621;

??? // add a element from tail, certainly, also can from head

??? lst.AddTail(elem1);

??? lst.AddTail(elem2);

// print the point count

cout<<"count: "<<lst.GetCount()<<endl;

// traverse the whole list

size_t index = 0;

for( POSITION ps = lst.GetHeadPosition();

???? ps;

??? lst.GetNext(ps) )

{??????

??? // extract the point according the current position

??? point = lst.GetAt(ps);

??? printf("index: %d, m_x = %d, m_y = %d\n", index++, point.m_x, point.m_y);

}

// search the point which is equal to elem1

ps = lst.Find(elem1);

point = lst.GetAt(ps);

printf("elem1: m_x = %d, m_y = %d\n", point.m_x, point.m_y);

Point elem3(123, 123123);

// insert elem3 into the list after elem1

lst.InsertAfter(ps, elem3);

// remove elem1

lst.RemoveAt(ps);

// remove all the rest

lst.RemoveAll();

return 0;

}
――――――――――――――――
版权声明：本文为CSDN博主「月光秦王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/yueguangbuxiu/article/details/7310466
https://blog.csdn.net/yueguangbuxiu/article/details/7310466


MFC中CList类使用注意
https://blog.csdn.net/ellor/article/details/1714736

CList的用法理解
6、链表的遍历
方式1：
POSITION pos = myList.GetHeadPostion();
while(pos != NULL)
{
CString? str = myList.GetNext(pos); //GetNext(pos),先返回pos位置的元素的值，再把pos指向当前位置的下一个。
}

方式2：
for(int i = 0 ; i < myList.GetCount(); i++)
{
CString str = myList.GetAt(myList.FindIndex(i));
}

总结：方式2，明显比方式1慢.方式1只需要执行N此就可以了，方式2，需要执行1+2+。。。+N = （1 + N）*N/2次

由于时间关系，写的也不是非常完整，需要这方面知识的，请多看MSDN帮助信息，祝你顺利~
最后还是请教一下大家，怎么把CList声明为const类型？欢迎留言~
――――――――――――――――
版权声明：本文为CSDN博主「曾经一片」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zengweicdut/article/details/8699402
https://blog.csdn.net/zengweicdut/article/details/8699402


00:08.16秒 counts=1906240
//mCListDataFrame.AddHead(*pStFrame);
mCListDataFrame.AddHead(*pStFrame);
200102.MDS 88,752K

00:07.57秒 counts=1906240
mCArrayItemDataFrame.Add(*pStFrame);
//mCListDataFrame.AddHead(*pStFrame);
200102.MDS 88,752K

01:25.02秒 counts=19592190
//mCListDataFrame.AddHead(*pStFrame);
mCListDataFrame.AddTail(*pStFrame);
181214.MDS 1,118,643K
------------
00:08.32秒 counts=1906240
//mCListDataFrame.AddHead(*pStFrame);
mCListDataFrame.AddTail(*pStFrame);
200102.MDS 88,752K

> 05:30秒 counts=1082351
//mCArrayItemDataFrame.Add(*pStFrame);
mCArrayItemDataFrame.Add(*pStFrame);
00:08.44秒
//mCListDataFrame.AddHead(*pStFrame);
mCListDataFrame.AddTail(*pStFrame);

00:07.75秒
mCArrayItemDataFrame.Add(*pStFrame);
//mCListDataFrame.AddHead(*pStFrame);
00:07.36秒
mCListDataFrame.AddHead(*pStFrame);
//mCListDataFrame.AddHead(*pStFrame);

00:07.52秒
//mCListDataFrame.AddHead(*pStFrame);
//mCListDataFrame.AddHead(*pStFrame);
00:01.59
//m_pUnpacker->InputData( (BYTE*)pPkgBuf, pkgSize ) ; 
200102.MDS 88,752K

------------------
02:10.97秒
mCArrayItemDataFrame.Add(*pStFrame);
//mCListDataFrame.AddHead(*pStFrame);
01:25.55秒
mCListDataFrame.AddHead(*pStFrame);
//mCListDataFrame.AddHead(*pStFrame);
01:24.96秒
//mCListDataFrame.AddHead(*pStFrame);
//mCListDataFrame.AddHead(*pStFrame);

00:09.19
//m_pUnpacker->InputData( (BYTE*)pPkgBuf, pkgSize ) ; 
181214.MDS 1,118,643K

00:07.52秒
//mCListDataFrame.AddHead(*pStFrame);
//mCListDataFrame.AddHead(*pStFrame);
00:01.59
//m_pUnpacker->InputData( (BYTE*)pPkgBuf, pkgSize ) ; 
200102.MDS 88,752K

2020.01.08 
---------------------------------------------------------------
C++：char、int占多少字节
x86

sizeof(char) ?1
sizeof(char*) ?4
sizeof(int) ?4
sizeof(int*) ?4
sizeof(double) ?8
sizeof(double*) ?4
sizeof(float) ?4
sizeof(float*) ?4
sizeof(string) ?28
sizeof(string*) ?4

x64

sizeof(char) ?1
sizeof(char*) ?8
sizeof(int) ?4
sizeof(int*) ?8
sizeof(double) ?8
sizeof(double*) ?8
sizeof(float) ?4
sizeof(float*) ?8
sizeof(string) ?40
sizeof(string*) ?8

指针只与系统有关，与类型无关
https://blog.csdn.net/ueh286/article/details/98210588

c++ int转char*
第一种方法：

int i=0;  
char itc[10];  
sprintf(itc,"%d.bmp",i);  


第二种方法：

int i=5;

char err_str[10];

_itoa(i, err_str, 10); //
https://blog.csdn.net/jacke121/article/details/80235064


在VC中,CSTRING类的用法形式多样,丰富多彩.但有时与传统数据类型之间的转换成为了很多人的难题.
下面我来简单介绍它们之间的关系.
1 如何实现cstring与char*之间的转换:

  CString   m_cstr="abc";   
  char*   m_char="def";   

  char*   lp=m_cstr.GetBuffer(m_cstr.GetLength());          
  m_cstr.ReleaseBuffer();   
    
     //相反的char* 转换成cstring
  m_cstr.Format("%s",lp);    // lp为数组指针


第二种：强制类型转换为   LPCTSTR   
  LPTSTR   p   =   m_cstr.GetBuffer(   10   );   
  strcpy(   Count,   p   );      
  m_cstr.ReleaseBuffer(   );   
  

2 .cstring 与BYTE之间的转换

BYET 为无符号字符型.原理与CHAR类似

CString m_cstr;
BYTE m_byte[100];
m_byte=(BYTE*)m_cstr.GetBuffer(m_cstr.GetLength());  //cstring转BYTE

同理:
m_cstr.format("%s",m_byte);   //BYTE字符串输出 

3 BYTE与CHAR类型之间的转换

strcpy,memcpy 函数皆可以强制转换

strcpy(m_char,(char*)m_byte);

strlen=(char*)m_byet;

memcpy(m_char,m_byte,strlen);

分类: visual c++
https://www.cnblogs.com/zhwl/archive/2012/11/27/2790601.html


CString转换 char[100] 
     
    char a[100]; 
    CString str("aaaaaa"); 
    strncpy(a,(LPCTSTR)str,sizeof(a));
https://www.xuebuyuan.com/3263371.html

Unhandled exception in MsEdit_Wendy.exe 0xCoooooo5:Access Violation. (x no)

C++字符数组初始化为空
char str[1024] = {0};

mfc中如何让listctrl生成行序号 [问题点数：40分，结帖人bshedu]
void CUserManger::List(CString sql)  //将SQL语句查询的结果显示在列表框中
{
	m_useradmin.DeleteAllItems(); 
	
	int nItem=0;
	char string[25];
	try
	{
		m_pRecordset.CreateInstance("ADODB.Recordset");
		m_pRecordset->Open((_variant_t)sql,_variant_t((IDispatch*)theApp.m_pConnection,true),adOpenStatic,adLockOptimistic,adCmdText);
		if(!m_pRecordset->adoEOF) //如果记录不为空
		{	
			while(!m_pRecordset->adoEOF)
			{	
				itoa(nItem,string,10);
				m_useradmin.InsertItem(nItem,string,0);
				m_useradmin.SetItemText(nItem,1,(LPCTSTR)(_bstr_t)m_pRecordset->GetCollect("AdminName"));
				m_useradmin.SetItemText(nItem,2,(LPCTSTR)(_bstr_t)m_pRecordset->GetCollect("权限"));
				m_useradmin.SetItemText(nItem,3,(LPCTSTR)(_bstr_t)m_pRecordset->GetCollect("创建时间"));
				nItem++;
				m_pRecordset->MoveNext();
			}
		}
		
		m_pRecordset->Close();
	}
	catch (_com_error e)
	{						
		CATCH_ERROR;
		return;
	}
	
}

	EnterCriticalSection(&m_cs);
	for( i=0; i<m_TTOptions->m_nDataTotal; i++ )
		m_arrItem.Add(m_TTOptions->m_pDataBuf[i]);
	LeaveCriticalSection( &m_cs );
https://bbs.csdn.net/topics/370128996


Strategy.h (options 1.0.0.57):	CArrayItem  m_arrItem;
TTOptions.h (options 1.0.0.57):typedef CArray<ItemOptions, ItemOptions&> CArrayItem;

---- : public CObject Matches (3 in 1 files) ----
Afxtempl.h (c:\users\wendy\desktop):class CArray : public CObject
Afxtempl.h (c:\users\wendy\desktop):class CList : public CObject
Afxtempl.h (c:\users\wendy\desktop):class CMap : public CObject
---- : public BASE_CLASS Matches (3 in 1 files) ----
Afxtempl.h (c:\users\wendy\desktop):class CTypedPtrArray : public BASE_CLASS
Afxtempl.h (c:\users\wendy\desktop):class _CTypedPtrList : public BASE_CLASS
Afxtempl.h (c:\users\wendy\desktop):class CTypedPtrMap : public BASE_CLASS


MFC中控件之CListCtrl的使用总结
m_ListCtrl.InsertColumn(0, _T("第0列"), LVCFMT_LEFT, 100);
m_ListCtrl.InsertColumn(1, _T("第1列"), LVCFMT_LEFT, 100);
m_ListCtrl.InsertColumn(2, _T("第2列"), LVCFMT_LEFT, 100);
m_ListCtrl.InsertItem(0, _T("第0行"), 3);//首行添加
m_ListCtrl.InsertItem(1, _T("第1行"), 4);//首行添加
m_ListCtrl.InsertItem(2, _T("第2行"), 5);//首行添加

6.添加几条数据向列表控件中：
for(int i = 0; i < 10; i++)
{
m_ListCtrl.InsertItem(i,"");
m_ListCtrl.SetItemText(i,0, "第一列");
m_ListCtrl.SetItemText(i,1, "第二列");
m_ListCtrl.SetItemText(i,2, "第三列");
}

10.获得列表的列数及行数：
    //得到列表的列数
    int nHeadNum = m_list.GetHeaderCtrl()->GetItemCount();
    //得到列表的行数
    m_list.GetItemCount();
https://blog.csdn.net/lovescjinbao/article/details/17691597

BOOL CShowData::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

	m_list_data.InsertColumn(0,"btGroupCode", LVCFMT_LEFT, 100);
	m_list_data.InsertColumn(1,"nLength", LVCFMT_LEFT, 70);
	m_list_data.InsertColumn(2,"lTime", LVCFMT_LEFT, 50);
	m_list_data.InsertColumn(3,"arItemCode", LVCFMT_LEFT, 90);
	m_list_data.InsertColumn(4,"btTransCode", LVCFMT_LEFT, 100);
	m_list_data.InsertColumn(5,"nTransDataLength", LVCFMT_LEFT, 150);
	m_list_data.InsertColumn(6,"pTransData", LVCFMT_LEFT, 90);
...}

#ifdef _DEBUG
void CWnd::AssertValid() const
{
	if (m_hWnd == NULL)
		return;     // null (unattached) windows are valid
...

		CObject* p;
		ASSERT((p = pMap->LookupPermanent(m_hWnd)) != NULL ||
			(p = pMap->LookupTemporary(m_hWnd)) != NULL);
		ASSERT((CWnd*)p == this);   // must be us
// Note: if either of the above asserts fire and you are
		// writing a multithreaded application, it is likely that
		// you have passed a C++ object from one thread to another
		// and have used that object in a way that was not intended.
		// (only simple inline wrapper functions should be used)
		//
		// In general, CWnd objects should be passed by HWND from
		// one thread to another.  The receiving thread can wrap
		// the HWND with a CWnd object by using CWnd::FromHandle.
		//
		// It is dangerous to pass C++ objects from one thread to
		// another, unless the objects are designed to be used in
		// such a manner.
..}
https://bbs.csdn.net/topics/50194470

复制粘贴乱码
电脑上为什么复制以后粘贴出来的都是乱码?
电脑上为什么复制以后粘贴出来的都是乱码：
在Windows 2000和Windows XP系统中，经常会在执行“复制”、“粘贴”操作时，粘贴到文本文件里的文字都是乱码，这实际是系统设置问题。解决该问题的方法操作如下几种：
1．在复制文字前用打开任意一种中文输入法，再执行“复制”→“粘贴”操作，这样就不会出现乱码问题了。
2．不使用操作系统自带的“文本编辑器”，如记事本。而是安装专门的EmEditor或UltraEdit文本编辑器，在里面选择“按ANSI方式粘贴”功能也可以。
3．最好解决方法是在系统中是把默认文字输入法设为中文状态下的英文输入法。如在“文字服务和输入语言”设置对话框中，通常会有英语和简体中文两种语言，英语下面有“英语（美国）”一类的项目，中文下面则有“简体中文输入法（美国）”、“微软拼音输入法”一类的项目。实际上，这个“简体中文输入法（美国）” 就是在中文状态下输入英文的，但是它与英语下面的“英语（美国）”又不同，后者是在英文状态下输入英文。只要你把要这个“简体中文输入法（美国）”设为默认输入法，以后右下角输入法上面总是显示“Ch”，而不是“En”，就不会出现粘贴乱码的情况了。如果你的电脑中找不到这一项，说明你没有安装，可通过系统安装盘进行安装。
https://zhidao.baidu.com/question/69533597.html

counts = 1906240

int counts = 0;
BOOL CUnpacker_TTFrame::InputData( BYTE* pBuf, int bufSize ) 
{...
		{//找到一帧
			//ATLTRACE("Find a frame .\n");
			unsigned char * buf=buff+sizeof(_tagTTDataFrame)+1; //for crc16
			counts ++;
...}

2020.01.07

(转)VC6调试技巧总结b
https://www.it610.com/article/5149622.htm

关于成员变量发生改变时的断点问题

Master::m_pDataSrc_TTFrameFile

CDataSrc_TTFrameFile::m_pProc

CUnpacker_TTFrame::pStFrame

vc++6.0断点调试
https://blog.csdn.net/zxq1138634642/article/details/8108983

一个在VC6中设置数据断点的问题，困扰我好久了 [问题点数：40分，结帖人Snailqiu]

vc++是否可设这样的断点，当变量值变化时中断？

vs中如何跟踪某个变量，一旦其值变化，立刻break

不能添加文件到目录(x no)

m_RecDataCount = 90853904 (10240)

Compiling...
MsEdit_WendyDlg.cpp
D:\Program Files\Microsoft Visual Studio\MyProjects\MsEdit_Wendy\MsEdit_WendyDlg.cpp(17) : error C2146: syntax error : missing ';' before identifier 'g_Master'
D:\Program Files\Microsoft Visual Studio\MyProjects\MsEdit_Wendy\MsEdit_WendyDlg.cpp(17) : error C2501: 'Master' : missing storage-class or type specifiers
D:\Program Files\Microsoft Visual Studio\MyProjects\MsEdit_Wendy\MsEdit_WendyDlg.cpp(17) : fatal error C1004: unexpected end of file found
Generating Code...
Compiling...
Master.cpp
Generating Code...
执行 cl.exe 时出错.
Creating browse info file...
BSCMAKE: error BK1506 : cannot open file '.\Debug\MsEdit_WendyDlg.sbr': No such file or directory
执行 bscmake.exe 时出错.
MsEdit_Wendy.exe - 1 error(s), 0 warning(s)(v ok)
#include "Master.h"


为CListBox加上智能水平滚动条
https://blog.csdn.net/i_like_cpp/article/details/196513


 C++  > MFC自动水平滚动条CListBox
https://download.csdn.net/download/ayang1986/9586701

为CListBox垂直滚动条，自动滚动，文字显示不全问题！
https://blog.csdn.net/u012307430/article/details/51556941

//#define IDD_MSEDIT_WENDY_DIALOG         102
#define IDD_READMDS                     102
enum { IDD = IDD_READMDS };  // IDD_MSEDIT_WENDY_DIALOG
更改对话框资源ID名称后，不能双击按钮添加响应函数(v ok)

2020.01.06 

struct _tagTTDataFrame{
	int nLength;
	time_t lTime;
	BYTE btGroupCode;
	char arItemCode[8];
	BYTE btTransCode;
	int nTransDataLength;
	void * pTransData;
};

2020-01-03 13:45:11(102004014), ==========================Start==========================
2020-01-03 13:45:13(102005777), Groupmng.dll load fail!
2020-01-03 13:45:22(102014825), Item:002      TransCode:E  Delay:10  Time:0-0
2020-01-03 13:45:23(102015824), open E:\200102\200102.MDS OK
2020-01-03 13:45:28(102020597), finish read E:\200102\200102.MDS
2020-01-03 13:45:28(102020597), finish ttframe files
2020-01-03 13:45:28(102020597), Frame-'E' total='0'
2020-01-03 13:45:28(102020597), EndThread DataSrc_TTFrameFile.
2020-01-03 13:45:28(102020691), ProcTTFrame-InputData finished.
2020-01-03 13:45:28(102020691), EndThread ProcTTFrame.
2020-01-03 13:45:28(102020691), ===========================End===========================


请问.des文件怎么打开
.des文件出现表示已经加密了。如果你自己没有设定密码，那么就是它自动生成密钥了。
DES是安全性比较高的一种算法,目前只有一种方法可以破解该算法,那就是穷举法。
你要先知道如果des使用的是多少位的密钥，如果是56位的密钥，则可能的密钥数量是2的56次方个。然后下载强行破解软件，因为攻击des的主要形式被称为蛮力的或彻底密钥搜索，即重复尝试各种密钥直到有一个符合为止。就我所知，应该都是收费的并且很难搞懂的黑客软件。
我觉得希望不大……真的。
https://zhidao.baidu.com/question/118378997.html

如何打开后缀为.DES格式文件？
我的图片用加密精灵加密解密过后，JPG格式后缀加了一个.des请问如何才能恢复我原来的JPG格式
PHOTOSHOP打不开的！
各种方法都试过了！都没用！
该问题我已经解决了！主要是加密软件未注册，我花了38元购买了软件重新定义为安全加密后，重新解密就可以了！所以这些不知名的加密软件不了解还是最好不要用！
这个要解密了才能打开的。你用加密精灵解开就行了。
https://zhidao.baidu.com/question/121075317.html

VC6.0 不能断点调试的解决方法 VC6.0没有debug模式
调试旧程序，VC6.0环境
1.VC6.0没有debug模式
Build->Configurations->Add
2.VC6.0不能断点调试  转载地址：http://blog.csdn.net/bin_zh123/article/details/5733459
现象是用 debug中的 step info或者run to cursor合着设置断点会出现One or morebreakpoints cannot be set and have been disabled.   Execution will stopat the beginning of the program.解决方法，
1.在project->setting->c/c++-general->debug info->program databse for edit and continue ;
2.edit->breakpoints->removeall;
3.build->set active project configuration->*.exe win32 debug.
经过以上三步，ok!
另一篇:
一、两种调试方式：
1、Debug模式：
2、Release模式: (v ok)
单击菜单[Project]->[Settings…],出现"Project Settings"对话框，选择“Release”状态；
将C/C++标签中的Category选择General,Optimizations选Disable (Debug),Debug info选Program Database；
在Link标签中选中Generate debug info复选框。
注：Release模式稍好点，因为某些情况程序只能在Release下运行，如“显示对话框的DLL”在Debug下显示出窗口后 就死在那里。
二、调试中可能的错误：“不能调试”、“断点错误”。
1、“不能调试”：
“One or more breakpoints cannot be set and have been disabled. Execution will stop at the beginning of the program.”
2、“断点错误”：
"One or more breakpoints are not positioned on valid lines.These breakpoints have been moved to the next valid line."
注意：“不能调试”跟“断点错误”不是一回事，“断点错误”会禁用某些错误断点，但“不能调试”则会禁用所有断点。
三、解决方法
1、对于“断点错误”，VC会自动帮我们定位到一行，我们不用理会！
2、对于“不能调试”，解决步骤如下：
1)、重起电脑
2)、把工程拷贝到新目录，删除ncb, .opt,.plg文件。 注意是拷贝，不是剪切。
3)、再菜单栏(menu)：Build->Rebuild All。
https://blog.csdn.net/hjk216/article/details/53422540


MsEdit.dsp
SOURCE=.\BrokersTrace.cpp
# End Source File
# Begin Source File


vc6.0不能在工程里面添加文件
win7的系统，装了vc6.0。不能在工程中添加文件，已经按照了FileTool控件了，添加文件的时候会提示unable to add file to the active project。
本人菜鸟，希望大神帮帮忙啊帮帮忙，感激不尽！
用记事本打开.dsp文件，看看里面是否已有要添加的文件，将其删除重新添加就OK了。我的就是这样给解决了。
https://zhidao.baidu.com/question/1605878237145018307.html

Unpacker_TTFrame.cpp
e:\msedit\msedit\datadef.h(1056) : warning C4183: 'Init': member function definition looks like a ctor, but name does not match enclosing class
e:\msedit\msedit\datadef.h(1088) : warning C4183: 'Init': member function definition looks like a ctor, but name does not match enclosing class
e:\msedit\msedit\mylistener.h(167) : error C2143: syntax error : missing ';' before '*'
e:\msedit\msedit\mylistener.h(167) : error C2501: 'DbEnv' : missing storage-class or type specifiers
e:\msedit\msedit\mylistener.h(167) : error C2501: 'm_pdbEnv' : missing storage-class or type specifiers
e:\msedit\msedit\mylistener.h(168) : error C2143: syntax error : missing ';' before '*'
e:\msedit\msedit\mylistener.h(168) : error C2501: 'Db' : missing storage-class or type specifiers
e:\msedit\msedit\mylistener.h(168) : error C2501: 'm_pdb' : missing storage-class or type specifiers
e:\msedit\msedit\filesync.h(16) : fatal error C1083: Cannot open include file: 'C:\\db-4.8.30\\build_windows\\db_cxx.h': No such file or directory
Generating Code...



MFC编译错误之cannot open file '.\Debug\xxxDlg.sbr': No such file or directory


原创linwx2010 发布于2015-06-30 09:57:53 阅读数 3133  收藏
展开

最近做个MFC小程序，今天在添加了一个自定义函数后出现了一个编译错误：

Creating browse info file...
BSCMAKE:error BK1506 : cannot open file '.\Debug\COMTOOLDlg.sbr':No such file or directory
Error executing bscmake.exe.



删除Debug文件夹，重新编译项目不能解决问题。
上网搜索解决办法：


1、删除 .ncb .opt文件，删除删除Debug文件夹，重新打开项目，Rebuild All，问题解决。




2、取消Build Browser Info file

方法：Project-->Settings-->Browser Info-->取消Build Browser Info file
――――――――――――――――
版权声明：本文为CSDN博主「linwx2010」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/linwx2010/article/details/46691879
https://blog.csdn.net/linwx2010/article/details/46691879


source insight 和 vc6 工作代码区显示的中文复制到记事本或UltraEdit中显示乱码(x no)
https://zhidao.baidu.com/question/69533597.html (v ok)

		case 'e':   //andy add 2014.01.28 'e'′úì?'t'
			HandleFrame_e(buff,Len);
			break;

每天"新英细姐"
分主次急缓
2020.01.03

Astyle编程语言格式化工具的中文说明
http://blog.chinaunix.net/uid-20662363-id-1904145.html

代码风格格式化--Astyle
https://winddoing.github.io/post/62371.html

如何在source insight中使用astyle的代码整理功能
https://zhidao.baidu.com/question/2142157796077477988.html?qbl=relate_question_2&word=sourceinsight%20Astyle%20%B8%F1%CA%BD%BB%AF%BE%D6%B2%BF%B4%FA%C2%EB

source insight代码格式化（Astyle）(v ok)
https://blog.csdn.net/wzk456/article/details/24302975

vc++ 6.0 怎么格式化代码？(v ok)
你是想让代码自动排版吧
选中代码或者全选代码，按"Alt+F8"就可以了
https://zhidao.baidu.com/question/452298511.html

Source Insight 批量注释 多行注释宏
https://blog.csdn.net/darennet/article/details/8495551 (v ok)

source insight中注释_取注快捷键设置方法
source insight中注释_取注快捷键设置方法：（使用//注释）
??? 1、打开Source Insight4.0，点击Project->Open Project->打开base项目->打开Base下的utils.em文件；相对路径如下：
./Source Insight 4.0/Projects/Base/utils.em
??? 2、在文件utils.em末尾添加下面代码,然后在source insight中点击Options->Key Assignments（键值分配）为Macro:MultiLineComment分配快捷键，比如Alt+/；或者点击Options->Menu Assignments（菜单分配）为Macro:MultiLineComment分配菜单按钮
――――――――――――――――
版权声明：本文为CSDN博主「WenKang_00」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_31701279/article/details/78511614
https://blog.csdn.net/qq_31701279/article/details/78511614 (v ok)

win7系统中pdf文件怎么打开(v ok)
方法二、
直接将pdf格式文件拖到浏览器图标上面，放开鼠标你就会惊奇的发现PDF文件打开了!
福昕pdf阅读器
https://www.win7qjb.com/jiaocheng/42279.html

获取系统运行进程信息――PSAPI介绍使用 .(v ok)

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <psapi.h>
 
#pragma comment (lib, "Psapi.lib")
// To ensure correct resolution of symbols, add Psapi.lib to TARGETLIBS
// and compile with -DPSAPI_VERSION=1
 
int PrintModules( DWORD processID )
{
	HMODULE hMods[1024];
	HANDLE hProcess;
	DWORD cbNeeded;
	unsigned int i;
 
	// Print the process identifier.
 
	printf( "\nProcess ID: %u\n", processID );
 
	// Get a handle to the process.
 
	hProcess = OpenProcess( PROCESS_QUERY_INFORMATION |
		PROCESS_VM_READ,
		FALSE, processID );
	if (NULL == hProcess)
		return 1;
 
	// Get a list of all the modules in this process.
 
	if( EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded))
	{
		for ( i = 0; i < (cbNeeded / sizeof(HMODULE)); i++ )
		{
			TCHAR szModName[MAX_PATH];
 
			// Get the full path to the module's file.
 
			if ( GetModuleFileNameEx( hProcess, hMods[i], szModName,
				sizeof(szModName) / sizeof(TCHAR)))
			{
				// Print the module name and handle value.
 
				_tprintf( TEXT("\t%s (0x%08X)\n"), szModName, hMods[i] );
			}
		}
	}
 
	// Release the handle to the process.
 
	CloseHandle( hProcess );
 
	return 0;
}
 
int main( void )
{
 
	DWORD aProcesses[1024]; 
	DWORD cbNeeded; 
	DWORD cProcesses;
	unsigned int i;
 
	// Get the list of process identifiers.
 
	if ( !EnumProcesses( aProcesses, sizeof(aProcesses), &cbNeeded ) )
		return 1;
 
	// Calculate how many process identifiers were returned.
 
	cProcesses = cbNeeded / sizeof(DWORD);
 
	// Print the names of the modules for each process.
 
	for ( i = 0; i < cProcesses; i++ )
	{
		PrintModules( aProcesses[i] );
	}
 
	return 0;
}


https://blog.csdn.net/fanpeii/article/details/8107527

GetProcessImageFileName GetProcessImageFileNameA 

psapi.h 头文件psapi.dll 下载 (v ok)
psapi.lib复制到vc++6.0的lib目录下（如：C:\Program Files\Microsoft Visual Studio\VC98\Lib），psapi.h复制到Include目录下（如：C:\Program Files\Microsoft Visual Studio\VC98\Include）便可使用，psapi.dll一般在system32目录下会自带，所以可以不做操作

获取当前所有进程的完整路径
https://blog.csdn.net/u014417619/article/details/52797855?utm_source=blogxgwz4

遍历进程,获取当前进程下进程的路径.(获得全路径)
https://blog.csdn.net/hgreminem/article/details/4305084

MFC中获取进程名、PID及进程所在路径
https://blog.csdn.net/hgreminem/article/details/4305084

MFC获得指定进程的ID，路径及终止进程
https://blog.csdn.net/lebao82/article/details/17142789

C++ 获取进程所在目录（全路径）

获取windows下任务管理器中的进程列表
#include "stdafx.h"

//int main(int argc, char* argv[])
//{
//	printf("Hello World!\n");
//	return 0;
//}

#include <iostream>
#include <Windows.h>
#include <Tlhelp32.h>
using namespace std;
 
int main(int argc, char** argv)
{
    HANDLE hProcessSnp = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(NULL == hProcessSnp)
    {
        return -1;
    }
    
    /* 列举第一个进程 */
    PROCESSENTRY32 pe32 = {0};
    pe32.dwSize = sizeof(pe32);
    BOOL bResult = Process32First(hProcessSnp, &pe32);
    while(bResult)
    {
        cout << pe32.szExeFile << endl;
        bResult = Process32Next(hProcessSnp, &pe32);
    }
    CloseHandle(hProcessSnp);
    
    getchar();
    return 0;
}
https://blog.csdn.net/c1520006273/article/details/50542052 (v ok)


求VC++6.0中注释多行代码的快捷键组合!!!!!!!!! [问题点数：5分，结帖人aqbeyond]
https://bbs.csdn.net/topics/70072414 (v ok)

VC++6.0中设置注释多行代码的快捷键组合(v ok)
https://blog.csdn.net/zz460833359/article/details/48348431

为Visual C++ 6.0添加批量注释和取消批量注释功能
首先在Visual C++ 6.0的安装目录下“Microsoft Visual Studio\Common\MSDev98\Macros”中新建一个txt文件，复制如下代码到文件中：然后把文件保存为Comment.dsm，注意文件后缀为dsm，文件类型也要更改。
打开VC6.0，Tools-Customize
打开Add-ins and Macro Files标签页，在下面勾上刚刚新建的文件名Comment，如果没有，点击下面的Browse找到自己保存的文件。
打开Commands标签页，下拉Category找到Macros，右边会出现CancelSelNote和SetSelNote，分别代表取消注释和添加注释的功能。
用左键选中CancelSelNote或SetSelNote不放，把它们拖动到工具栏上，然后放手，会弹出下面的对话框，让你给这个功能选择一个图标，可以随意选择，然后确定即可。
注意：

当你用【取消注释】这个功能时，它会删除选中行的前两个字符。。。

　　正常情况下，删除的是每一行前面“//”这两个字符，但是，有时候，你选中多行时，如果其中有1行是不带注释的，那么，它也会删除这行的前两个字符。自己可以慢慢试一下，就清楚了。

　　所以，在使用【 取消注释 】功能时，要慎用。
――――――――――――――――
版权声明：本文为CSDN博主「qlexcel」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qlexcel/article/details/86709679
https://blog.csdn.net/qlexcel/article/details/86709679 (v ok)

VC6.0快捷键 与 Visual Assist X 快捷键(转载)
https://blog.csdn.net/weixin_30432007/article/details/96790356

VS 和Visual Assist X快捷键
https://blog.csdn.net/xueying_/article/details/7679042

MultiByteToWideChar和WideCharToMultiByte用法详解
void main()
{
    char sBuf[25]={0};

    strcpy(sBuf, "我最棒");

    //获取输入缓存大小
    int sBufSize=strlen(sBuf);
    //获取输出缓存大小
    //VC++ 默认使用ANSI，故取第一个参数为CP_ACP
    DWORD dBufSize=MultiByteToWideChar(CP_ACP, 0, sBuf, sBufSize, NULL, 0);
    printf("需要wchar_t%u个\n", dBufSize);

    wchar_t * dBuf=new wchar_t[dBufSize];
    wmemset(dBuf, 0, dBufSize);

    //进行转换
    int nRet=MultiByteToWideChar(CP_ACP, 0, sBuf, sBufSize, dBuf, dBufSize);
    
    if(nRet<=0)
    {
        cout<<"转换失败"<<endl;
        DWORD dwErr=GetLastError();
        switch(dwErr)
        {
        case ERROR_INSUFFICIENT_BUFFER:
            printf("ERROR_INSUFFICIENT_BUFFER\n");
            break;
        case ERROR_INVALID_FLAGS:
            printf("ERROR_INVALID_FLAGS\n");
            break;
        case ERROR_INVALID_PARAMETER:
            printf("ERROR_INVALID_PARAMETER\n");
            break;
        case ERROR_NO_UNICODE_TRANSLATION:
            printf("ERROR_NO_UNICODE_TRANSLATION\n");
            break;
        }
    }
    else
    {
        cout<<"转换成功"<<endl;
        cout<<dBuf; 
    }

    delete(dBuf);
}
https://www.cnblogs.com/ranjiewen/p/5770639.html

Window获取所有运行的进程
https://blog.csdn.net/oshirdey/article/details/29407467

Windows编程 - 遍历所有进程(exe) 代码(C++)
https://blog.csdn.net/caroline_wendy/article/details/29381987

【转】Windows下如何枚举所有进程（含代码）
https://blog.csdn.net/zdragon2002/article/details/3690925

急！获取windows中所有正在运行的应用程序信息 [问题点数：20分，结帖人liaoyilin_2001]
https://bbs.csdn.net/topics/310054898

C语言编写获取当前系统所有正在运行的应用程序
EnumProcesses函数枚举进程。
https://ask.csdn.net/questions/201936

获取当前正在运行的应用程序

查看正在打开的应用程序或目录

最近打开的目录或程序

Windows 三种开机自启动的设置方式（全面）
https://blog.csdn.net/lee008108/article/details/78713385

Windows设置自己的程序开机自动启动
https://blog.csdn.net/lwpkjio/article/details/85129507

开机自动打开最近的目录或程序

vc打开文件和打开文件所在目录
https://blog.csdn.net/mail_cm/article/details/7248359

cmd一次性打开多个应用程序
https://blog.csdn.net/xufeng0991/article/details/41309603

批处理一键打开多个应用程序
@echo off
echo Starting PLSQL...
start "" "D:\YLZ\PLSQL Developer 12正式版64位+中文语言包+注册码\plsqldev.exe"
echo Starting sublime...
start "" "D:\QuickStart\sublime"
echo Starting youdao...
start "" "D:\QuickStart\youdao"
echo Starting idea...
start "" "D:\tools\quickStart\idea"
echo Starting mongo...
start "" "D:\tools\quickStart\mongo"
echo Starting navicat...
start "" "D:\tools\quickStart\navicat"
echo Starting SecureCRT...
start "" "D:\tools\quickStart\SecureCRT"
echo Starting xmind...
start "" "E:\desktop\wzh\xxx\xxx.xmind"
echo Starting alwaysup...
start "" "D:\tools\quickStart\alwaysup"
https://blog.csdn.net/qq_31748587/article/details/84138742

win7如何删除开始菜单最近打开文档记录听语音
https://jingyan.baidu.com/article/67508eb4974d3edcca1ce488.html

Win7系统中如何查看最近打开过的文档项目？
右键点击Win7系统的开始按钮，选择属性按钮点击。点击属性按钮后，进入属性界面。
在属性界面点击自定义按钮，进入自定义菜单，在自定义菜单上勾选“最近使用的项目”，然后点击确定按钮。
在开始菜单点击最近使用的项目图标，显示最近打开过的文件。
需要查看最近打开过的所有项目，右键点击最近打开项目的图标。
C:\Users\Wendy\AppData\Roaming\Microsoft\Windows\Recent
https://jingyan.baidu.com/article/67508eb4974d3edcca1ce488.html

查找最近打开的目录或程序

如何查看和删除电脑的各种使用历史记录
四.查看资源管理器地址栏快速打开记录
查看方法：点击地址栏右侧的向下箭头
这里写图片描述
删除方法： 
1.按下 Windows + R ， 输入并执行 regedit ， 打开注册表编辑器 
2.按以下路径展开： HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\TypedPaths 
3.Windows 资源管理器地址栏历史记录会列在以上注册表路径下，不需要的路径删除掉即可。
https://blog.csdn.net/bruce135lee/article/details/79675259

C:\Windows\Prefetch

记录打开的程序或目录

查看电脑使用记录（包括打开过的文件）
C:\Windows\Tasks\SCHEDLGU.TXT
C:\Users\Wendy\Recent Nothings
6、电脑日志记录
开始/控制面板/性能和维护(经典视图里去掉这个)/管理工具/事件查看器，看看里面的记录，或者有比较简单的方法就是在开始里\设置\控制面板\管理工具\事件查看器。这样也能查看
7、查看文档记录
开始→我最近的文档，点开这里就可以查看最近都写了什么文档，看了什么电影、图片。
https://blog.csdn.net/bruce135lee/article/details/79674898

2020.01.02

ATL窗口实现
https://download.csdn.net/download/clever101/4359848

mfc在对话框中创建单文档问题

COM003.Simple.1

com组件对话框

COM组件中显示对话框的资源
https://download.csdn.net/download/yangshusen55/2508773?utm_source=bbsseo

MFC编程 CButton::Create
第四个参数，表示按钮的大小和位置。
CRect(x1,y1,x2,y2)
x1和y1表示按钮左上角坐标
x2和y2表示按钮右下角坐标
所以x2必须大于x1，y2必须大于y1；
你的x都设成了100，按钮的宽度为0了，当然不显示了。
明白了不。
https://zhidao.baidu.com/question/127558261.html

	CRect rect1 ;
	GetClientRect( rect1 ) ;

	//m_pwndBgn->MoveWindow( rect1 ) ;
	//m_pwndBgn->GetClientRect( rect1 ) ;

	CRect rectbtn( rect1 ) ;
	rectbtn.left++ ;  //左上角X位置
	rectbtn.top++ ;   //左上角Y位置
	rectbtn.right  = rectbtn.left+120 ; //右下角 X 位置 // wendy 80
	rectbtn.bottom = rectbtn.top+20 ;  //右下角 Y 位置

	m_pbtnItemCode->Create( "", WS_CHILD|WS_VISIBLE, rectbtn, m_pwndBgn, MACRO_BtnItemCodeID ) ;  // wendy rectbtn rect


m_pbtnItemCode->Create( "", WS_CHILD|WS_VISIBLE, rect, m_pwndBgn, MACRO_BtnItemCodeID ) ;
	ON_BN_CLICKED(MACRO_BtnItemCodeID, OnSelectItemCode)

	CRect rectbtn( rect ) ;
	rectbtn.left++ ;  //左上角X位置
	rectbtn.top++ ;   //左上角Y位置
	rectbtn.right  = rectbtn.left+40 ; //右下角 X 位置 // wendy 80
	rectbtn.bottom = rectbtn.top+20 ;  //右下角 Y 位置
	//m_pbtnItemCode->MoveWindow( rectbtn ) ;//设置位置大小
	int nPreX = rectbtn.right ;	

D:\VC6_SOFT\vc6cn\VC6CN\COMMON\MSDEV98\BIN 覆盖

暂时跳过 直接编辑资源文件改为MS Sans Serif即可 (v ok)

VC6 IDE字体设置增强补丁
DEVSHL.DLL 6.00.8168.2

VC6.0经典字体 Fixedsys字体 MS Sans Serif

D:\Program Files\Microsoft Visual Studio\Common\MSDev98\Bin\MSDEV.EXE属性
VC6产品版本: 6.00.8168.2 (v ok)

vc中如何更改对话框的字体属性
https://jingyan.baidu.com/article/e8cdb32b5a698f37052bad29.html

转载：修改VC++6.0对话框资源字体及大小（不修改源码）
3、打开工程目录下的rcTest.rc文件
搜索“IDD_ABOUTBOX DIALOG DISCARDABLE”，可以看到
CAPTION "关于 rcTest"
FONT 9, "宋体"
https://blog.csdn.net/MOLLY0511/article/details/81062011

vc6 选择对话字体
select dialog font

VC里面大家都喜欢用什么字体？ [问题点数：40分，结帖人HelloDan]
Fixedsys, system ,Arial
Courier New or Courier 是标准答案
https://bbs.csdn.net/topics/320099237

VC++6.0使用非默认字体
近期在使用vc++6.0写C程序
问题：vc++自带的字体不太好看
解决办法：修改注册表
1. win+r 运行 regedit 调出注册表编辑器
进入到目录 HKEY_CURRENT_USER\SOFTWARE\Microsoft\DevStudio\6.0\Format
2.在Format上右键导出


https://blog.csdn.net/qq_21808961/article/details/78191167

VC6.0修改字体（非系统自带的5种字体）
在VC6.0下更改字体，我们一般通过菜单-Tools-Options-Format来更改
但在我的win7 64位系统下这一选项下的字体和字体颜色是空的，无法选择
所以我想起来通过注册表来更改。
Win+R输入“Regedit”，找到“HKEY_CURRENT_USER/Software/Microsoft/DevStudio/6.0”
发现下面没有Format，这也是为什么VC环境中找不到字体的原因，注册表里面都没有该信息
在6.0上右键New-Key（项（K）），给它重命名为“Format”
这里我只要更改编辑源文件窗口和输出窗口的字体
所以在“Format”下面再新建两个New-Key：“Output Window”和“Source Window”，“Workspace Window”
单击“Output Window”后在右侧显示详情区右键New-String Value，命名为“FontFace”
再右键“FontFace”Modify...为“Courier New”
https://blog.csdn.net/pk124729136/article/details/16339609

VC6 IDE字体设置增强补丁 评分:     
适用于版本号6.0.9782.0的devshl.dll。对应MSDEV.EXE版本号为6.0.9782.2
参考moring#pediy的帖子做个一个补丁。
复制到
C:\Program Files\Microsoft Visual Studio\Common\MSDev98\Bin
覆盖同名原文件(DEVSHL.DLL)即可，然后你可以在VC6的字体设置中选择更多的字体。

引用来自：
VC6 IDE字体设置增强
by morning

VC6只枚举系统缺省字符集一致的字体,这导致选择字体时甚为不便.虽然说可以通过修改注册表,直接设置字体,但是总觉得有些遗憾,今天有点时间,就小小patch了
https://download.csdn.net/download/lonmaor/5108632

VC++6.0字体设置工具（完美版）
https://download.csdn.net/download/xd20065401417/3270033

VC6字体列表不全和默认字体修改的补丁
https://download.csdn.net/download/networkdragon/1764649
https://download.csdn.net/download/limotao2011/4909644
https://download.csdn.net/download/u010436145/6595767
VC6 IDE字体设置增强补丁
https://download.csdn.net/download/lonmaor/5108632
手动修改注册表来添加vc6.0的字体
https://download.csdn.net/download/zhouzijian588/4705970

设置VC++6.0字体，非自带字体，可改为任何字体

运行regedit（注册表编辑器），打开 HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format为了方便编写，我们先导出Format，然后修改成下面的样子，只需要改FontFace （字体名称） 这里写你想改成的字体名称
FontSize（字体大小） 0000000a = 10 （学过16进制的我想应该都知道）
设置VC++6.0字体，非自带字体，可改为任何字体
Windows Registry Editor Version 5.00
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format]
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format\Calls Window]
"FontFace"="Courier New"
"FontSize"=dword:0000000a
"Text"=hex:00,00,00,00,ff,ff,ff,00,13,01,b3,00
"Text Selection"=hex:ff,ff,ff,00,00,00,00,00,19,00,19,00
"Calls Highlight"=hex:00,00,00,00,00,ff,00,00,10,00,10,00
"Superceded code"=hex:80,80,80,00,ff,ff,ff,00,10,00,10,00
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format\Disassembly Window]
"FontFace"="Courier New"
"FontSize"=dword:0000000a
"Text"=hex:00,00,00,00,ff,ff,ff,00,13,01,b3,00
"Text Selection"=hex:ff,ff,ff,00,00,00,00,00,19,00,19,00
"Assembly Code"=hex:80,80,80,00,ff,ff,ff,00,10,00,10,00
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format\Memory Window]
"FontFace"="Courier New"
"FontSize"=dword:0000000a
"Text"=hex:00,00,00,00,ff,ff,ff,00,13,01,b3,00
"Text Selection"=hex:ff,ff,ff,00,00,00,00,00,19,00,19,00
"Memory Highlight"=hex:ff,00,00,00,ff,ff,ff,00,10,00,10,00
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format\Output Window]
"FontFace"="Courier New"
"FontSize"=dword:0000000a
"文本"=hex:00,00,00,00,ff,ff,ff,00,15,00,15,00
"文本选择"=hex:ff,ff,ff,00,00,00,00,00,19,00,19,00
"当前错误/标记"=hex:ff,ff,ff,00,00,00,80,00,55,00,55,00
"书签"=hex:00,00,00,00,00,ff,ff,00,10,00,10,00
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format\Registers Window]
"FontFace"="Courier New"
"FontSize"=dword:0000000a
"Text"=hex:00,00,00,00,ff,ff,ff,00,13,01,b3,00
"Text Selection"=hex:ff,ff,ff,00,00,00,00,00,19,00,19,00
"Value Highlight"=hex:ff,00,00,00,ff,ff,ff,00,10,00,10,00
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format\Source Browser]
"FontFace"="Courier New"
"FontSize"=dword:0000000a
"文本"=hex:00,00,00,00,ff,ff,ff,00,15,00,15,00
"文本选择"=hex:ff,ff,ff,00,00,00,00,00,19,00,19,00
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format\Source Window]
"FontFace"="Courier New"
"FontSize"=dword:0000000a
"文本"=hex:00,00,00,00,ff,ff,ff,00,13,01,b3,00
"文本选择"=hex:ff,ff,ff,00,00,00,00,00,19,00,19,00
"当前错误/标记"=hex:ff,ff,ff,00,00,00,80,00,d2,01,b2,01
"书签"=hex:00,00,00,00,00,ff,ff,00,10,00,10,00
"断点"=hex:ff,ff,ff,00,80,00,00,00,10,00,10,00
"当前声明"=hex:00,00,00,00,ff,ff,00,00,70,00,70,00
"选择边距"=hex:d4,d0,c8,00,d4,d0,c8,00,13,00,13,00
"关键字"=hex:00,00,ff,00,ff,ff,ff,00,10,00,11,00
"注释"=hex:00,80,00,00,ff,ff,ff,00,10,00,11,00
"Number"=hex:00,00,00,00,ff,ff,ff,00,11,00,11,00
"String"=hex:00,00,00,00,ff,ff,ff,00,11,00,11,00
"操作员"=hex:00,00,00,00,ff,ff,ff,00,11,00,11,00
"Wizard IDL/ODL Code"=hex:80,80,80,00,ff,ff,ff,00,14,00,15,00
"HTML Element Name"=hex:80,00,80,00,ff,ff,ff,00,14,00,15,00
"HTML Attribute Name"=hex:ff,00,00,00,ff,ff,ff,00,14,00,15,00
"HTML Attribute Value"=hex:00,00,ff,00,ff,ff,ff,00,14,00,15,00
"HTML Comment"=hex:00,80,00,00,ff,ff,ff,00,14,00,15,00
"HTML Entity"=hex:ff,00,00,00,ff,ff,ff,00,14,00,15,00
"HTML Tag Delimiter"=hex:00,00,ff,00,ff,ff,ff,00,14,00,15,00
"HTML String"=hex:00,00,ff,00,ff,ff,ff,00,14,00,15,00
"HTML Tag Text"=hex:ff,00,ff,00,ff,ff,ff,00,14,00,15,00
"HTML Operator"=hex:00,00,ff,00,ff,ff,ff,00,14,00,15,00
"HTML Server-Side Script"=hex:00,00,00,00,ff,ff,00,00,14,00,14,00
"User Defined Keywords"=hex:00,00,ff,00,ff,ff,ff,00,14,00,15,00
"Wizard Code"=hex:80,80,80,00,ff,ff,ff,00,14,00,15,00
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format\Variables Window]
"FontFace"="Courier New"
"FontSize"=dword:0000000a
"Text"=hex:00,00,00,00,ff,ff,ff,00,13,01,b3,00
"Text Selection"=hex:ff,ff,ff,00,00,00,00,00,19,00,19,00
"Variables Highlight"=hex:ff,00,00,00,ff,ff,ff,00,10,00,10,00
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format\Watch Window]
"FontFace"="Courier New"
"FontSize"=dword:0000000a
"Text"=hex:00,00,00,00,ff,ff,ff,00,13,01,b3,00
"Text Selection"=hex:ff,ff,ff,00,00,00,00,00,19,00,19,00
"Watch Highlight"=hex:ff,00,00,00,ff,ff,ff,00,10,00,10,00
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format\Workspace Window]
"FontFace"="Courier New"
"FontSize"=dword:0000000a
4
重新打开VC++6.0，是不是变的比较美观了
https://jingyan.baidu.com/article/90808022f9bedcfd91c80f20.html

?方法一: 1、解压文件,双击MS Sans Serif.fon文件; 2、放到【C:\Windows\Fonts】路径; 3、打开可以切换字体的软件,如Word、笔记本等,即可使用。
?方法二: 1、在本页直接下载这款字体,对下载好的字体压缩包进行解压处理; 2、直接双击运行字体文件,打开之后点击上方的安装按钮; 3、等待字体安装完毕,打开Word找到该字体即可使用。
MS Sans Serif.fon 如何安装字体 百度

IDD_FORMVIEW_ItemList DIALOGEX 0, 0, 225, 316
STYLE WS_CHILD
EXSTYLE WS_EX_NOPARENTNOTIFY
FONT 8, "MS Sans Serif", 0, 0, 0x1

IDD_FORMVIEW_ItemList DIALOG DISCARDABLE  0, 0, 187, 96
STYLE WS_CHILD
FONT 10, "System"
BEGIN
    CONTROL         "List1",IDC_LIST_Item,"SysListView32",LVS_REPORT | 
                    LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_SORTASCENDING | 
                    WS_BORDER | WS_TABSTOP,7,7,173,82
END

2019.12.31

一步搞定Beyond Compare文件乱码(v ok)
方法一：进行会话设置（仅用于本次会话）

步骤一打开文本比较会话界面，在“会话”菜单下选择“会话设置”选项卡；

步骤二切换到“格式”页面，在左侧编码重写和右侧编码覆盖选择 GB2312/UTF-8/GBK，选择完毕后，单击确定关闭窗口，完成设置。
方法二：文件格式（永久配置）

步骤一打开文本比较会话界面，在“工具”菜单下选择“文件格式”选项；

步骤二打开文件格式对话框转换窗口，在该窗口下面的编码选项里设置编码方式，然后点击保存即可。

http://www.sohu.com/a/117100747_200939

#define new DEBUG_NEW

使用方式：

在stdafx.h中包含头文件

在要用诊断机制的文件中加入如下的代码。
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

这样不管是new申请的内存泄漏，还是malloc申请的内存泄漏在程序正常退出后都会输出在Debug窗口里。而且都会显示完整文件路径、行数、泄漏字节数。

https://www.cnblogs.com/lisuyun/p/5744548.html


C++中析构函数为虚函数
1、析构函数是否定义为虚函数的区别

（1）析构函数定义为虚函数时：基类指针可以指向派生类的对象（多态性），如果删除该指针delete []p；就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。

（2）析构函数不定义为虚函数时：编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。

5、基类析构函数定义为虚函数的情况

        如果不需要基类对派生类及对象进行操作,则不能定义虚函数,因为这样会增加内存开销.当类里面有定义虚函数的时候,编译器会给类添加一个虚函数表,里面来存放虚函数指针,这样就会增加类的存储空间。所以,只有当一个类被用来作为基类的时候,并且有使用到基类指针操作派生类的情况时，才把析构函数写成虚函数。

https://blog.csdn.net/King_weng/article/details/89263215


为什么构造函数不能声明为虚函数？

1.创建一个对象必须明确指出它的类型，否则无法创建，一个对象创建成功编译器获得它的实际类型，然后去调用对应的函数，而如果构造函数声明为虚函数，会形成一个死锁，虚函数是在运行才能确定确定其调用哪一个类型的函数，而具体哪一个类型是编译器通过对象的类型去确定的，但是此时对象还未创建也就没法知道其真实类型。

2.虚函数对应一张虚函数表，这个虚函数表是存储在对象的内存空间的，如果构造函数是虚函数就需要通过虚函数表来调用，可是对象还没有实例化，也就是内存空间还没有，找不到虚函数表，所以构造函数是不能声明为虚函数的。

https://www.cnblogs.com/wuyepeng/p/9882289.html


股票价格估值DPS
投融界为你提供股票价格估值DPS相关报道、相关新闻、相关动态，如果你想要了解股票价格估值DPS找项目，股票价格估值DPS相关资金项目介绍，就上投融界！这里拥有海量的投资融资项目合作信息,是专业的融资服务平台。
https://www.trjcn.com/tags/1569295/

EPS
每股收益即每股盈利（EPS），又称每股税后利润、每股盈余，指税后利润与股本总数的比率。
https://baike.baidu.com/item/%E6%AF%8F%E8%82%A1%E6%94%B6%E7%9B%8A/2429458?fromtitle=EPS&fromid=10928288&fr=aladdin

GetOEMCP(v ok)
VB声明
Declare Function GetOEMCP Lib "kernel32" Alias "GetOEMCP" () As Long
说明
判断在OEM和ANSI字符集间转换的windows代码页
返回值
Long，目前处于活动状态的OEM代码页的标识符。针对一种特定的语言，可能存在多个代码页。以下是可用代码页列表
437
默认：美国
708-720
阿拉伯代码页
737
希腊
775
波罗的
850
国际
852
Slavic
855
西里尔语
857
土耳其语
860
葡萄牙语
861
冰岛语
862
希伯来语
863
加拿大法语
864
阿拉伯语
865
挪威/丹麦语
866
俄语
874
泰语
932
日语
936
中文（简体）
949
朝鲜语
950
中文（台、港繁体）
1361
朝鲜语
http://www.office-cn.net/t/api/getoemcp.htm

VC如何创建没有基类的类(v ok)
很简单。
点Class View在最上面的***.classes上面点右键选New Class，
然后在Class type里选generic class，这样你新建的类就没基类了。
https://zhidao.baidu.com/question/127700748.html


IGPEditor_hwdDoc.cpp(59) : error C2079: 'c_file' uses undefined struct '_finddata_t'(v ok)
#include <io.h>

上传时间：2017-02-20 所需积分/C币： 
这个有点不明白了，你下架就下架吧，扣分的理由是什么呢？
这是2017年上传的,现在2019年底来扣我100分呀？

我只是修改个下载所需积分就要重新审核了？
积分里有反动内容还是有违犯法律条例的东西在里面了呢？呵呵。


舍本求末;本末倒置

这个问题必须从根本上加以解决，头痛医头，脚痛医脚，总不是个办法。
正本清源
https://www.cidianwang.com/cy/t/toutongyitoujiaotongyijiao363.htm

很遗憾，你上传的VC6功能完整版本安装后有插入ATL对象菜单项 没有通过审核，已被删除,原因是：资源违规，如有疑问，请联系webmaster@csdn.net
前几天上传的资源通过了审核,昨晚就仅仅是修改个下载所需积分从免费改为1分。然后就审核不通过了，这是怎么回事呢？

你上传的资源没有通过审核vc6.0 免安装 绿色版 兼容win7 vc助手1小时前
很遗憾，你上传的vc6.0 免安装 绿色版 兼容win7 vc助手 没有通过审核，已被删除,原因是：资源违规，如有疑问，请联系webmaster@csdn.net
之前一直好好的资源，也是只修改个下载所需积分就不能通过审核了。这太不合理了吧。
上一封 下一封


vc++ 整型 最大值
	if (ntimes >= INT_MAX) ntimes = 0;
https://zhidao.baidu.com/question/383761125.html

windows API 第八篇 _tcsicmp _stricmp _wcsicmp _mbsicmp
wchar_t szStr1[] = "asdfg";
wchar_t szStr2[] = "AsDfG";
int nResult = _wcsicmp(szStr1, szStr2);      //nResult = 0
https://blog.csdn.net/weixin_34202952/article/details/93466664

#include <string.h>
_tcsicmp

strcmp|wcscmp 与 stricmp|wcsicmp
区分大小写：

1、strcmp

????? 这是用于ANSI标准字符串的函数(如string和char *)，此函数接受两个字符串缓冲区做为参数，如果两个字符串是相同的则返回零。否则若第一个传入的字符串的值大于第二个字符串返回值将会大于零，若传入的第一个字符串的值小于第二个字符串返回值将小于零。


char *ch="test";
if(strcmp(ch,"TeSt")==0)
{
    //字符串相等
}
else
{
    //字符串不相等
}
?
2、wcscmp

????? 这个函数是strcmp所对应的Unicode系列的函数，它的使用方法和strcmp相同，它用来比较两个Unicode字符串是否相等(如wstring和wchar_t *)。


wchar_t *ch=L"NewString";
if(wcscmp(ch,L"newstring")==0)
{
    //字符串相等
}
else
{
    //字符串不相等
}

不区分大小写：

1、stricmp

????? 这是用于ANSI标准字符串的函数(如string和char *)，此函数接受两个字符串缓冲区做为参数，如果两个字符串是相同的则返回零，不区分大小写。否则若第一个传入的字符串的值大于第二个字符串返回值将会大于零，若传入的第一个字符串的值小于第二个字符串返回值将小于零。


char *ch="AbcD";
if(stricmp(ch,"aBCd")==0)
{
    //字符串相等
}
else
{
    //字符串不相等
}

2、wcsicmp
????? 这个函数是stricmp所对应的Unicode系列的函数，它的使用方法和stricmp相同，它用来比较两个Unicode字符串是否相等，不区分大小写(如wstring和wchar_t *)。

wchar_t *ch=L"AbcD";
if(wcsicmp(ch,L"aBCd")==0)
{
    //字符串相等
}
else
{
    //字符串不相等
}

――――――――――――――――
版权声明：本文为CSDN博主「hellokandy」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/hellokandy/article/details/52161852

区分大小写
这个函数是strcmp所对应的Unicode系列的函数，它的使用方法和strcmp相同，它用来比较两个Unicode字符串是否相等(如wstring和wchar_t *)。
wchar_t *ch=L"NewString";
if(wcscmp(ch,L"newstring")==0)
{
    //字符串相等
}
else
{
    //字符串不相等
}


不区分大小写
这个函数是stricmp所对应的Unicode系列的函数，它的使用方法和stricmp相同，它用来比较两个Unicode字符串是否相等，不区分大小写(如wstring和wchar_t *)。
wchar_t *ch=L"AbcD";
if(wcsicmp(ch,L"aBCd")==0)
{
    //字符串相等
}
else
{
    //字符串不相等
}


https://blog.csdn.net/hellokandy/article/details/52161852?utm_source=blogxgwz8

windows API 第八篇 _tcsicmp _stricmp _wcsicmp _mbsicmp
https://blog.csdn.net/weixin_33946605/article/details/93257253

常用的字符串处理函数和宏
http://www.cppblog.com/xyjzsh/archive/2010/10/15/130044.html

MIDL示例
cpp_quote：指导MIDL编译器将限定了的字符串转换成生成的头文件。具体来说，这四行会在MIDL编译器生成的头文件中做出C++的注释。
https://www.xuebuyuan.com/1194141.html

cpp_quote

2019.12.30

CTTOptions::CTTOptions() 
{

	CLogout("CTTOptions::CTTOptions() b \r\n");
...
	m_pwndBgn = new CwndBgn() ;
	ASSERT( m_pwndBgn!=NULL ) ;
...}

LRESULT CTTOptions::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	// TODO : Add Code for message handler. Call DefWindowProc if necessary.
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	RECT rect ;
	CLogout("CTTOptions::OnCreate() b \r\n");
	m_pwndBgn->Create( CwndBgn::m_strMyClass, NULL, WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN , rect, CWnd::FromHandle(m_hWnd), NULL ) ;
...}

wndBgn.cpp
CwndBgn::~CwndBgn()
{
}
BEGIN_MESSAGE_MAP(CwndBgn, CWnd)
	//{{AFX_MSG_MAP(CwndBgn)
	ON_WM_PAINT()
	ON_WM_CTLCOLOR()
	//}}AFX_MSG_MAP
	ON_BN_CLICKED(MACRO_BtnItemCodeID, OnSelectItemCode)


void CwndBgn::OnSelectItemCode() 
{
	if( m_pOwner!=NULL )
	{
		m_pOwner->m_bSelectWin = 0;
		m_pOwner->OnSelectItemCode() ;
	}

}

新视图->期权->左上角按钮单击响应的函数如下:
[17:01:16.653]:CTTOptions::OnSelectItemCode()  
void CTTOptions::OnSelectItemCode()
{
	CLogout("CTTOptions::OnSelectItemCode()  \r\n");
...}



listctrlOptions.cpp
UINT ColorThread(LPVOID  lParam)  //检查字体颜色的线程函数
{
	//CoInitializeEx(NULL,COINIT_MULTITHREADED);
	ClistctrlOptions * pclass;
	pclass=(ClistctrlOptions *)lParam;
	int iCount = 0;
	int iCount2 = 0;
	while (pclass->m_bStopColorThread == FALSE)
	{
		Sleep(50);
		iCount++;
		iCount2++;
		if(iCount >= 20) //1秒判断一次
...}

BIN为后缀名的文件是什么文件啊
.bin是二进制文件，其用途依系统或应用而定
bin有多种含义，包括虚拟光驱格式.bin，用于科研计算的数据格式为bin格式。另外，FTP 在传送文件时分为ASC 和 Bin 两种格式，只有文字文件 (例如 html 文件) 使用 ASC，其他的通通使用 Bin 格式 (例如图像文件、压缩文件、可执行文件等等)。 
一般来说，常见的虚拟光驱格式。建议你使用WINISO。WinISO是一款功能强大的镜像文件处理工具，它可以从CD-ROM中创建ISO镜像文件，或将其他格式的镜像文件转换为标准的ISO格式，还可以轻松实现镜像文件的添加、删除、重命名、提取文件等操作。 
PC上常见的bin如果很大的多半是光盘镜像，1.44M左右的可能是软盘镜像。小于1M的可能是主板BIOS的程序。
嵌入式开发里面交叉编译出来通常是个bin，烧到板子去用的。
一切的bin都能用16进制编辑器打开
https://iask.sina.com.cn/b/iR1ayX5UMLKf.html


HRESULT CTTOptions::WriteLogFile(LPTSTR strLog)
{

	CLogout("CTTOptions::WriteLogFile()  \r\n");

	char strTime[100];
	SYSTEMTIME sysTime;
	GetLocalTime(&sysTime);

	HANDLE m_hLogFile;
	char strFileDir[200];
	char strTemp[50];
	sprintf(strTemp,"\\W2TOptionsIV-%04d%02d%02d.LOG",sysTime.wYear,sysTime.wMonth,sysTime.wDay);
...}

/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Nov 24 11:34:50 1999
 */
/* Compiler settings for C:\MWTT\MAS\MAS.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/

printf(" TEST_printf() \r\n");v
ATLTRACE("TEST_ATLTRACE() \r\n");
TRACE( "TEST_TRACE()\r\n" ) ;


删除文件 - G:\Tele-Trend\system\desktop\_g_charting.dsk
删除文件 - G:\Tele-Trend\system\desktop\_g_pf_aud.dsk
删除文件 - G:\Tele-Trend\system\desktop\_g_pf_white.dsk
删除文件 - G:\Tele-Trend\system\desktop\_g_pf_{aud}.dsk
删除文件 - G:\Tele-Trend\system\desktop\_g_pf_{white}.dsk
找不到 G:\Tele-Trend\HISTORYDATA\*.his
[13:44:44.751]:CTTOptions::GetExpiryTime()
[13:44:44.757]:CTTOptions::GetExpiryDays()

printf("%s", szMsg);

ATLTRACE("OnMySetItemsTotal \r\n");

TRACE( "tool_Icon create faile!\r\n" ) ;

logfile.h
// Debug版本宏1
#define _FLAG_OUTLOG_ENABLE TRUE // wendy add

D:\Program Files\Microsoft Visual Studio\MyProjects\CallOptions\Debug

#import "G:\Tele-Trend\bin\Options.dll" no_namespace (v ok)

void CCallOptionsDlg::OnButton1() 
{
	CoInitialize(NULL);
	
	CLSID clsid;
	
	HRESULT hr ;
	// Looks up a CLSID in the registry, given a ProgID.
	hr = CLSIDFromProgID(OLESTR("Options.TTOptions.1"),&clsid);
	
	if(S_OK !=hr )
		return;

	ITTObject* pInterf = NULL; //Interface Pointer 
	
	hr = CoCreateInstance(clsid,
		NULL,
		CLSCTX_INPROC_SERVER,
		__uuidof(ITTObject),
		(LPVOID*)&pInterf);
	
	if(pInterf->InitObject() != S_OK)  // 2708
	{
			printf("no do InitObject");
	}
	else
	{
			printf("ok do InitObject");
	}

	if(pInterf->Activate(1) != S_OK)  // 2708
	{
			printf("no do InitObject");
	}
	else
	{
			printf("ok do InitObject");
	}

	VARIANT var;
	var.vt = 13;
	VARIANT *pVar = &var;
	if(pInterf->GetByID(1021,&pVar) != S_OK)  // 2708
	{
			printf("no do GetByID");
	}
	else
	{
			printf("ok do GetByID");
	}


	CoUninitialize();
}

G:\Tele-Trend\bin\w2t.exe
G:\Tele-Trend\bin\

2019.12.27

WINCORE.CPP  894

CTTOptions::CTTOptions() 
{
	m_nColorMode = 2;  //颜色  0白色   1黑色   2彩色//wendy test
...}



ItemOptions* m_pDataBuf ;	//
CTTOptions* m_TTOptions;

	theta = theta/(365.0*conversionRatio) ;	// paul, 2008-4-30
											// ben 2017.6.29   252改为365

	double rho  =  ( bCallOption==TRUE ) ? 
						X*T_t*pow( MathE, -1.0*r*T_t )*N_d2/conversionRatio :
						-1.0*X*T_t*pow( MathE, -1.0*r*T_t )*( 1.0 - N_d2 )/conversionRatio ;


// ben 2017.6.29   252改为365
//cove	add 2019.07.08
//andy add 2003.02.13 for future always display first month
2002.07.11 create
char* CTTOptions::MakeFutCode( char* pEchoItemCode, char* pTitleCode, int nMM, int nYY )
{

	m_bUseNtMth = FALSE;

	//andy add 2003.02.13 for future always display first month
	memset(pEchoItemCode,' ',G_GENCODELEN);
...}


ClearData(); //ResetTable();  andy modify 20090507

int CStrategy::DrawIncomeLine() 5千 10309 - 4941 = 5368行画图代码

void CStrategy::OnMouseMove(UINT nFlags, CPoint point) 
{
	if( m_bMode==1 )
		return;
	CRect frmrect;
	m_frame.GetWindowRect(&frmrect);
	ScreenToClient(&frmrect);	
	int nCount = m_arrPL[0].GetSize();
	CRect rct(frmrect.left,frmrect.top+35,frmrect.right,frmrect.bottom-40);
	if( rct.PtInRect(point) && m_nRetn==1 && nCount!=0 && m_bDrawing==FALSE )
	{
		if( (m_bSelectLo || m_bSelectUp) && m_btMouseGet==1 && m_btMouseRelease==0 )
		{
			m_hCursor = LoadCursor(NULL,IDC_CROSS);
		}
		else
			m_hCursor = LoadCursor(NULL,IDC_ARROW);
		m_point = point;
		m_bPainted = FALSE;
		DrawIncomeLine();
	}
...}

option （期权） 编辑 讨论
Option中文译为期权，又称为选择权，是在期货的基础上产生的一种衍生性金融工具。
从其本质上讲，期权实质上是在金融领域中将权利和义务分开进行定价，使得权利的受让人在规定时间内对于是否进行交易，行使其权利，而义务方必须履行。在期权的交易时，购买期权的一方称作买方，而出售期权的一方则叫做卖方；买方即是权利的受让人，而卖方则是必须履行买方行使权利的义务人。
https://baike.baidu.com/item/option/1171193?fr=aladdin
期权具“零和游戏”特性，而个股期权及指数期权皆可组合，进行套利交易或避险交易。
期权主要可分为买方期权（Call Option）和卖方期权（Put Option），前者也称为看涨期权或认购期权，后者也称为看空期权或认沽期权

Options.TTOptions.1
492E31D3-B80D-11D3-AF24-00A0CC23E698
492E31C6-B80D-11D3-AF24-00A0CC23E698
492E31D4-B80D-11D3-AF24-00A0CC23E698

\CallOptionsDlg.cpp(221) : error C2787: 'ITTOptions' : no GUID has been associated with this object

CallOptionsDlg.cpp(179) : error C2065: 'IFirstInterface' : undeclared identifier
interface ITTOptions : IDispatch (v ok)

CallOptionsDlg.cpp(201) : error C2059: syntax error : '{'
CLSID clsid;
clsid = {0x492E31D3,0xB80D,0x11D3,{0xAF,0x24,0x00,0xA0,0xCC,0x23,0xE6,0x98}};
CLSID clsid = {0x492E31D3,0xB80D,0x11D3,{0xAF,0x24,0x00,0xA0,0xCC,0x23,0xE6,0x98}}; (v ok)

IDD_STRATEGY

电脑右下角显示星期，选中日期右键调整日期/时间-更改日期和时间...更改日历设置-区域和语言-格式 
日期和时间格式 其它设置...自定义格式 yyyy/M/d dddd (v ok)

492E31D3-B80D-11D3-AF24-00A0CC23E698 - ITTOptions

太极软件-新视窗-期权(v ok)

工程-设置-连接-输出文件名 (v ok)

CoInitialize

需要为控件工具栏按钮ID_GROUP_ADDITEM增加响应函数才会显示图标(v ok)

Microsoft Office 2013安装与激活
https://blog.csdn.net/qq_37798548/article/details/95317354


32位win7系统安装office2013以及破解
https://blog.csdn.net/willie_chen/article/details/49683303?utm_source=blogxgwz9
Microsoft Toolkit.exe
打开之后这个界面，这个界面不要动。看到左上角Main了么?单击右边的Activation。
大家来到这个界面第一件事是点击Install。完成后!
最重要的一步：点击右边绿色的EZ-Activator。大功告成。快去看吧~是不是破解成功了。


D:\Program Files\Microsoft Visual Studio\VC98\MFC\SRC\VIEWCORE.CPP
BOOL CView::OnSplitCmd(UINT) F5->F10调试进去.

MainFrm.cpp(126) : error C2664: 'CreateEx' : cannot convert parameter 1 from 'const int' to 'class CWnd *'
#define this                            32772 导致

手动修改文件和VC6加菜单资源两种方式.(v ok)
手动
Resource.h IGPEditor_hwd.rc 
#define ID_ADDMENU_TEST                 32771
MENUITEM "addmenu_test",                ID_ADDMENU_TEST
    POPUP "编辑(&E)"
    BEGIN
        // wendy del MENUITEM "撤消(&U)\tCtrl+Z",            ID_EDIT_UNDO
        // wendy del MENUITEM SEPARATOR
        // wendy del MENUITEM "剪切(&T)\tCtrl+X",            ID_EDIT_CUT

VC6
ResourceView Menu 选中菜单右击属性(分隔符或弹出)填写ID和字符 或按键盘Delete键删除菜单




D:\Program Files\Microsoft Visual Studio\MyProjects\IGPEditor_hwd\MainFrm.cpp(116) : error C2611: '~' : illegal following '~' (expected identifier)
D:\Program Files\Microsoft Visual Studio\MyProjects\IGPEditor_hwd\MainFrm.cpp(116) : error C2588: '::~CMainFrame' : illegal global destructor
52936(HZ-GB2312简体中文)会出错 no

[图]捷利资讯执行董事陈玉炯
https://finance.qq.com/a/20100423/007002.htm

// wendy b
// wendy e

Beyond Compare乱码问题这样就能解决(v ok)  
00936 (ANSI/OEM - 简体中文 GBK) ok
20936 (简体中文 GB2312) ok
54936 (GB18030 简体中文) ok
52936(HZ-GB2312简体中文)会出错 no
65001(UTF-8) or UTF-8 会出错 no
文本比较乱码
当使用Beyond Compare软件比较文本文件时，明明在项目里面是对的，可是用Beyond Compare 打开之后就会出现乱码，内容完全错误。
解决方法：
步骤一：在已经打开的Beyond Compare文本比较会话中，单击工具栏“会话”按钮，在展开的菜单中选择“会话设置”选项，并切换到“格式”选项卡页面。
步骤二：在界面“左边编码重写”和“右边编码覆盖”栏目中选择 GB2312/UTF-8/GBK，当然这个也可以根据自己喜好和文本自身的encode选择。
步骤三：单击“确定”按钮完成比较文本的编码设置，再次回到文本比较会话即可进行正常的文本比较工作。
https://blog.csdn.net/weixin_34198453/article/details/91910432
转载于:https://my.oschina.net/navicat/blog/707700
可以关注相关的Beyond Compare教程 http://www.beyondcompare.cc/support.html


了解TSCI - Thermotec Sistemas de Combust?o Industrial的最新动态

tele-trend  添加释义
网络释义

  环球快车
...应用标题 东方(香港)环球快车(Tele-Trend) 应用描述 东方(香港)环球快车iOS版是东方证券(香港)有限公司全新打造的一款国际化、专业化的iOS证券交易终端，提供最及时的沪深...
基于8个网页-相关网页
  港股快车
金(香港)港股快(Tele-Trend)应用说明 金C券(香港)有限公司之金(香港)港股快，橛籼峁└加方便和全面的Y料及Y服眨投Y者不管身在何都可以...
基于4个网页-相关网页
短语
Tele-Trend Limited 捷利资讯有限公司 ; 香港捷利信息有限公司
http://dict.youdao.com/w/tele-trend/


VC6 关键字蓝色如何改
https://zhidao.baidu.com/question/503043114.html
vc ++6.0中程序关键字不变蓝色，全部都是黑色的。程序可以正常运行。上面说的改format的方法没用。
你说的是一个叫visual assisx X 插件的功能,VC6自己是不会变蓝的.(v ok)


CSplitterWnd类分割MFC单文档应用程序窗口
https://blog.csdn.net/m_buddy/article/details/50803102

F5运行，重试自由定位到问题点上。(v ok)
D:\Program Files\Microsoft Visual Studio\VC98\MFC\SRC\VIEWFORM.CPP
#ifdef _DEBUG
	// dialog template must exist and be invisible with WS_CHILD set
	if (!_AfxCheckDialogTemplate(m_lpszTemplateName, TRUE))
	{
		ASSERT(FALSE);          // invalid dialog template name
		PostNcDestroy();        // cleanup if Create fails too soon
		return FALSE;
	}
#endif //_DEBUG

viewform.cpp , line 69 
原因是 CFormView 的导出类，需要与一个Dialog资源关联，这个Dialog的属性必须是ws_child，Style必须选 “下层”SystemMenu和TitleBar属性最好都设为False
参见 http://www.cnweblog.com/vcbird/archive/2005/10/10/36404.html
https://blog.csdn.net/u011514451/article/details/49174797

注：还有一种方法就是在添加Dialog资源时，在Dialog列表上点右键->添加资源，
选择Dialog->IDD_FORMVIEW,再点“新建”按钮，这样新建出来的Dialog属性就会自动配好了
http://www.cnweblog.com/vcbird/archive/2005/10/10/36404.html
如何导入对话框资源从一个项目到另一个项目使用 Visual C++.NET 或 Visual C
http://blog.sina.com.cn/s/blog_b646fbcf0102w7it.html

viewform.cpp 69
是AfxCheckDialogTemplate这个验证失败，CFormView类关联的对话框资源必须具有Child属性，(v ok)
打开你用来和CFormView关联的对话框属性页面，在Style里面选择Child再试试。
http://blog.sina.com.cn/s/blog_6a5aef5e0102uztp.html

Beyond Compare 修改保存提示: This file contains Unicode characters that will be lost if it is saved using
the current encodeing. 编码选改为UTF-8保存即可(v ok)

任务栏按钮:当任务栏被占满时合并(v ok)

通过比对修改后用unicode格式保存VC6会显示读取二进制文件出错。
用utraedit32打开后另存为格式为ansi/ascii(DOS)后可正常读取.(v ok)

win7 activation(win7激活工具) v2.6 绿色版 (v ok)
http://www.downcc.com/soft/5435.html
此windows副本不是正版怎么解决

Uedit32.zip
https://download.csdn.net/download/messeager5/10232684

source Insight3.0
https://download.csdn.net/download/ccm163/4194046

c6.0 免安装 绿色版 兼容win7 vc助手
https://download.csdn.net/download/hixi2007/9758584

beyond compare3 序列号
sl2T62PGJWHyemKxBS0+G94HyBMAN+qAvdqWlYaw1hN3VkAtOdqDYsDkmi9451fK9567RIt8sb85UwjEm5vb2tJzJXE6YVapYW7f+tRRXRFI4yn4NjjZ0RiiqGRCTVzwComUcXB-eiFWRBY6JpSsCNkmIxL5KsRCo442djHhTZE+
――――――――――――――――
版权声明：本文为CSDN博主「dlfgh」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/sinat_29891353/article/details/88994831

BCompare-zh-3.3.8.16340
https://download.csdn.net/download/jiejieforupdate/7440599

首页- 应用软件- 文件管理 - Beyond Compare3绿色破解版下载
https://www.newasp.net/soft/15746.html

oem7 编辑
Oem7是一款易用的windows7激活工具，采用一键式激活，人性化设计，所有激活软件中激活率最高。使用Oem7windows7激活软件windows7后是永久激活,和正版一样,可以自动更新,可以通过微软正版验证 [1]  。
https://baike.baidu.com/item/oem7/10013435?fr=aladdin

用电脑管家中的软件管理找到编程软件"Microsoft .NET Framework 4.6.1" 单独安装 (v ok)

net framework 4安装未成功，原因是hresult 0x80240037 是怎么回事啊
https://zhidao.baidu.com/question/814177706745454532.html


Windows 7安装.net framework 4 安装
https://blog.csdn.net/kingepoch/article/details/8817936

注册表,
HKEY_LOCAL_MACHINE\SOFWARE\Microsoft\Internet Explorer下
MAIN子键的权限问题,改成"允许完全控制"
https://zhidao.baidu.com/question/379292948.html?sort=11&rn=5&pn=0#wgt-answers

https://blog.csdn.net/gtatcs/article/details/8769787
.net framework 4.0 0xc8000247错误解决

SoftwareDistribution

Microsoft .NET Framework 4: [2] Error code -2145124297 for this component is not recognized.

安装visual studio 2010到framework 4总是失败
https://zhidao.baidu.com/question/569005009.html

安装visual studio 2010到framework 4总是失败
这是截图

错误日志在下面
[07/08/13,14:29:54] setup.exe: [2] ISetupComponent::Pre/Post/Install() failed in ISetupManager::InternalInstallManager() with HRESULT -2147467259.***EndOfSession***[07/08/13,15:14:45] Microsoft .NET Framework 4: [2] Error code -939523550 for this component is not recognized.[07/08/13,15:14:45] Microsoft .NET Framework 4: [2] Component Microsoft .NET Framework 4 returned an unexpected value.[07/08/13,15:14:46] VS70pgui: [2] DepCheck indicates Microsoft .NET Framework 4 is not installed.[07/08/13,15:14:46] VS70pgui: [2] DepCheck indicates Microsoft .NET Framework 4 简体中文语言包 was not attempted to be installed.
对了我单独安装framework 4的时候也失败了，出现HRESULT 0xc8000222错误代码

 我来答 分享 举报 浏览 4714 次
2个回答 #活动# 请回答2019，答题瓜分百万现金
lt8799  
推荐于2018-03-13
翻译：主要原因是windows update的临时文件损坏 建议重命名该文件夹
步骤 1.开始----- 运行------- cmd ----- 键入net stop WuAuServ回车（停止windows update服务）
2.开始----- 运行----键入%windir%回车（打开系统目录）
3.将SoftwareDistribution文件夹重命名为SDold
4.开始----- 运行------- cmd ----- 键入net start WuAuServ回车
5.可以正常安装.net了
 19     评论(2) 分享 举报

leiyangbdwk  
2013-07-11
有很多人遇到过你那个错误，我本人也遇到过，而且根据如下的办法也解决了。
安装不了的原因很有可能是你的操作系统是Ghost版本的。
http://wenku.baidu.com/view/484102e16294dd88d0d26b99.html
另外，如果你遇到其他问题，请把你的错误号百度一下，没准就可以搜到解决办法。

C#

域服务器windows 2008 Server, IP 10.10.1.2
把Win7无法加入域的电脑DNS配置成10.10.1.2，即可。
https://zhidao.baidu.com/question/405352662.html


win7下怎么配置ODBC数据源
我的系统是win7旗舰版的，找了半天也没有找到控制面板中的额管理工具--数据源，后来上网查了之后发现win7不是这样打开ODBC数据源管理器的，打开ODBC数据源管理器的方法是在cmd命令框中输入odbcad32之后会打开管理器。

1.Win+R-àodbcad32

2.点‘添加’

3.测试

之后的步骤都和XP下相同了。

也可以在桌面最下方右键---属性---开始菜单---自定义---系统管理工具---在“所有程序”菜单和【开始】菜单上显示，然后在开始中就可以看到管理工具了。之后使用方法和XP中相同。
――――――――――――――――
版权声明：本文为CSDN博主「gukesdo」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/gukesdo/article/details/6873445
https://blog.csdn.net/gukesdo/article/details/6873445