面试了一个 46 岁的程序员，我思绪万千!
https://mp.weixin.qq.com/s/ibYJld1_uHPjXivM5iTqSw

https://www.sqlite.org/2013/sqlite-amalgamation-3071700.zip
查看复制链接地址得出以上地址，即可直接下载成功(v ok)
https://www.sqlite.org/snapshot/sqlite-snapshot-202003260029.tar.gz
https://www.sqlite.org/2020/sqlite-amalgamation-3310100.zip

如何在网站 https://www.sqlite.org/download.html 上找sqlite-amalgamation-3071700版本的
sqlite3.c, sqlite3.h (x no)


sqlite-amalgamation-3_7_17

/ Check-in [af8057ef]Login
Home Timeline Files
https://www.sqlite.org/src/info/af8057ef5dcaa72d
Comment:	Update the sessions branch to the latest 3.7.17 beta.
Downloads:	Tarball | ZIP archive | SQL archive
Timelines:	family | ancestors | descendants | both | sessions
Files:	files | file ages | folders
SHA1:	af8057ef5dcaa72dc0d2ab5d1553b06757449fa1
User & Date:	drh on 2013-05-17 10:58:08
Other Links:	branch diff | manifest | tags


** version 3.7.13.  By combining all the individual C code files into this 
Downloads  2012-06-11 (3.7.13)
** version 3.7.17.  By combining all the individual C code files into this 
RadarAlert

Release History
2013-05-20 (3.7.17)

History Of SQLite Releases
https://www.sqlite.org/chronology.html

Date	Version 
2020-01-27	3.31.1
2020-01-22	3.31.0
2019-10-11	3.30.1
2019-10-10	3.30.1
2019-10-04	3.30.0
...

Windows下通过VC6编译SQLite源代码
https://www.cnblogs.com/braver/articles/2621202.html
1.下载SQLite源代码。
http://www.sqlite.org/sqlite-amalgamation-3071300.zip
2.创建Win32 Dll Library工程，在工程中加入sqlite3.c, sqlite3.h, sqlite3.def。（sqlite3.def加入工程的Resource Files中）

如何使用VC6编译sqlite3源码生成动态链接库(版本：sqlite-source-3_6_23_1)
https://blog.csdn.net/littletigerat/article/details/5502491
四．将文件添加进工程
将sqlite-source-3_6_22里的文件添加到sqlite3工程中：

1.将sqlite-source-3_6_22下的所有*.C文件添加在工程的Source File中

2.将sqlite-source-3_6_22下的所有*.h文件添加在工程的Header File中

注意：不要将tclsqlite.c源文件添加进工程中；

五．文件说明：
1. tclsqlite.c用于生成基于TCL的API，如果需要编译，则需要另外下载tcl.h头文件；

2. shell.c用于生成命令行模式的sqlite.exe；

3. fts3*.c是全文索引的模块；

4. rTree.c是建立数据库R树索引的模块；



数据库 如何在VC6下使用sqlite3
https://www.cnblogs.com/vipwtl/p/5916925.html
到http://www.sqlite.org/download.html下载：
解压后得到sqlite3.h，得到的其他文件这里不会用到
下载第二个，解压后得到sqlite3.dll和sqlite3.def
下面要做的是：利用sqlite3.def生成sqlite3.lib
⑥用VC6新建一个空的控制台工程，把(sqlite3.h、sqlite3.dll、sqlite3.lib)放到工程文件夹里，

选择菜单栏的工程-->设置：在连接的(对象/库模块)后面加上sqlite3.lib，然后点确定


关于面向宝安区户籍在册轮候家庭配租公共租赁住房选房有关事项的通告
http://www.baoan.gov.cn/jshej/zwfw/zfly/tzgg/202003/t20200330_19082487.htm
信息来源：宝安区住建局 信息提供日期：2020-03-30 16:08
1、勤诚达乐园:https://720yun.com/t/5cvkihpyg8m?scene_id=36604776,或扫描本通告末的二维码在线看房。
2、君钰府:https://720yun.com/t/b3vkihpyzr7?scene_id=36604747,或扫描本通告末的二维码在线看房。

Sqlite3小结（小型数据库中增删改查的操作）
https://blog.csdn.net/nan_lei/article/details/84344003
2、常见数据库简介

目前比较流行的数据库有以下几种：

1.大型数据库Oracle Database

Oracle公司（甲骨文公司）是全球最大的企业级软件公司，其公司旗下著名产品有Java编程语言与OracleDatabase。Oracle公司主要面向大型企业，为各大企业提供专业级的数据库解决方案。

2.办公用数据库Microsoft Access

Access是微软在Office办公套件内提供的数据库软件，具有数据库引擎和图形化交互界面，并且可以使用VBA编程环境对其进行深度编程操作。

3.小型数据库MySQL

由瑞典MySQLAB公司开发（该公司已被Oracle公司收购），经常应用于WEB前端领域。由于体积小、速度快、代码开源深受程序开发人员喜爱。还可以配合PHP和Apache搭建数据库服务器。

4.嵌入式数据库SQLite

SQLite数据库是专门针对嵌入式开发的数据库软件，占用资源非常少（仅需几百K内存即可），处理速度快，而且可以直接使用C语言编程，同时也可以配合C#、PHP、Java等其他语言。SQLite诞生于2000年，2015年发布了新版本SQLite3，一经推出马上变成了最流行的嵌入式数据库软件。

//SQL中文翻译为“结构化查询语言”，是单词"Structured Query Language"的缩写。SQL是一种操作数据库的高级的非过程化编程语言，用户使用SQL命令通过DBMS对数据库内的数据进行访问。1987年，SQL得到国际标准组织ISO的支持成为数据库的国际标准，不过各种数据库的SQL命令略有不同，因此并不能够完全通用。

//SQL到底应该读作"S-Q-L"三个字母还是读作"色Q尔"整体读音，这个争?? ?论时至今日仍没有定论

二、SQLite3数据库使用

//使用SQLite3需要安装，若当前主机没有SQLite3软件可以输入命令sudo apt-get install sqlite3安装

使用SQLite3数据库有两种方式：

1.手动创建



SQLITE_API int sqlite3_exec

每日文件(日期h.db)和最新15分钟文件(renew.db)

Andy 2020/3/31 星期二 8:26:57
ben要辞职了，你接手一下他的一部分项目

awendy 2020/3/31 星期二 8:28:53
哦，好的。

Andy 2020/3/31 星期二 8:29:38
他会给你，今天先看radar 和 options ，options以前看过的

Andy 2020/3/31 星期二 8:57:21
大概搞清楚是做什么的

awendy 2020/3/31 星期二 8:57:39
好的。

Andy 2020/3/31 星期二 8:57:51
你跑w2t里面有个异动雷达

Andy 2020/3/31 星期二 8:58:26
radar包括 server 和 client  

awendy 2020/3/31 星期二 9:00:45
好的。

awendy 2020/3/31 星期二 8:58:09
问你个私人问题啊，你为什么要离职的呀？

awendy 2020/3/31 星期二 8:58:33
有更好的方向发展， 还是其它原因的呀。

Ben 2020/3/31 星期二 8:58:51
回老家啊，对象在老家

awendy 2020/3/31 星期二 8:59:22
哦，这倒是个事实原因的。

Ben 2020/3/31 星期二 8:59:47
是啊

Ben 2020/3/31 星期二 9:12:57
嗯，最开始server和client是同一个工程来的

Ben 2020/3/31 星期二 9:13:16
后来client功能加多了，就分开了


Ben 2020/3/31 星期二 10:05:45
这个地方由<0改成<=0

Ben 2020/3/31 星期二 10:06:04
版本号也改到60吧



2020.03.31

http://www.oracle.com/
download--->
https://www.oracle.com/downloads/
java--->
https://www.oracle.com/java/technologies/javase-downloads.html
--->
23465028@qq.com Hwdcxm+birthyear
jdk-8u241-windows-i586.exe
Java SE 8u241
Java SE 8u241 includes important bug fixes. Oracle strongly recommends that all Java SE 8 users upgrade to this release.

https://www.oracle.com/java/technologies/javase-downloads.html
拉到最下面
Java Archive
The Java Archive offers access to some of our historical Java releases. WARNING: These older versions of the JRE and JDK are provided to help developers debug issues in older systems. They are not updated with the latest security patches and are not recommended for use in production.
--->
https://www.oracle.com/cn/java/technologies/oracle-java-archive-downloads.html
Oracle Java 存档
Oracle Java 存档提供对一些历史 Java 版本的自助式下载访问。
警告: 提供这些旧的 JRE 和 JDK 版本是为了帮助开发人员对旧系统中的问题进行调试。 这些旧版本未使用新安全补丁进行更新，不建议用于生产环境。
--->
https://www.oracle.com/java/technologies/java-archive-javase-v13-downloads.html
j2sdk-1_3_1_28-windows-i586.exe
以上为java的JDK下载全流程。


https://www.eclipse.org
右上角download--->
https://www.eclipse.org/downloads/；进入官网，点击Download Packages；
右边..从这个2018-09开始才会有32位的--->
https://www.eclipse.org/downloads/packages/release/2018-09/r
--->
Eclipse IDE for Java Developers
189 MB 534,722 DOWNLOADS
The essential tools for any Java developer, including a Java IDE, a Git client, XML Editor, Mylyn, Maven and Gradle integration
Windows 32-bit 64-bit
---->
https://www.eclipse.org/downloads/download.php?file=/technology/epp/downloads/release/2018-09/R/eclipse-java-2018-09-win32.zip
Select Another Mirror
China - Beijing Institute of Technology
eclipse-java-2018-09-win32.zip

以上为eclipse的JDK下载全流程。




https://docs.oracle.com/javase/8/docs/

D:\Program Files\Project

Project 只有一个 其它盘下都是Temp

C:\Users\Wendy\Documents\WeChat Files\awendy999999999\FileStorage\File\2020-03
奥拓维修手册.rar 2^10=1024

https://www.eclipse.org/downloads/download.php?file=/technology/epp/downloads/release/2018-09/R/eclipse-java-2018-09-win32.zip
Select Another Mirror
China - Beijing Institute of Technology
eclipse-java-2018-09-win32.zip

https://www.eclipse.org/downloads/packages/release/2018-09/r
从这个2018-09开始才会有32位的

https://www.eclipse.org/downloads/；进入官网，点击Download Packages；

https://www.eclipse.org/downloads/packages/release/photon/r
https://ftp.yz.yamagata-u.ac.jp/pub/eclipse//technology/epp/downloads/release/2018-09/R/eclipse-jee-2018-09-win32.zip
https://ftp.yz.yamagata-u.ac.jp/pub/eclipse//oomph/epp/2018-09/Ra/eclipse-inst-win32.exe

https://www.oracle.com/cn/java/technologies/oracle-java-archive-downloads.html
https://www.oracle.com/java/technologies/java-archive-javase-v13-downloads.html
j2sdk-1_3_1_28-windows-i586.exe

https://www.oracle.com/java/technologies/javase-downloads.html
23465028@qq.com Hwdcxm+birthyear
jdk-8u241-windows-i586.exe
Java SE 8u241
Java SE 8u241 includes important bug fixes. Oracle strongly recommends that all Java SE 8 users upgrade to this release.


C:\Users\Wendy\Desktop
C:\Users\Public\Desktop
D:\Program Files\Microsoft Visual Studio\MyProjects

AStyle_3.1_windows-硬件开发工具类资源-CSDN下载
2019年3月24日 - AStyle_3.1_windows 评分 AStyle是一款代码格式化工具

C:\ProgramData dp45977c.lfl是什么?
https://zhidao.baidu.com/question/326749346357971285.html
DP45977C.lfl文件默认保存在C:\ProgramData，该文件为隐藏文件，大小为0字节，使用记事本打开后无任何内容。该文件自Win7系统就出现在该位置，Win8、Win8.1和Win10系统也有存在。virscan.org网站鉴定该文件是安全文件。该文件好像和Realtek声卡驱动有关，可能用于加载相关声卡驱动。
该文件正常情况，不能删除，即便在PE下已无法删除，删除后会自动生成。

整理电脑硬盘.

凌风观雪: 我终于解决2345全家桶了，分享给大家-在任务管理器里找到2345病毒位置，记下来-开机进入安全模式（各个电脑不同）-进入对应位置删除（亲测可删）-打开注册表-搜索2345全家桶，一个干掉，花了5小时，原装系统不想重装。。。
https://tieba.baidu.com/p/5986053651

MSCREATE.DIR是什么文件?
https://zhidao.baidu.com/question/26271769.html
这种现象是安装程序的设计导致的。安装程序会在每个文件夹中创建MSCREATE.DIR（0 字节隐藏文件）以指示安装程序已创建该文件夹 。当您在维护模式下运行安装程序并删除组件或单击全部删除时，安装程序将使用此文件来确定是否可删除的空文件夹。如果某个空文件夹不包含此文件，在维护模式下运行安装程序时，安装程序不会删除该文件夹。
例如，如果在 Microsoft Office 文件夹中，创建“我的文件”的文件夹，当您在维护模式下运行 Microsoft Office 安装程序并单击全部删除时，安装程序不会删除“我的文件”的文件夹，即使它是空的。

feel doing things of Twenty years ago.

汽车冲向儿子瞬间父亲做出神反应 惊险画面曝光让人后怕
https://wxn.qq.com/cmsid/AUS2020032900508903

2020.03.30

快速看书，得右键loadmenu菜单的流程，量变到质变的案例？


MFC对话框资源移植（一个工程复制到另一个工程）
https://blog.csdn.net/myruo/article/details/80917406
前言：

很多时候，我们需要把已经存在的一个对话框资源（或者类似的）复制到另一个工程中（好吧，其实就是懒~）


可用方案：


1、把两个工程添加到一个项目中，这样你就可以随意的复制粘贴了，当然，这种办法还需要你去布局，改ID什么的


2、简单快速高效的办法：在源工程的rc文件中复制你需要的内容到目标工程的rc文件，然后把源工程的resource.h中对应部分复制到目标工程，这样就大功告成了。



VC 如何Copy一个项目的资源文件中的对话框到另一个项目
https://blog.csdn.net/ccl3311/article/details/3224222
方法一：
文本打开rc文件，找到你想要的对话框资源那段，直接拷贝到你的工程中。不过这样资源你需要手动的resource.h中添加。 
方法二：
将要拷贝资源的工程(Prcject)插入到你现在的工程所在的工作区(WorkSpace)中，在ResourceView中，找到你想要复制的对话框，复制，再回到你的工程中，粘帖就可以了。资源拷贝好后将对应.cpp和.h文件拷贝到你的工程目录下，并且添加到你的工程中，稍微做一下修改即可，也可以利用ClassWizard添加对应的类。
方法三：
class view 中选中界面对于的类，右键->add to  gallery，需要的时候 project->add to project-> component and control找到对应的ogx 文件，插入即可。


VC++6.0如何将一个工程中的对话框资源复制到另一个工程
https://blog.csdn.net/PerfectToday/article/details/11056681
第一步：打开源工程，切换到资源视图（ResourceView），选中要复制的对话框或菜单资源ID，如：本例中选中对话框资源“IDD_FIND_DLG”，按Ctrl+C或点击Edit菜单选择Copy项。
第二步：点击文件（File）菜单，选择关闭工作区（Close Workspace），从而关闭源工程。
第三步：点击文件（File）菜单，选择打开工作区（Open Workspace），从而打开目标工程。注意打开时需要手动选择文件类型（Projects (*.dsp)）。之后选择资源视图且选中
第四步：顺便把对话框 IDD_FIND_DLG 对应的H/CPP文件从源工程工作区目录中复制过来，本例还复制了一个相关的线程类，合计4个文件。
之后，选择文件视图（FileView），右击工程在弹出的菜单中选择“Add Files to Project…”选中上述4个文件，将相关类加载到目标工程中来。
第五步：一般情况下，对话框类与源工程其它类都保持着密切的交互动作，增加相关变量、函数保持相关处理的一致性，编译之后就不会有什么错误了。


VC++中如何复制对话框资源
https://www.cnblogs.com/Yogurshine/p/3710566.html
法1：
 
在你的工程中添加另一个工程的rc文件，这时资源视图中就会出现两个rc,从后加的rc中拷贝资源到你自己工程的rc中就可以了。(复制即可 v ok)
 resource.h 也要复制过来，修改ID值为不同。
 
 
法2：vc中如何拷贝一个工程的对话框资源到另一个工程中?
 
这是一个很专业也很有用的问题。其实VC的设计者早就为我们考虑了这个问题。
在VC6环境下，选择Class视图，选中想要克隆的对话框所对应的类，例如CAboutDlg，点击鼠标右键，选择Add to gallery。在新工程中选择Project菜单，选择Add Component and ActivX，你会看到多了一个文件夹（与上一个工程同名），进入该文件夹，选择*.ogx。选择Insert，你会发现原来的对话框被加入到新的工程中了！
 
补充：
.net下更简单，将原来的工程加到新的工程中，直接将对话框拷贝过去就行了！
 
 
法3：
VC++中如何复制对话框资源
第一步：用记事本打开原工程的.rc文件，找到想复制的对话框的信息，如下所示
 
IDD_UGMS_DIALOGDIALOGEX 0, 0, 320, 230
STYLE WS_CHILD | WS_VISIBLE
EXSTYLE WS_EX_APPWINDOW
FONT 9, "宋体"
BEGIN
  GROUPBOX      "学生信息",IDC_STATIC,10,8,290,200
  GROUPBOX      "",IDC_STATIC,25,55,205,120
  PUSHBUTTON    "最前(&F)",IDC_BUTTON_FIRST,30,30,35,15
  PUSHBUTTON    "向前(&B)",IDC_BUTTON_PRE,82,30,35,15
  PUSHBUTTON    "向后(&N)",IDC_BUTTON_NEXT,134,30,35,15
  PUSHBUTTON    "最后(&L)",IDC_BUTTON_LAST,186,30,35,15
  PUSHBUTTON    "查询(&Q)",IDC_BUTTON_QUERY,246,70,40,15
  PUSHBUTTON    "增加(&A)",IDC_BUTTON_ADD,246,96,40,15
  PUSHBUTTON    "修改(&M)",IDC_BUTTON_MODIFY,246,122,40,15
  PUSHBUTTON    "删除(&D)",IDC_BUTTON_DELETE,246,148,40,15
  PUSHBUTTON    "确定(&O)",IDC_BUTTON_OK,58,183,40,15
  PUSHBUTTON    "取消(&C)",IDC_BUTTON_CANCEL,150,183,40,15
  LTEXT          "学号：",IDC_STATIC,52,75,25,8
  LTEXT          "姓名：",IDC_STATIC,52,100,25,8
  LTEXT          "性别：",IDC_STATIC,52,125,25,8
  LTEXT          "入学时间：",IDC_STATIC,44,151,41,8
  EDITTEXT      IDC_EDIT_SID,91,72,95,15,ES_AUTOHSCROLL
  EDITTEXT      IDC_EDIT_SNAME,91,96,95,15,ES_AUTOHSCROLL
  EDITTEXT      IDC_EDIT_SSEX,91,120,95,15,ES_AUTOHSCROLL
  CONTROL        "DateTimePicker1",IDC_DATETIMEPICKER_SCOMEDATE,
                  "SysDateTimePick32",DTS_RIGHTALIGN | WS_TABSTOP,91,144,
                  95,15
  GROUPBOX      "",IDC_STATIC,25,19,205,35
END
 
上面代码中绿色背景代表的是要复制的对话框资源的ID，此段代码也就是.rc文件中记录的此对话框的信息，黄色背景中间的代码就是
 
相应对话框中添加的控件信息，只需将相应代码拷到新工程的相应.rc文件相应的ID对话框资源的BEGIN 和END之间即可；
 
第二步：打开原工程的FileView视图下的Header Files 下的resource.h文件，将其中相应ID的信息复制到新工程的resource.h中即可；
 
例如：
 
//复制的资源ID
#define IDC_BUTTON_FIRST              1000
#define IDC_BUTTON_PRE                1001
#define IDC_BUTTON_NEXT              1002
#define IDC_BUTTON_LAST              1003
#define IDC_BUTTON_QUERY              1004
#define IDC_BUTTON_ADD                1005
#define IDC_BUTTON_MODIFY              1006
#define IDC_BUTTON_DELETE              1007
#define IDC_BUTTON_OK                1008
#define IDC_BUTTON_CANCEL              1009
#define IDC_EDIT_SID                  1010
#define IDC_EDIT_SNAME                1011
#define IDC_EDIT_SSEX                1012
#define IDC_DATETIMEPICKER_SCOMEDATE    1013
 
第三步：记得不要遗漏啊，如有ID重复，可以更改一下即可！
 
 
法4：
 
今天碰到模块移植问题了,自己做的对话框类(继承于CDialog)要移植到目标工程中.在网上搜了几个帖子发现都说的很生涩.问了我们的技术总监之后总算解决这个问题了.
 
      问题:把一个MFC SDI工程中的一个对话框资源和类拷贝到另一个MFC SDI中.
 
      1.在VC6中打开老的工程,在工作区Resource标签页中选中Dialog文件夹下的资源文件(就是双击后会出现编辑窗口界面的那个东西),按Ctrl+C(Edit->Copy也一样).
 
      2.关闭当前工程,注意不要关闭VC6,打开目标工程(File->OpenWorkspace),然后选中工作区的Resource标签页中的Dialog文件夹,然后按Ctrl+V(Edit->Paste也一样).好了,对话框拷贝过来了.
 
      3.将对话框类的cpp h文件拷贝到目标工程中(不详细说了,往当前工程添加文件)
 
      4.打开复制过来的类cpp和h文件,删除没用的头文件(老工程相关的),并且在.h文件中添加文件包含
 
#include "Resource.h"
第四步很关键,老工程中根本就没有这个文件包含,可是移植之后必须手动添加头文件包含.因为这个问题卡了10几分钟...
当你用资源ID时（通常资源编辑器编辑的资源ID都在resource.h中），如果没有包含CWinApp的派生类所在的头文件就会出错，你看一下它的头文件里，包含了这个文件， 而向导生成的类，它的实现文件都有包含CWinApp派生类所在的头文件的
 
然后在新工程中就可以使用这个类了,主要就是这个类的对话框中的资源复制头一次遇到.不敢独享,拿出来跟新手们一起学习.
 
 
于是，当有已经创建好的对话框资源要添加到新工程中时：
（1）右键单击新工程所在的解决方案添加“现有项目”把旧工程添加进来；
（2）切换到“资源视图”并在旧工程对话框资源上右键“复制”；
（3）在新工程对话框资源上右键“粘贴”；
（4）现在就可以为新对话框添加类了，顺便把旧工程的响应函数拷贝过来；
（5）切换回“解决方案资源管理器”，右键旧工程“移除”。


三天前左右，济自己冲凉了。办济手表卡明说不让拍照，以后尽量看场合拍照。
aoe罗马尽量少作笔，多练技术.

只要百度搜索，右边会出现百度热榜.

2020.03.27

微信,user name :手机号or awendy9...9(9个）password:Q名+o

git checkout .

如何回滚文件

1. 修改完，还未执行git add 
git checkout .
使用暂存区的文件覆盖工作区，所以执行完git add .之后，再执行该命令是无效的  
git checkout .和git add .是一对反义词

2.使用git add 提交到暂存区，还未commit之前
git reset  先用Head指针覆盖当前的暂存区内容
git checkout . 再用暂存区内容覆盖工作区内容
或者使用
git reset --hard 直接使用head覆盖当前暂存区和工作区

3.已经git commit，还未git push
git reset --hard origin/master (v ok)
从远程仓库把代码取回来，然后覆盖本地仓库、本地暂存区和工作区  
或者使用
git reset --hard last_commit_id
覆盖本地仓库、暂存区和工作区，其中查看last_commit_id命令为
git log
  或者使用
git reset --mixed last_commit_id  
覆盖本地的暂存区，再执行
git checkout . 覆盖本地工作区

4.已经git push  
  那就没办法了



error BK1506 : cannot open file '.\Debug\????????.sbr': No such file or dire
https://blog.csdn.net/shuilan0066/article/details/8738035
1 error BK1506 : cannot open file '.\Debug\????????.sbr': No such file or dire




解决方法：

从工程->设置->浏览信息->创建创建浏览信息的复选框的勾给去掉就行了




工程---属性---C/C---Browse Information -----Enable Browse Information? 设置为NONE


无法识别您当前的时区,请选择一个有效的时区
https://jingyan.baidu.com/article/e9fb46e17547797521f766b5.html

2020.03.26

Service Worker, 你到底是个什么东西？
https://www.zcfy.cc/article/service-worker-what-are-you-mariko-kosaka-1927.html
我认为它就像一个你可以邀请住到用户浏览器里的外星人。听起来很奇怪？好吧，让我来解释给你听。

service-worker用法详解
https://segmentfault.com/a/1190000019863217

Service Workers简介(一)
https://www.jianshu.com/p/1bc5bf8be43d
service worker是一个脚本，由浏览器在背后默默地运行，独立于web页面.....
关于service worker，我们需要知道:
它是一个 JavaScript 线程, 所以它不能直接接触DOM. service worker 可以与一些页面通信(这些页面通过postMessage接口发出信息)，而这些页面可以操作DOM(如果需要的话)
Service worker 是一个可编程的网络代理，它允许你控制网络如何从你的页面发出请求。



# Begin Target

# Begin Target

# Name "MsEdit_Wendy - Win32 Release"
# Name "MsEdit_Wendy - Win32 Debug"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
# Begin Source File

SOURCE=.\DataSrc_TTFrameFile.cpp
# End Source File
# Begin Source File
...
SOURCE=.\MsEdit_Wendy.rc
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# Begin Source File

SOURCE=.\Datadef.h
# End Source File
# Begin Source File
....
SOURCE=.\WorkThread.h
# End Source File
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
# Begin Source File
...

SOURCE=.\res\MsEdit_Wendy.rc2
# End Source File
# End Group
# Begin Source File

SOURCE=.\ReadMe.txt
# End Source File
# End Target
# End Project

Begin XX 和 End XX 需要一一对应 (v ok)

-----------------------------------------
SOURCE=.\WorkThread.cpp
# End Source File
# Begin Source File

SOURCE=.\MsEdit_Wendy.rc
# End Source File
# End Group
# Begin Group "Header Files"
---------------------------------------- (v ok)
SOURCE=.\WorkThread.cpp
# Begin Source File
# End Source File

SOURCE=.\MsEdit_Wendy.rc
# End Source File

# PROP Default_Filter "h;hpp;hxx;hm;inl"
------------------------------------------------- x

VC6.0添加文件到工程无响应解决方案 (2011-12-09 20:43:25)转载
http://blog.sina.com.cn/s/blog_77f7c6e20100yc6p.html
标签： vc6.0 加载 文件 工具栏 解决方案 工程 it	分类： VC学习
    最近使用vc6.0时，要添加类到工程，但是右键点击添加文件到工程或者在工程里单击增加到工程――文件毫无反应，在网上搜了很久，发现是visio2007与vc6.0有冲突。找了解决方案，下面简单说下：

1、下载filetool.exe，下载地址：http://support.microsoft.com/kb/241396/zh-cn

2、解压下载下来的filetool.exe文件，用vc6.0打开解压出来的filetool.dsw文件

3、运行程序，生成debug文件

4、单击工具――定制――附加项和宏文件――浏览，把刚才生成的debug文件夹里的filetool.dll加载进来，关闭对话框

这时候会出现一个只有两个命令的工具栏，用工具栏上的命令就可以把文件加载到工程中了。至于对快捷键的设置我都没有设置，反正只要已经能成功加载文件就行了。



.dsp has been modified and cannot be loaded as a developer studio project
https://www.cnblogs.com/weiweiting/articles/2645801.html
网上找到的方法：

　　第一个是,打开工程文件时,XX.DSP   has   been   modified   and   cannot   be   loaded   as   a   Developer   Studio   project.  

　　第二个是编译时错误，resource.h fatal error RC1004: unexpected end of file found

　　我是在用replace pioneer替换工程名后出现第一个问题的，对比备份的dsp文件没有发现任何可能错误的地方。然后我退求其次手动修改了原来的dsp文件，于是就碰到第二个问题了，同样对比备份的resource.h文件也没发现任何不同。

　　网上对于第一个问题的解决方法是新建一个工程再把原有文件都添加进去，太麻烦了。

　　第二个问题给的解决方法是找一个正常的resouce.h文件替换结尾部分：

　　看了网上给出的第二个问题方法，我对比了下它们的结尾部分，其实是有差别的，差别就是一个回车换行~晕哪，怪只能怪VC6不提供行号显示功能，假如放到Dev-C++下打开就一目了然了。

    同样对于第一个问题，我们只要检查下dsp文件最后是不是有一个空行就好了。

上述方法，都没有解决我的问题，奇怪的是，这个工程在我工作机上打开是没有问题的，为什么在笔记本上打开就有问题了？经过检查，我发现工程放的文件夹在几层文件夹下，是解压后的文件，并且上两层文件夹名中带括号（还有注意中文文件名的问题），我试着把工程文件夹放在任一硬盘驱动器根目录下，问题解决……


2020.03.25

ini的注释怎么写？ [问题点数：20分，结帖人flypigluo]
https://bbs.csdn.net/topics/70114126
一般是分号开头，也可以是#号，或者直接写注释也行
ini文件本身只是一个文本格式的文件，你可以自己定义，只要你真正的数据，如小节名，键名不要使用这些怪字符就可以了，
ini的注释写法是:

每一行的第一个字母是 ; 号,这一行就是注释行．注释行可以出现在文件中的任意一行．

就像Ｃ＋＋
// 这是一个注释行．
汇编
; 这是一个注释行．

my.ini文件参数中文注释
https://blog.csdn.net/lienfeng6/article/details/78140404

INI文件中的注释符（；），有什么用？ [问题点数：40分，结帖人sdcer777]
https://bbs.csdn.net/topics/360137034
注释成单独的行，正解
嗯,只有开头的;会被认为是注释行

石岩营业厅地址：宝安区石岩街道宝石西路76号（石岩新汽车站、北龙加油站旁）。服务时间：9:00-18:00（2020年1月24日-1月30日营业时间为：11:00-16:00）；服务电话：13510008009，如需了解位置信息可参考以下地图链接： http://f.amap.com/1pE7c_0152Bxd【中国移动】


佳华豪苑营业厅地址：宝安区石岩大道83号佳华豪苑首层11-12号商铺(真功夫餐厅旁)。服务时间：9:30－18:30，服务电话：13510001292，如需了解位置信息可参考以下地图链接： http://f.amap.com/5Bf3t_0F52zIH【中国移动】


8元自由选套餐（30分钟）：
1、包含国内通话30分钟，国内接听免费，来电显示；
2、超出套餐范围：
（1）语音通话：在国内直接拨打国内电话0.25元/分钟全包。
（2）国内流量：默认开通30元流量保障服务，每10元100MB，不足10元部分按照0.29元/MB收取，以此类推，直至超出流量费用达到30元时，可以继续使用流量至1GB。
温馨提醒：以上资费不含中国港澳台地区。★“众志成城、抗击疫情。服务不中断、爱心永在线”，广东移动手机营业厅为您提供足不出户的便捷服务，详情可点击： dx.10086.cn/10086rg 。如有疑问，请回复0寻求在线客服帮助。【中国移动】


8元自由选套餐（100MB流量）：
1、包含国内流量100MB，国内接听免费，来电显示；
2、超出套餐范围：
（1）语音通话：在国内直接拨打国内电话0.25元/分钟全包。
（2）国内流量：默认开通30元流量保障服务，每10元100MB，不足10元部分按照0.29元/MB收取，以此类推，直至超出流量费用达到30元时，可以继续使用流量至1GB。
温馨提醒：以上资费不含中国港澳台地区。★“众志成城、抗击疫情。服务不中断、爱心永在线”，广东移动手机营业厅为您提供足不出户的便捷服务，详情可点击： dx.10086.cn/10086rg 。如有疑问，请回复0寻求在线客服帮助。【中国移动】

亲，超60分钟了，超出会打不出，打不进。
可以在公众号的充值激活点套餐订购输入手表号码之后点右下角有叠加包可以办理接着使用，如果不办理可以等待到下个月1号才可以使用 

移动卡，【中升翼联】季度包套餐/59元，半年 包套餐/79元，1年包套餐/109元：              
通话时长60分钟/月， 100MB/月
30分钟通话时长叠加包/8元：30分钟，当月有效，月底清 零 


中国移动营业厅(石岩服营厅) 查看全市分店
信息更新时间: 2020年03月23日
地址： 广东省深圳市宝安区石岩镇宝石西路石岩上屋坳背龙新村93,94号商铺首层 查看地图
电话： 10086
分类： 营业厅

石岩宝石西路76号，石岩汽车站公交站那里

石岩影剧院背后过去有个佳华商场，旁边有个肯德基，肯德基旁边就有个中国移动营业厅。
可以办理所有业务，石岩就两个，一个在这里，另一个在石岩汽车站旁边。10：00--19：00

MFC的注册表操作―CRegKey类的使用
https://blog.csdn.net/a237428367/article/details/5973799
1.简介
CRegKey提供了对系统注册表的操作方法，通过CRegKey类，可以方便的打开注册表的某个分支或子键（CRegKey::Open），可以方便的修改一个键的键值（CRegKey::SetValue），也可以查询某个键的键值（CRegKey::QueryValue），操作完成之后，可以关闭子键（CRegKey::Close）。
要想使用CRegKey类，需要包含头文件atlbase.h
2.常用操作方法
1) 打开需要查询或修改的注册表键
CRegKey myKey;
    if(myKey.Open(HKEY_LOCAL_MACHINE, "SOFTWARE//Microsoft//Windows") != ERROR_SUCCESS)
    {
        AfxMessageBox("Error open reg key!!");
    }
2) 查询注册表项中的某个键的键值
CRegKey myKey;
   if(myKey.Open(HKEY_LOCAL_MACHINE, "SOFTWARE//Microsoft//Windows//CurrentVersion") != ERROR_SUCCESS)
        AfxMessageBox("Error open reg key!!!");
    else
    {
        char szPath[MAX_PATH];
        DWORD dwLen = myKey.QueryValue(szPath, "WallPaperDir", MAX_PATH);
    }

CRegKey myKey;
    if(myKey.Open(HKEY_CLASSES_ROOT, ".txt") != ERROR_SUCCESS)
        AfxMessageBox("Error open key!!!");
    else
    {
        char szFileType[255];
        DWORD dwLen = myKey.QueryValue(szFileType, "", sizeof(szFileType));
    }

3) 添加或修改键值
 CRegKey myKey;
    if(myKey.Open(HKEY_CURRENT_USER, "Software//Microsoft//Internet Explorer//Toolbar") != ERROR_SUCCESS)
        AfxMessageBox("error open reg key!!!");
    else
    {
        myKey.SetValue("C://WINDOWS//Web//Wallpaper//Bliss.bmp", "BackBitmap");
    }
4) 删除键值
CRegKey myKey;
    if(myKey.Create(HKEY_CLASSES_ROOT, ".spj") != ERROR_SUCCESS)
        AfxMessageBox("error create key!!!");
    else
        AfxMessageBox("create key ok!");
5) 新建项
CRegKey myKey;
    if(myKey.Create(HKEY_CLASSES_ROOT, ".spj") != ERROR_SUCCESS)
        AfxMessageBox("error create key!!!");
    else
        AfxMessageBox("create key ok!");
6) 删除项
LONG DeleteSubKey( LPCTSTR lpszSubKey );
该函数可以删除名为lpszSubKey的项，以及该项下的所有的键。注意，被删除的项不能含有子项！可以通过另外一个函数LONG RecurseDeleteKey( LPCTSTR lpszKey );删除某个项以及该项下的所有内容。

7) 关闭注册表
LONG Close( );
关闭注册表时，之前所做的修改才会被保存到硬盘。或者，也可以使用LONG RegFlushKey( HKEY hKey ); 函数在需要的时候将所做的修改及时写入硬盘。



2020.03.24

刚刚收到，要激活卡的，幸好先问一下没有激活卡，因为卡不是本地的不能加入集团网，谢谢客服回得快

CArray,CMap,CList 速度比较
http://www.cppblog.com/xkjy3000/archive/2012/06/20/179510.aspx
CArray：增加元素非常快, 查询元素慢(循环方式)
CMap：增加元素很慢,查询元素非常快(Lookup方法)【随机地频繁地访问元素时,建议使用CMAP】
CList：插入删除很快。但是通过索引访问很慢

用CTypedPtrList吧。你这样用结构传值做参数性能很低的
而且不推荐用CTypedPtrList,用CTypedPtrMap会快得多

恒大的多个楼盘已经打7.5折卖啦

MFC控件编程之 按钮编辑框.静态文本的使用以及访问控件的七种方法.
https://www.cnblogs.com/iBinary/p/9652668.html
常用的API:
　　1.根据控件ID.获取控件的标题名称.
　　GetDlgItemText(控件ID,字符串缓冲区);
　　2.根据控件ID.设置控件的标题.
　　SetDlgItemText(控件ID.字符串);
我们如果在MFC中使用API .需要加上全局访问符号.::  也就是四饼. 
否则就是使用MFC自带的封装的API不过此时我们上面所说的API.就是使用的MFC封装的.比较方便..
三丶访问控件的七种方法.
上面我们已经使用了一种了. GetDlgItemText() 根据指定控件ID获取控件文本.

3.1   控件ID访问方法.
　　 GetDlgItem(控件ID)
　　GetWindowsText(缓冲区.大小.)
GetDlgItem(IDC_EDIT1)->GetWindowText(ch1,12);
GetDlgItem(IDC_EDIT3)->SetWindowText(ch3);
上面是MFC封装好了.所以我们可以 ->继续调用.如果是自己使用Windows API编写.那么需要 ::GetDlgItem(指定窗口的句柄,控件ID)获取根据控件ID寻找的窗口句柄.然后自己继续调用 ::GetWindowText(句柄.缓冲区) 来进行获取.
具体原理可以自己看下源代码

3.2GetDlgItemText() 获取.
GetDlgItemText(IDC_EDIT2, ch2, 12);
SetDlgItemText(IDC_EDIT3, ch3);

3.3. 使用方法三.直接获取整形.
GetDlgItemInt(IDC_EDIT2);
SetDlgItemInt(IDC_EDIT3,nNum3);

3.4 控件跟整形变量关联. Value类型
如果使用这个方法.那么我们的控件需要绑定一个变量.使用这个变量来获取跟设置.
编辑框 - > 类向导 -> 添加变量   给编辑框进行关联.
使用的时候需要用到一个函数. 
UpdateData(True) 或者 False
TRUE. 则把控件里面的数据.关联到变量里. 简单理解为就是获取数据.调用了这个.那么我们绑定的变量就会有数据了.
FALSE: 数据设置到控件中. 当我们使用完变量则需要将数据设置到控件里显示.就用FALSE.
原理.
DoDataExChange函数. 
在MFC中有一个这种函数. 用来跟关联变量的设置的.
DDX_Text 是跟变量关联了.
DDV开头的则是检查的.
我们可以F12跟进看到很多这种类型.

3.5 把控件跟控件变量关联. Edit类型.我们可以跟控件关联
这个就可以当控件使用了.
我们给编辑框关联的.那么查询MSDN可以看到控件的操作方法.
m_Edit.GetWindowText();
m_Edit.SetWindowText();

3.6发送消息进行控件操作.
MFC中都是消息驱动的.那么我们也有API可以进行发消息操作.
::SendMessage(控件id的句柄,消息类型,大小.附加参数.)
::SendMessage(GetDlgItem(EDT_EDIT)->m_hWnd,WM_GETTEXT,12,(LPARAM)ch1);
参数2: 消息类型.我们WM_GETTEXT 是代表我要获取这个文本.
参数3: 12 是缓冲区的长度.
参数4: 缓冲区.
其中3 4 是额外附加参数.什么意思? 就是说这个参数不确定.可以自己给定.
我们解析的时候按照对应类型解析即可. 你可以给数组.也可以给结构体.都是可以的.
设置字符串.
::SendMessage(Getdlgitem(IDC_EDT3),WM_SETTEXT,0,(LPARAM)ch3);
这个方法需要掌握.一般写windows程序.这个函数会常用.

3.7 根据方法6合并的一个函数
SendDlgItemMessage(控件ID.WM_GETTEXT,附加参数,附加参数);
//使用例子
SendDlgItemMessage(IDC_EDIT1,WM_GETTEXT,12,(LPARAM)ch1);
设置字符串
SendDlgItemMessage(IDC_EDIT1,WM_SETTEXT,0,(LPARAM)ch3);

C:\Users\Wendy\Downloads

我们赠送的卡是先要在微*ｘｉｎ公众号里充值激活+实名认证后就可以使用了！（充值激活+实名认证，就和平时办卡一样） 
亲  充满电正常使用1-2天左右，具体可使用时间会因为您的使用频率和使用方式而影响的
移动卡，【中升翼联】季度包套餐/59元，半年 包套餐/79元，1年包套餐/109元：              通话时长60分钟/月， 100MB/月
30分钟通话时长叠加包/8元：30分钟，当月有效，月底清 零
https://detail.tmall.com/item.htm?spm=a1z0d.6639537.1997196601.4.d94a74843zDY6M&id=601405966315


移动日租卡，在网上怎么办理？
https://zhidao.baidu.com/question/1580282184231188180.html
移动日租卡在网上办理的步骤如下：
1、使用手机打开手机微信进入微信首页点击右上角“+”，选择“添加朋友”，搜索移动微信公众号。
2、点击“移动”进入公众号后点击下方“关注”并进入页面。
3、进入公众号点击左下方键盘标识，然后在下方输入“日租卡”并点击发送。
4、公众号回复“日租卡办理”，然后点击蓝色字体进入链接。
5、最后弹出日租卡申请页面，点击“限时限量立即申请”，这样移动日租卡在网上办理的问题就解决了。


移动日租卡最便宜的套餐多少钱
https://zhidao.baidu.com/question/2273167452121837148.html
8元日租卡，我来帮你算
8元基础月租加上每天日租然后就是
8块一个月的月租，流量一元800M.，你每天用多少流量的钱，乘以30天，就等于你一个月的话费，如果你不用流量，一个月它就扣8元，打电话，短信费除外，，，，望采纳

2020.03.23

The MemoryStatus structure is 32 bytes long.
It should be 32.
50 percent of memory is in use.
There are 2097151 total Kbytes of physical memory.
There are 1572784 free Kbytes of physical memory.
There are 4194303 total Kbytes of paging file.
There are 3901144 free Kbytes of paging file.
There are  1fff80 total Kbytes of virtual memory.
There are  1fe604 free Kbytes of virtual memory.
My There are 1fff80 total Kbytes of virtual memory.
My There are 1fe604 free Kbytes of virtual memory.
p1=-681164800,p2=2140672000,My percentVirMem=1

p1=-681164800 *100后溢了数值.

#define DIV 1024
char *divisor = "K";
#define WIDTH_MY 7

MEMORYSTATUS stat;
static DWORD m_whileCount = 0;
if(m_whileCount % 1024*1024 ==0 )
{
	static DWORD pre_percent = 0;
	
	GlobalMemoryStatus (&stat);
	TRACE("The MemoryStatus structure is %ld bytes long.\n",stat.dwLength);
	TRACE("It should be %d.\n", sizeof (stat));
	TRACE("%ld percent of memory is in use.\n", stat.dwMemoryLoad);
	
	if (pre_percent > stat.dwMemoryLoad && stat.dwMemoryLoad >90)
		{
			m_nThreadStatu = -1 ;
		TRACE("Because pre_percent(%d) > Now(%d), So EndThread m_nThreadStatu = -1.\n", pre_percent,stat.dwMemoryLoad);
		}
	pre_percent = stat.dwMemoryLoad;
	
	TRACE ("There are %*lx total %sbytes of virtual memory.\n",
	        WIDTH_MY, stat.dwTotalVirtual/DIV, divisor);
	TRACE ("There are %*lx free %sbytes of virtual memory.\n",
	        WIDTH_MY, stat.dwAvailVirtual/DIV, divisor);
}


93 percent of memory is in use.
There are  1fff80 total Kbytes of virtual memory.
There are   76c9c free Kbytes of virtual memory.
The MemoryStatus structure is 32 bytes long.
It should be 32.
87 percent of memory is in use.
There are  1fff80 total Kbytes of virtual memory.
There are   72d5c free Kbytes of virtual memory.
The MemoryStatus structure is 32 bytes long.
It should be 32.


93 percent of memory is in use.
There are 2097151 total Kbytes of physical memory.
There are  202396 free Kbytes of physical memory.
There are 4194303 total Kbytes of paging file.
There are 2457220 free Kbytes of paging file.
There are  1fff80 total Kbytes of virtual memory.
There are   6acd0 free Kbytes of virtual memory. 437456  20%
The thread 0x16D8 has exited with code 0 (0x0).
The thread 0x1F4C has exited with code 0 (0x0).
The thread 0x2224 has exited with code 0 (0x0).
The MemoryStatus structure is 32 bytes long.
It should be 32.
89 percent of memory is in use.
There are 2097151 total Kbytes of physical memory.
There are  344220 free Kbytes of physical memory.
There are 4194303 total Kbytes of paging file.
There are 2437268 free Kbytes of paging file.
There are  1fff80 total Kbytes of virtual memory.
There are   63a50 free Kbytes of virtual memory.
The MemoryStatus structure is 32 bytes long.
It should be 32.


There are  1fff80 total Kbytes of virtual memory.  2097024
There are    43e0 free Kbytes of virtual memory. 17376

Loaded 'C:\Windows\System32\normaliz.dll', no matching symbolic information found.
Loaded 'C:\Windows\System32\iertutil.dll', no matching symbolic information found.
Loaded 'C:\Windows\System32\SearchFolder.dll', no matching symbolic information found.
SetBtnReadOrSearch m_needreadfs=1. 
m_needreadfs=1. 
Read Files.... 
The MemoryStatus structure is 32 bytes long.
It should be 32.
46 percent of memory is in use.
There are 2097151 total Kbytes of physical memory.
There are 1688764 free Kbytes of physical memory.
There are 4194303 total Kbytes of paging file.
There are 3981240 free Kbytes of paging file.
There are  1fff80 total Kbytes of virtual memory.
There are  1d9708 free Kbytes of virtual memory.
...
The MemoryStatus structure is 32 bytes long.
It should be 32.
93 percent of memory is in use.
There are 2097151 total Kbytes of physical memory.
There are  202396 free Kbytes of physical memory.
There are 4194303 total Kbytes of paging file.
There are 2457220 free Kbytes of paging file.
There are  1fff80 total Kbytes of virtual memory.
There are   6acd0 free Kbytes of virtual memory.
The thread 0x16D8 has exited with code 0 (0x0).
The thread 0x1F4C has exited with code 0 (0x0).
The thread 0x2224 has exited with code 0 (0x0).
...
The MemoryStatus structure is 32 bytes long.
It should be 32.
74 percent of memory is in use.
There are 2097151 total Kbytes of physical memory.
There are  790936 free Kbytes of physical memory.
There are 4194303 total Kbytes of paging file.
There are 2029532 free Kbytes of paging file.
There are  1fff80 total Kbytes of virtual memory.
There are    43e0 free Kbytes of virtual memory.
First-chance exception in MsEdit_Wendy.exe (KERNELBASE.DLL): 0xE06D7363: Microsoft C++ Exception.


主要修改: 1,ClistCtrl显示的时间为time2十进制. 2,文件列表取消自动排序便于看后加文件. 3,优化代码逻辑以事务码e分流等. 4,做完一次缓存,多次和无缓存稍后做.

状态栏，大文件.

e XHIFC   

如何判断CString　中的某一个字符是否为指定字符？简单问题郁闷一天了。谢谢！ [问题点数：20分，
https://bbs.csdn.net/topics/40136271
if(sl.GetAt(n)=='x')

MSDEV.EXE
Microsoft Visual C++ 6.0
VC6
Git
Source Insight
....
一步一步熟悉精通.(如 VC6  每日提示：你知道吗... 启动时显示提示(S) 下一条(N) 关闭(C))

class CShowData : public CDialog
{
// Construction
public:
	int test_test_classwizard_add_var;
..}

计算机\Developer Studio Components
计算机\Registered ActiveX Controls

先用VC6-->工程-->添加到工程-->组件和控件
然后打开
D:\Program Files\Microsoft Visual Studio\Common\MSDev98\Gallery 进入
选中其中一个点属性 点打开文件位置即得上面二个目录路径.

vc6 group by access 
vc6按访问分组
public:
protected:
private:

vc6有AddtoGallery把带对话框的类从一个工程转到另一个工程,vc++.net怎么实现? [问题点数：20分]
https://bbs.csdn.net/topics/220060111
1、打开对话框工程,在classview中，右键对话框对应的类，选择Addtogallery；2、在新工程中，选择project菜单下的addtoproject--〉componentsandcontrols，插入1即可。
D:\Program Files\Microsoft Visual Studio\Common\MSDev98\Gallery\MsEdit_Wendy\Show Data.ogx

逻辑先简单到复杂，先大模块到小模块等。及时记录和进入状态等，不拖拉。

昨晚明济自己冲凉了。

别像永泰的播放控件换肤按钮滑动条等找不到了。

2020.03.20

C:\Users\Wendy\Downloads

cmd.exe 一些常见的启动参数介绍
https://www.jb51.net/article/99001.htm
cmd [{/c | /k}] [/s] [/q] [/d] [{/a | /u}] [/t:FG] [/e:{on | off}] [/f:{on | off}] [/v:{on | off}] [String]

参数
/c

执行 String 指定的命令，执行完后停止，会退出。例如：
/k

执行 String 指定的命令并继续，运行完会保持当前运行窗口及环境变量。例如：


ShellExecuteEx调用第三方程序
https://blog.csdn.net/mpp_king/article/details/80194563
调用第三方程序有很多方法, 包括system , WinExec , CreateProcess, ShellExecute, ShellExecuteEx。对比这几个启动进程的函数, 总结下来功能完善而且好用的就是
另外ShellExecuteEx执行cmd命令的时候, 命令行参数要加入/c 来让命令行执行完成后关闭自身。否则命令行进程会一直存在, WaitForSingleObject会一直等待。

比如:?ShellRun(L"cmd.exe", L"/c sc start UlogReport"); 启动一个服务。

VC下MFC程序自删除（自杀）几种方法的实践与探讨
https://blog.csdn.net/a316586261/article/details/5287495
在VC下做了个MFC的程序，想让他运行后，自动删除自己。在网上看了些资料，方法也有一些，都实践了一下，感觉对MFC的程序，使用cmd.exe可能更合适一些。其他的方法也蛮好，蛮经典的，不过我感觉用在MFC程序上就不太合适了。

[推荐] 应用程序启动后修改自身EXE文件或自删除EXE文件（附VC++6.0源码） [问题点数：40分]
https://bbs.csdn.net/topics/390506828
也是重写应用程序，但将使用次数写入到应用程序文件里面，每使用一次，就更新一下应用程序文件里的计数。

　　这种方案想来有几个问题：1.如果运行应用程序前做了备份，则每当使用次数完后，还可以用备份应用程序运行；2.我们知道，一个应用程序运行后，是不能修改自身EXE文件的。因此这个方案也只是想想而已，并不实用。但是要实现这种方案还是需要一定的技术，我闲来无事，就写了一个DEMO。

　　每2个问题，如何在应用程序运行时候修改自身EXE文件？答案也很简单，应用程序运行时加载另一个应用程序，自己退出，让另一个应用程序来修改EXE文件。既然应用程序运行时可以修改本身EXE文件，那么删除自身的EXE文件也是可以的，因此这种方法还可以用于卸载软件中，卸载软件时，可以使用此方法删除卸载软件本身。

　　好了，我们把目标明确一下：

　　1.第三方软件为SourceExe.exe，为了演示，我们还是自己模块第三方，自己写；

　　2.加载的应用程序为ExePackage.exe；

　　3.修改ExePackage.exe的程序为ExeHelper.exe。

　　将SourceExe.exe和ExeHelper.exe以资源形式加载进ExePackage.exe。启动ExePackage.exe时，ExePackage.exe并不显示界面，只将SourceExe.exe和ExeHelper.exe释放到临时目录，然后启动ExeHelper.exe，并告诉ExeHelper.exe一些必要的信息（DEMO中通过参数传递）。

　　ExeHelper.exe启动时，首先等待ExePackage.exe结束，这样才能修改ExePackage.exe文件。然后从ExePackage.exe文件末尾读取16个字节，测试是否匹配我们指定的数据（以区别这些数据是EXE文件本身的数据，还是我们添加的数据），这16个字节的最后4个字节保存的是使用次数，这样我们就可得到使用次数了，使用一次后，再将数据更新到EXE文件，最后就可以启动SourceExe.exe了。

　　原理很简单，但用到的技术还是不少的：

　　1.子进程等待父进程结束再处理事务（应用程序的自删除）；

　　2.父进程将句柄等信息传递给子进程；

　　3.将EXE中加载的资源释放为本地文件。

　　下面就开始上代码，代码很简单，就不一一解释了，只在需要说明的地方说明一下：

　　首先是SourceExe.exe的源码，作为第三方工具，代码很简单，就不多说了。

　　SourceExe.cpp：
C/C++ code

SetFilePointer(hFile, -16, NULL, FILE_END);



一个exe程序，如何保存数据到自身的可执行文件? 
https://bbs.csdn.net/topics/350038917
A.exe程序启动后，把自己复制一个副本A_COPY.exe出来，然后在运行过程中，把要记录的数据更新到副本中。
退出的时候，生成一个批处理，不断的删除A.exe，然后把A_COPY.exe改名为A.exe。最后程序退出了，批处理会执行成功
你自己菜了就不要乱说
#pragma comment(linker,"/SECTION:节名称,RWS") 


如何直接修改exe文件
https://blog.csdn.net/ly131420/article/details/8742839
 ?在以前学习的时候，无法想象在没有源码的时候如何对exe文件添加功能，觉得简直不可思议，在了解汇编和反编译的一些知识后，原来这种想法是可以实现的。我们需要对exe文件进行直接修改，把我们的代码直接写入exe文件，这样就能实现我们的功能了。
????当然，要想直接对exe文件进行直接修改必须有较好的汇编基础，对反汇编技术有一定的基础。否则会很茫然的。
????一般有两种方法可以对exe文件添加我们需要的功能。
????第一种是利用页面的对齐机制，因为一般来说，每节的最后一页多少都有空余的空间，也就是说最后一页一般不会被用完，由于下一个节开始的时候是要对齐页面的，所以这中间就由多余的空间让我们写代码了。我们可以利用工具直接把内存虚拟和文件偏移地址进行转换来得到文件偏移位置，这个位置就是我们最终要把机器码写入的地方。
????第二种是我们自己在exe文件种添加一个节，这个节专门用来写我们的代码。这样做好处更多，因为我们可以任意指定这个节的大小，而上一种方法是利用节之间的空隙来写我们的代码，如果代码较多的时候我们能就不好办了，所以第二种方法更具有通用性，但相对来说第一种更容易些。这里大家要注意一下，如果我们直接增加节的话，最好把节分配的空间设置为页面大小的整数倍，文件中分配空间的大小也分配成和虚拟空间的大小一样即可，一般文件的块对齐大小比页面的块对齐尺寸更小。
????还要注意的一点就是，如果我们对exe文件增加节以后，可能会出现exe文件无法运行的情况，这时候一般我们对exe文件进行重建就可以了。


VC 快速读取大文件的方法 
http://blog.sina.com.cn/s/blog_93491c750101hm8x.html

vc读取大文件的高效的方法

一个简单的更改.exe 文件里面的 函数（新手初始试，高手勿喷）
https://blog.csdn.net/liumeng305/article/details/24529325

分段读取大文件解决方案
http://www.myexception.cn/vc-mfc/333308.html

就正常保养机油机油滤芯空气滤芯我车首保之后都在外面做保养用美孚半合成机油性价比挺费用概300
https://club.m.autohome.com.cn/bbs/thread/9edaae870d42d1c3/84804279-1.html

49 percent of memory is in use. Count_BreakCList=83886080 
49 percent of memory is in use. Count_BreakCList=84934656 
49 percent of memory is in use. Count_BreakCList=85983232 
48 percent of memory is in use. Count_BreakCList=87031808 
48 percent of memory is in use. Count_BreakCList=88080384 
48 percent of memory is in use. Count_BreakCList=89128960 
The thread 0x1A60 has exited with code 0 (0x0).
No SetTimer DataCount=856703,Datainterval=85,ListIndex=100,GetIndex=856703
Already read this file(1). 
m_needreadfs=0. 

2020.03.19

书和操作分开

m_needreadfs=1. 
Read Files.... 
54 percent of memory is in use. Count_BreakCList=1048576 
55 percent of memory is in use. Count_BreakCList=2097152 
56 percent of memory is in use. Count_BreakCList=3145728 
58 percent of memory is in use. Count_BreakCList=4194304 
59 percent of memory is in use. Count_BreakCList=5242880 
60 percent of memory is in use. Count_BreakCList=6291456 
62 percent of memory is in use. Count_BreakCList=7340032 
The thread 0x24D4 has exited with code 0 (0x0).
63 percent of memory is in use. Count_BreakCList=8388608 
64 percent of memory is in use. Count_BreakCList=9437184 
66 percent of memory is in use. Count_BreakCList=10485760 
67 percent of memory is in use. Count_BreakCList=11534336 
69 percent of memory is in use. Count_BreakCList=12582912 
70 percent of memory is in use. Count_BreakCList=13631488 
71 percent of memory is in use. Count_BreakCList=14680064 
73 percent of memory is in use. Count_BreakCList=15728640 
74 percent of memory is in use. Count_BreakCList=16777216 
76 percent of memory is in use. Count_BreakCList=17825792 
77 percent of memory is in use. Count_BreakCList=18874368 
78 percent of memory is in use. Count_BreakCList=19922944 
80 percent of memory is in use. Count_BreakCList=20971520 
81 percent of memory is in use. Count_BreakCList=22020096 
83 percent of memory is in use. Count_BreakCList=23068672 
84 percent of memory is in use. Count_BreakCList=24117248 
86 percent of memory is in use. Count_BreakCList=25165824 
86 percent of memory is in use. Count_BreakCList=26214400 
88 percent of memory is in use. Count_BreakCList=27262976 
The thread 0x1C28 has exited with code 0 (0x0).
89 percent of memory is in use. Count_BreakCList=28311552 
90 percent of memory is in use. Count_BreakCList=29360128 
92 percent of memory is in use. Count_BreakCList=30408704 
93 percent of memory is in use. Count_BreakCList=31457280 
80 percent of memory is in use. Count_BreakCList=32505856 
The thread 0x22A4 has exited with code 0 (0x0).
The thread 0x17C8 has exited with code 0 (0x0).
The thread 0x237C has exited with code 0 (0x0).
The thread 0x13C0 has exited with code 0 (0x0).
75 percent of memory is in use. Count_BreakCList=33554432 
75 percent of memory is in use. Count_BreakCList=34603008 
75 percent of memory is in use. Count_BreakCList=35651584 
75 percent of memory is in use. Count_BreakCList=36700160 
75 percent of memory is in use. Count_BreakCList=37748736 
75 percent of memory is in use. Count_BreakCList=38797312 
75 percent of memory is in use. Count_BreakCList=39845888 
75 percent of memory is in use. Count_BreakCList=40894464 
75 percent of memory is in use. Count_BreakCList=41943040 
75 percent of memory is in use. Count_BreakCList=42991616 
75 percent of memory is in use. Count_BreakCList=44040192 
The thread 0x24F4 has exited with code 0 (0x0).
75 percent of memory is in use. Count_BreakCList=45088768 
75 percent of memory is in use. Count_BreakCList=46137344 
First-chance exception in MsEdit_Wendy.exe (KERNELBASE.DLL): 0xE06D7363: Microsoft C++ Exception.


  MEMORYSTATUS stat;
  GlobalMemoryStatus (&stat);
  TRACE("The MemoryStatus structure is %ld bytes long.\n",stat.dwLength);
  TRACE("It should be %d.\n", sizeof (stat));
  TRACE("%ld percent of memory is in use.\n", stat.dwMemoryLoad);



//  Sample output:
//  c:\>global
//  The MemoryStatus structure is 32 bytes long.
//  It should be 32.
//  78 percent of memory is in use.
//  There are   65076 total Kbytes of physical memory.
//  There are   13756 free Kbytes of physical memory.
//  There are  150960 total Kbytes of paging file.
//  There are   87816 free Kbytes of paging file.
//  There are  1fff80 total Kbytes of virtual memory.
//  There are  1fe770 free Kbytes of virtual memory.

#include <windows.h>

// Use to change the divisor from Kb to Mb.

#define DIV 1024
// #define DIV 1

char *divisor = "K";
// char *divisor = "";

// Handle the width of the field in which to print numbers this way to
// make changes easier. The asterisk in the print format specifier
// "%*ld" takes an int from the argument list, and uses it to pad and
// right-justify the number being formatted.
#define WIDTH 7

void main(int argc, char *argv[])
{
  MEMORYSTATUS stat;

  GlobalMemoryStatus (&stat);

  printf ("The MemoryStatus structure is %ld bytes long.\n",
          stat.dwLength);
  printf ("It should be %d.\n", sizeof (stat));
  printf ("%ld percent of memory is in use.\n",
          stat.dwMemoryLoad);
  printf ("There are %*ld total %sbytes of physical memory.\n",
          WIDTH, stat.dwTotalPhys/DIV, divisor);
  printf ("There are %*ld free %sbytes of physical memory.\n",
          WIDTH, stat.dwAvailPhys/DIV, divisor);
  printf ("There are %*ld total %sbytes of paging file.\n",
          WIDTH, stat.dwTotalPageFile/DIV, divisor);
  printf ("There are %*ld free %sbytes of paging file.\n",
          WIDTH, stat.dwAvailPageFile/DIV, divisor);
  printf ("There are %*lx total %sbytes of virtual memory.\n",
          WIDTH, stat.dwTotalVirtual/DIV, divisor);
  printf ("There are %*lx free %sbytes of virtual memory.\n",
          WIDTH, stat.dwAvailVirtual/DIV, divisor);
}




单读文件大小:88,724 KB
MsEdit_Wendy.exe 118,088 KB

读文件大小:428,300 KB
MsEdit_Wendy.exe 595,716 KB

再加文件88,725KB 时，先释放到40几M。

读文件大小:339,575 KB
MsEdit_Wendy.exe 482,292 KB 

正常
MsEdit_Wendy.exe 1,504 KB 未读数据时.

Clist_Break1.png 1,819,328 KB
Clist_Break2.png 2,91G
Clist_Break3.png 1,780,216 KB
....
Count_BreakCList:44040192 
Count_BreakCList:45088768 
The thread 0x17E0 has exited with code 0 (0x0).
Count_BreakCList:46137344 
First-chance exception in MsEdit_Wendy.exe (KERNELBASE.DLL): 0xE06D7363: Microsoft C++ Exception.
First-chance exception in MsEdit_Wendy.exe (MFC42D.DLL): 0xC0000005: Access Violation.
The program 'E:\wendy_work\MsEdit_Wendy\Debug\MsEdit_Wendy.exe' has exited with code 0 (0x0).


Count_BreakCList:48234496 
First-chance exception in MsEdit_Wendy.exe (KERNELBASE.DLL): 0xE06D7363: Microsoft C++ Exception.

char szTmp[100];
OutputDebugString(szTmp);

char temp[10] ;
	TRACE( "%s, tradeticker-- TickTime:%d %d, key: %u, price:%.4f, share:%d, TyadeType:%c, BrokerNo:%d\r\n", 
			temp, TradeTime,TradeTime2, Key, Price, Quantity, TyadeType, BrokerNo ) ;


目前这个e才4万多条，最多的时候一天有80万条

主要修改 1,详情菜单修改时间和增加key搜索 2,加大数据文件1M到1024M和清空功能 3,显示信息添加右键菜单复制和清空功能 4,中文改为英文 5,优化日志,操作界面显示,优化搜索,添加写数据文件功能等
6,优化数据处理函数HandleFrame_e


今后还是会读其它帧的

q key改为10进制， time改为显示time2


C语言将字符串转换成对应的数字(十进制、十六进制)【转】
https://yq.aliyun.com/articles/363504
问题1：讲一个十进制数字的字符串表示转换成对应的整数。举例：将“1234”转换成整数1234.
C代码  收藏代码
/*将字符串s转换成相应的整数*/  
int atoi(char s[])  
{  
    int i;  
    int n = 0;  
    for (i = 0; s[i] >= '0' && s[i] <= '9'; ++i)  
    {  
        n = 10 * n + (s[i] - '0');  
    }  
    return n;  
}  
 
        问题2：将一个十六进制数的字符串表示形式转换成对应的整数。所谓的十六进制数的字符串形式是指字符串只包含'0'-'9'或者'a'-'z'或者'A'-'Z'，前导“0x”或者“0X”是否出现都可以。
        要解决这个问题，还需要一个将大写字母转换成小写字母的工具函数：
C代码  收藏代码
/*将大写字母转换成小写字母*/  
int tolower(int c)  
{  
    if (c >= 'A' && c <= 'Z')  
    {  
        return c + 'a' - 'A';  
    }  
    else  
    {  
        return c;  
    }  
}  
 
        下面是转换函数：
C代码  收藏代码
//将十六进制的字符串转换成整数  
int htoi(char s[])  
{  
    int i;  
    int n = 0;  
    if (s[0] == '0' && (s[1]=='x' || s[1]=='X'))  
    {  
        i = 2;  
    }  
    else  
    {  
        i = 0;  
    }  
    for (; (s[i] >= '0' && s[i] <= '9') || (s[i] >= 'a' && s[i] <= 'z') || (s[i] >='A' && s[i] <= 'Z');++i)  
    {  
        if (tolower(s[i]) > '9')  
        {  
            n = 16 * n + (10 + tolower(s[i]) - 'a');  
        }  
        else  
        {  
            n = 16 * n + (tolower(s[i]) - '0');  
        }  
    }  
    return n;  
}  


十六进制数的字符串转换成对应的整数的函数

16进制的字符串转换整数的功能

int CEINFO::cmp_key(_Frame_e *pFrame_e)
{
	long lkey = atol(strKey);

	if (pFrame_e->Key == lkey) // wendy lTime
	{
		return 1;
	}
	else
	{
		return 0;
	}
}



q 还是先只管e ，时间，key ，price， quantity ，tradetype

q 回车关闭了对话框

2020.03.18

Cove  16:44:55
交易代码一般都是A\B\X xxxxx类型的，数字型的是股票，HIFC和HIZ18 这种纯英文或中英混合的大部分都是期权

Cove  16:45:33
当然也有少部分会是股票，不过都比较特殊

awendy  16:45:38
高手。

Cove  16:45:52
你可以看IGPEditor，这里面是有描述的

awendy  16:46:03






Processing ..\common\WTTCommon.idl
WTTCommon.idl
fatal error C1083: Cannot open source file: '..\common\WTTCommon.idl': No such file or directory
midl : command line error MIDL1003 : error returned by the C preprocessor (2)
执行 midl.exe 时出错.

TTDataFrame.dll - 1 error(s), 0 warning(s)


#include <stdlib.h>
 
int main(void)
{
	FILE *file;
	file = fopen("test.txt","w");//清空当前文件夹下的test.txt文件
	return 0;

}

ftruncate

很简单，在打开时指定打开方式为w就可以了。
比如，fp = fopen( "a.txt", "w" );
close(fp),这样文件就清空了。
当然，打开方式为"a"也可以。
删除文件用remove（"a.txt")函数。



q Key值不对，应该是递增的。

Andy  13:34:12
对了，界面的上字都用英文，中文如果给香港用都是乱码

awendy  13:35:30
哦。好的。

Andy  13:35:33
我用记事本打开还是有空行

q 我用记事本打开还是有空行
q 对了，界面的上字都用英文，中文如果给香港用都是乱码

C++中char字符串可以和CString比较吗？
https://zhidao.baidu.com/question/1668129209224613907.html
char* xx="efgh";
CString str=xx;
CString xxx="abdd";
if(str==xxx)

要怎么比较CString类型和Char类型两个字符串是否一样我用strcmp()这个函数不行啊
https://zhidao.baidu.com/question/556028055.html
#include<stdio.h>
#include<string.h>
#include<afx.h>
void main()
{
CString a("123");
char b[]={"123"};
if(strcmp(a,b)==0)
printf("2");
}
可以用啊。
CString src;
src="abcd";
char s[255]="abcd";
if(strcmp(src.GetBuffer(src.GetLength()),s)==0)
    AfxMessageBox("=");
你可以先把他们转换为同样的类型，再比较
用CString的Compare函数试试



q3,读这个文件读到一半就退出了

Andy 2020/3/17 星期二 10:08:16
读这个文件读到一半就退出了

awendy 2020/3/17 星期二 10:10:56
好的，我的也是一样。文件太大，我知道原因了。 STL标准库链表溢出了。



是HIFC 的e

	BOOL	Init( const char* pszFileName, DWORD nMaxFileSize=1024*1024*500, BOOL	bKeepFileOpen=FALSE ) ;  // wendy int  1024*500

!?CLog.m_nMaxFileSize	[.] CLog属性: log文件最大文件大小
*/
	DWORD			m_nMaxFileSize ;	// wendy int

BOOL CLog::Init( const char* pszFileName, DWORD nMaxFileSize, BOOL	bKeepFileOpen )  // wendy int
{
	if( pszFileName==NULL || strlen(pszFileName)<=0 )
		return FALSE ;

	m_szFileName = pszFileName ;
	m_nMaxFileSize = max( 1024, nMaxFileSize ) ;
	m_bKeepFileOpen = bKeepFileOpen ;

	return TRUE ;

}

CLog::CLog()
{
	m_pFile = NULL ;

	CString path ;
	CWrapperPath::GetExtPath( path ) ;

	m_szFileName.Format( "%slog.txt", path ) ;
	m_nMaxFileSize = 1024*1024*1024 ;			// wendy 1024*1024
	m_bKeepFileOpen = FALSE ;

}

	w_Log.Init("ReadMds.log",1024*1024*1024);  // wendy 1024*1024
	w_eLog.Init("eOfMds.log",1024*1024*1024);  // wendy 1024*1024


修改日志信息显示为未选中文件
void CMsEdit_WendyDlg::OnAddfile() 
{
	// TODO: Add your control notification handler code here

	CString cstrPathName,cstrFileName;
	CFileDialog fdlg(true, NULL, NULL, OFN_OVERWRITEPROMPT|OFN_NOCHANGEDIR, "(*.mds)|*.mds|All Files (*.*)|*.*||", NULL);
	int nRetDlgDoMo = fdlg.DoModal();
	if(nRetDlgDoMo==IDOK)
	{	
		//for (int i=0;i<m_filelist.GetCount();i++) //wendy test
		{
			if (m_filelist.FindString(-1,fdlg.GetPathName())>=0) // wendy nStartAfter=0 LB_ERR
			{
				AfxMessageBox("Already add this file.");
				return;
			}
		}
		cstrPathName.Format("%s",fdlg.GetPathName());
		m_filelist.AddString(cstrPathName);

		cstrFileName.Format("%s",fdlg.GetFileName());

	}
	else if (nRetDlgDoMo == IDCANCEL)
	{
		cstrFileName.Format("未选中文件");
	}
	s_Log.Format("OnAddfile FileName = %s",cstrFileName);
	SetBtnReadOrSearch(1);
}



xq1,为什么list里只有3个？ log那么多？log按搜索条件写 item 也写到log里

q2,这里有个问题， ‘X’帧你没解 ， 'X'是夜市帧，里面包含了普通帧， 比如‘A' ，'L' ，'e'

数据库，多媒体(音视)，网络，软件，其它。点到线，线到面，.....
文件数据处理:读写文件，STL，表格，日志，输入和生成各种文件等.

2020.03.17

CString类型字符串，怎样全部转为大写？？ [问题点数：20分，结帖人tohell]
https://bbs.csdn.net/topics/60172612
CString str = "abc";
str.MakeUpper();

如何使用CListBox的复选功能？GetSelItems() [问题点数：50分，结帖人NsKen]
https://bbs.csdn.net/topics/41964
int n = GetSelCount();
int *p = new int[n];
GetSelItems(n, p);
for(i = 0; i < n; i++)
{
  // do something with the selected item whose index is i
}
delete[] p;

CListBox控件如何让它支持 选择复制功能 [问题点数：10分，结帖人yang_fujiang]
https://bbs.csdn.net/topics/280024618
之后调用onCopy()：
CString source ="";
int iIndex =0;
iIndex = m_List_Msg.GetCurSel();
m_List_Msg.GetText(iIndex,source); //获取选择项内容
if(OpenClipboard()) 
{ 
HGLOBAL clipbuffer; 
char *buffer; 
EmptyClipboard(); 
clipbuffer=GlobalAlloc(GMEM_DDESHARE,source.GetLength()+1); 
buffer=(char *)GlobalLock(clipbuffer); 
strcpy(buffer,LPCSTR(source)); 
::GlobalUnlock(clipbuffer);
SetClipboardData(CF_TEXT,clipbuffer); 
CloseClipboard(); 
}// 将内容粘贴到剪切板上 1029 OK！！！


读取变搜索.

git checkout --help
file:///D:/Program%20Files/Git/mingw32/share/doc/git-doc/git-checkout.html

MFC子类化控件
https://blog.csdn.net/xuanyuanlei1020/article/details/52979738
子类化有两种类型: 实例子类化（instance subclassing）和全局子类化（global subclassing）。实例子类化是子类化一个窗口中的单一实例，全局子类化是把整个窗口子类化为一个特殊的类型。这里我们仅讨论单一实例子类化。

MFC窗口子类化
https://www.cnblogs.com/aishangxue/p/3531774.html
1）最简单的方法，可以通过传递GWL_WNDPROC调用SetWindowLong来改变窗口过程，可是这个函数还需要窗口句柄作为参数，而句柄只有在窗口创建成功后才合法，所以这种做法只能当不用改变默认WM_CREATE行为（以及一些窗口创建过程中的动作）的时候才适用。
2）窗口过程是在窗口类注册时确定的，要改变窗口函数就需要注册一个新类（参考DuiLib中的Edit空控件实现）：
首先调用系统API获得窗口类的详细信息，结果放在lpwcx指向的内存区中。
3）我们也可以用一种更柔和的方法，使用系统钩子布置好陷阱，然后静等窗口自投罗网。
首先在窗口创建之前（当然可以在应用程序对象 InitInstance过程中）安置一个系统钩子，钩子类型可以设为WH_CALLWNDPROC，这个钩子会在系统调用窗口过程之前调用，还可以设置线程ID为目标窗口创建线程。
钩子函数里我们主要工作就是筛选目标窗口（因为目标线程的所有窗口过程调用都会提前通知我们定义的钩子过程）。

筛选方式可以参考一下步骤：

实现子类化的一般方法
http://www.cppblog.com/aaxron/archive/2015/08/10/211517.aspx
实现子类化的一般方法
从上面可以看出，子类化主要使用几个API函数，这几乎是所有实现子类化相同的方法。相关API说明如下：
1、 WINUSERAPI LONG WINAPI GetWindowLongA(HWND hWnd, int nIndex);
WINUSERAPI LONG WINAPI GetWindowLongW(HWND hWnd,int nIndex);
2、 SetWindowLong 与 CallWindowProc 函数这不再列出来了，都是粉容易的！
使用 ComCtl32.dll version 6 实现窗口子类化
Windows XP 带的ComCtl32.dll version 6 提供了4个可以让创建子类化更简单，并且可以消除前面提到的缺陷的函数。这些新的函数封装了对多组参考数据（multiple sets of reference data）的管理操作，使得开发者能将精力集中到具体的程序特性而不是对子类的管理上。这些新的函数为：
SetWindowSubclass
GetWindowSubclass
RemoveWindowSubclass
DefSubclassProc
下面是对这些函数的描述。

【C++】DDX_Control、SubclassWindow和SubclassDlgItem的区别
https://blog.csdn.net/ssslpk/article/details/12174223
Subclass(子类化)是MFC中最常用的窗体技术之一。子类化完成两个工作：一是把窗体类对象attach到一个windows窗体实体中（即把一个窗体的hwnd赋给该类）。
另外就是把该类对象的消息加入到消息路由中，使得该类可以捕获消息。
而通常我们会碰到DDX_Control、SubclassWindow、SubclassDlgItem等，不同的子类化方法。首先先看下面的代码：
我们发现 DDX_Control()函数中调用了SubclassWindow()，再看SubclassWindow()里写了什么：
很显然，SubclassWindow()中调用了Attach()函数和reSubclassWindow()函数，由于SubclassWindow()函数是不可重载的，而PreSubclassWindow()函数是可重载的，所以我们经常重载PreSubclassWindow()函数，以致于窗口被子类化之前进行其它的必要的子类化，看下它原来的声明：
CWnd::PreSubclassWindow
virtual void PreSubclassWindow( );
而SubclassWindow又与SubclassDlgItem有什么区别？前者用于一切具有HWND的窗体，后者只限定于对话框控件
用法：在OnInitDialog中调用SubclassDlgItem将派生类的控件对象与对话框中的基类控件相连接，则这个基类控件对象变成了派生控件对象


MFC学习（五）DDX_Control关联资源
https://blog.csdn.net/sunnzhongg/article/details/56282825
DDX_Control函数管理着在对话框、表格视或控件视中被子类化的控件与对话框、
表格视或控件视的CWnd数据成员之间的数据交换。
其实说白了，就是将资源（如按钮）与类对象（CButton）关联在一起，也就是绑定起来。
DDX_Control的使 用：
在对话框类头文件中定义m_btnOK对象
CButton m_btnOK;
然后在DoDataExchange函数中添加以下语句
DDX_Control(pDX, IDOK, m_btnOK);
上边说了DDX_Control的用法，其实DDX_Control的原理很简单就是
获取控件ID的HWND句柄，然后调用Attach(hWnd)，将句柄绑定到对象上，最后初始化
对象，即调用对象类中重载的PreSubclassWindow()函数,之后再做一些显示工作。
原理很简单，接下来我用一段代码来代替DDX_Control语句，以便大家理解
在OnInitDialog()函数中添加以下语句，即可实现DDX_Control做的工作。(v ok)
HWND hWndCtrl;
GetDlgItem(IDOK, &hWndCtrl);
m_btnOK.SubclassWindow(hWndCtrl);
上边的代码关键在SubclassWindow函数，SubclassWindow是基类CWnd中的函数主要做的就是
Attach(hWnd)以及调用对象类中重载的PreSubclassWindow()方法,并做一些显示工作。

DDX_Control(pDX, IDC_LOG, m_loglist); 	m_loglist.SubclassDlgItem(IDC_LOG,this)	;
不能同时使用，二选一。


命令行语法格式中常用符号的含义
https://www.cnblogs.com/uakora/p/11809501.html
在描述命令行参数的时候，对其格式有些约定俗成的写法，各系统之间也有差别。一般采用的格式如下：

　　命令 <必选参数1|必选参数2> [-option {必选参数1|必选参数2|必选参数3}] [可选参数…] {(默认参数)|参数|参数}

 

命令格式中常用的几个符号含义如下：

　　尖括号< >：必选参数，实际使用时应将其替换为所需要的参数

　　大括号{ }：必选参数，内部使用，包含此处允许使用的参数

　　方括号[ ]：可选参数，在命令中根据需要加以取舍

　　小括号( )：指明参数的默认值，只用于{ }中

　　竖线|：用于分隔多个互斥参数，含义为“或”，使用时只能选择一个

　　省略号…：任意多个参数

 

说明：

大括号和尖括号的区别为：大括号中只能选择所列举的必选参数（或之一），尖括号中却需要根据实际替换必选参数

示例一：

　　命令语法：git help <name>

　　实际使用：git help config 或 git help branch 或 ...  (name被替换为实际的内容)

示例二：

　　命令语法：git stash {apply | pop}

　　实际使用：git stash apply 或 git stash pop (只能在必选参数apply或pop中选一个)



Git branch && Git checkout常见用法
https://www.cnblogs.com/qianqiannian/p/6011404.html

2. Git checkout

　　　　1. 操作文件  2. 操作分支

　　　　2.1 操作文件

　　　　　　2.1.1 git checkout filename 放弃单个文件的修改

　　　　　　2.1.2 git checkout . 放弃当前目录下的修改

　　　　2.2 操作分支

　　　　　　2.2.1 git checkout master 将分支切换到master

　　　　　　2.2.2 git checkout -b master 如果分支存在则只切换分支，若不存在则创建并切换到master分支，repo start是对git checkout -b这个命令的封装，将所有仓库的分支都切换到master，master是分支名，

　　　　2.3 查看帮助

　　　　　　git checkout --help

　　　　　　当然git checkout还有许多命令，但这些已经能满足我们日常开发所需

学习无他法，唯有持之以恒



Git 命令行的各种退出方式
https://blog.csdn.net/weixin_41287260/article/details/89813851
2.1 保存并退出：

（1）按 Esc 键退出编辑模式，英文模式下输入 :wq ，然后回车(write and quit)。


（2）按 Esc 键退出编辑模式，大写英文模式下输入 ZZ?，然后回车。(v ok)

2.2 
不保存退出：

按 Esc 键退出编辑模式，英文模式下输入 :q! ，然后回车。


按 Esc 键退出编辑模式，英文模式下输入 :qa! ，然后回车。


git reset 使用及回滚
https://blog.csdn.net/edric1261234/article/details/82796506
目录

一、git reset 参数

1. --soft ?

2.? --mixed ?

3.? --hard ?

二、 如何回滚文件

1.?修改完，还未执行git add?

2.使用git add 提交到暂存区，还未commit之前

3.已经git commit，还未git push

4.已经git push??
--mixed  
是reset的默认参数,移动head指针，改变暂存区内容，但不会改变工作区 
如何回滚文件
1. 修改完，还未执行git add 
git checkout .
使用暂存区的文件覆盖工作区，所以执行完git add .之后，再执行该命令是无效的  
git checkout .和git add .是一对反义词
2.使用git add 提交到暂存区，还未commit之前
git reset  先用Head指针覆盖当前的暂存区内容
git checkout . 再用暂存区内容覆盖工作区内容
或者使用
git reset --hard 直接使用head覆盖当前暂存区和工作区
3.已经git commit，还未git push
git reset --hard origin/master (v ok)
从远程仓库把代码取回来，然后覆盖本地仓库、本地暂存区和工作区  
或者使用
git reset --hard last_commit_id
覆盖本地仓库、暂存区和工作区，其中查看last_commit_id命令为
git log
  或者使用
git reset --mixed last_commit_id  
覆盖本地的暂存区，再执行
git checkout . 覆盖本地工作区
4.已经git push  
  那就没办法了


Your branch is ahead of 'origin/master' by 2 commits.
https://www.cnblogs.com/ckAng/p/10640770.html
遇到这种问题，表示在你之前已经有2个commit而没有push到远程分支上，所以需要先git push origin **将本地分支提到远程仓库。
也可以直接git reset --hard HEAD~x解决 ,这里的x表示的就是在这之前已经有多少次的提交，这句命令的意思就是直接回退到x 个commit之前（这两次提交所改动的代码都没有了，慎用）


在git提交环节，存在三大部分：working tree, index file, commit
https://blog.csdn.net/lksodit_yiyi/article/details/8767150
这三大部分中：
working tree：就是你所工作在的目录，每当你在代码中进行了修改，working tree的状态就改变了。
index file：是索引文件，它是连接working tree和commit的桥梁，每当我们使用git-add命令来登记后，index file的内容就改变了，此时index file就和working tree同步了。
commit：是最后的阶段，只有commit了，我们的代码才真正进入了git仓库。我们使用git-commit就是将index file里的内容提交到commit中。
总结一下：
git diff：是查看working tree与index file的差别的。
git diff --cached：是查看index file与commit的差别的。
git diff HEAD：是查看working tree和commit的差别的。（你一定没有忘记，HEAD代表的是最近的一次commit的信息）
git status
#很明显可以知道：
Changes to be committed表示已经存在于index file里，但尚未提交。
Changed but not updated表示在working tree已经做修改，但还没有使用git add登记到index file里。


交际: 1,不讲敏感话题(黄文男女孩). 2,不聊利益事(杨秋兴囤货疫情). 3,注意频率节奏不能过（年年有余细卫哥). 4,久不聊一聊相关(黄新明相片)
5,微Q少聊色暴注意频率. 6,sln转换dsw对比.c.h.r等文件. 7,
awendy:
学习才是硬道理。

高信:
牛逼


awendy:
将以前的： 股票都能做好，还有什么不能做好呢？


awendy:
改为：学习(编程)都能做好，还有什么不能做好呢？


高信:
niubility

8,愿有送皮带一天. 9,看懂,控件,200个类,算法...java,android. 10,早上急下楼梯差点摔因口罩雾气.


<<<<<<< HEAD
		m_loglist.AddString(s_Log);
		w_Log.Log(s_Log);
		s_Log="";
=======
		s_Log="";

>>>>>>> 6a982e05c2ea58ca638a64ccadb6fe3283b33350

merge失败，you need to resolve

commit no push

git did not exit cleanly (exit code 1) (4321 ms @ 2020/3/16 星期一 8:11:37)


2020.03.16

CListBox的AddString 排序问题
https://blog.csdn.net/robinson_911/article/details/20701273
CListBox默认对各项进行排序，在属性中把sort改为false就解决问题了，或者用InsertString()，而不是 AddString()。InsertString() 不会导致 LBS_SORT 清单进行排序

WM_DRAWITEM，DrawItem的一些总结
原创woshiyuanlei 最后发布于2015-06-05 13:45:01 阅读数 2040  收藏
展开
1、

? ? 当在MFC中要对某个控件自绘时，就需要重写DrawItem或者OnDrawItem函数，要实现重绘：

? ? 首先要允许重绘:

? ?1）可以在控件属性中设置（网上很多，自己搜吧）?

? ? 2）在控件类中实现，

? ? 比如我实现了class CMyButton:public ?CButton自己的按钮类，然后在CMyButton中重写PreSubclassWindow函数

? ? 然后添加__super::PreSubclassWindow();SetButtonStyle(GetButtonStyle()|BS_OWNERDRAW);

? ?其次要实现重绘:

? ?当然就要重载DrawItem了(listbox控件重载OnDrawItem)

?? 需要注意的是:

? ?重载DrawItem后不能再有WM_PAINT或WM_ERABKGND(好像是这样拼写的)消息映射，否则，DrawItem函数将不会运行(具体为什么可以网上搜搜，MFC绘图的顺序就知道了)



2、

? 当在win32实现控件自绘时，需要在WndProc中相应WM_DRAWITEM消息，而相应的这个消息是在总的消息循环中，当自控件有自己的消息循环时，不管WndProc还是子空间自己的消息循环都不能相应WM_DRAWITEM消息，因此要响应此消息，则子控件默认使用跟窗体一样的消息处理函数WndProc



符:

设置子控件自己的消息循环:?SetWindowLong(hSubWnd,GWL_WNDPROC,(LONG)ButtonProc);
――――――――――――――――
版权声明：本文为CSDN博主「woshiyuanlei」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/woshiyuanlei/article/details/46375701


MFC-自绘控件（CStatic与CEdit）
https://blog.csdn.net/wyansai/article/details/50985319
主要是在主窗口中的OnCtlColor函数中进行自绘
HBRUSH CSelfDrawDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
	// TODO:  在此更改 DC 的任何特性
	if (nCtlColor == CTLCOLOR_STATIC) {
		pDC->SetBkMode(TRANSPARENT);
		if (pWnd->GetDlgCtrlID() == IDC_STATIC1) {
			pDC->SetTextColor(RGB(200, 200, 100));
		}
		return (HBRUSH)GetStockObject(NULL_BRUSH);
	}
	// TODO:  如果默认的不是所需画笔，则返回另一个画笔
	return hbr;
}
二、check box 与 radio box

改变背景透明
HBRUSH CSelfDrawDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
	HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
	if (nCtlColor == CTLCOLOR_BTN || nCtlColor == CTLCOLOR_STATIC) {
		pDC->SetBkMode(TRANSPARENT);
		hbr = (HBRUSH) ::GetStockObject(NULL_BRUSH);
 
		UINT id = pWnd->GetDlgCtrlID();
		if (id == IDC_RADIO1 || id == IDC_CHECK1)
		{
			CRect rc;
			pWnd->GetWindowRect(&rc);
			ScreenToClient(&rc);
			CDC* dc = GetDC();
			//把父窗口背景图片先画到按钮上
			pDC->BitBlt(0, 0, rc.Width(), rc.Height(), dc, rc.left, rc.top, SRCCOPY);
			ReleaseDC(dc);
			return hbr;
		}
		if (nCtlColor == CTLCOLOR_STATIC) {
			pDC->SetTextColor(RGB(255, 200, 0));
		}
		return hbr;
	}
	
	return hbr;
}
三、CEdit

主要是继承CEdit这个类，简单的自绘一下边框的颜色

CSkinEdit.h

#pragma once
#include "afxwin.h"
class CSkinEdit :
	public CEdit
{
public:
	CSkinEdit();
	~CSkinEdit();
	DECLARE_DYNAMIC(CSkinEdit)
protected:
	DECLARE_MESSAGE_MAP()
public:
	BOOL m_bTracking;
	BOOL m_bHover;
	BOOL m_bFocus;
	CBrush m_ClientBrush;
	CBrush m_hOrderBrush;
	CBrush m_HotOrderBrush1;
	CBrush m_HotOrderBrush2;
public:
	LRESULT OnMouseLeave(WPARAM wParam, LPARAM lParam);
	LRESULT OnMouseHover(WPARAM wParam, LPARAM lParam);
	void OnMouseMove(UINT nFlags, CPoint point);
	void OnSetFocus(CWnd* pOldWnd);
	void OnKillFocus(CWnd* pNewWnd);
	void OnNcPaint();
	void OnPaint();
	void DrawBorder();
};
 
CSkinEdit.cpp
#include "stdafx.h"
#include "SkinEdit.h"
 
IMPLEMENT_DYNAMIC(CSkinEdit, CEdit)
 
CSkinEdit::CSkinEdit()
{
	m_bTracking = m_bHover = m_bFocus = FALSE;
	m_ClientBrush.CreateSolidBrush(RGB(0,0,200));
	m_hOrderBrush.CreateSolidBrush(RGB(0, 100, 200));
	m_HotOrderBrush1.CreateSolidBrush(RGB(255, 255, 0));
	m_HotOrderBrush2.CreateSolidBrush(RGB(255, 200, 0));
}
 
CSkinEdit::~CSkinEdit()
{
	DeleteObject(m_ClientBrush);
	DeleteObject(m_hOrderBrush);
	DeleteObject(m_HotOrderBrush1);
	DeleteObject(m_HotOrderBrush2);
}
 
 
BEGIN_MESSAGE_MAP(CSkinEdit, CEdit)
	ON_WM_NCPAINT()
	ON_MESSAGE(WM_MOUSELEAVE, OnMouseLeave)
	ON_MESSAGE(WM_MOUSEHOVER, OnMouseHover)
	ON_WM_MOUSEMOVE()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
END_MESSAGE_MAP()
 
 
 
// CSkinEdit 消息处理程序
void CSkinEdit::OnMouseMove(UINT nFlags, CPoint point)
{
	if (!m_bTracking)
	{
		TRACKMOUSEEVENT tme;
		tme.cbSize = sizeof(tme);
		tme.hwndTrack = m_hWnd;
		tme.dwFlags = TME_LEAVE | TME_HOVER;
		tme.dwHoverTime = 50;
		m_bTracking = (bool)_TrackMouseEvent(&tme);
	}
 
	CEdit::OnMouseMove(nFlags, point);
}
LRESULT CSkinEdit::OnMouseLeave(WPARAM wParam, LPARAM lParam)
{
	m_bTracking = FALSE;
	m_bHover = FALSE;
	DrawBorder();
	return 0;
}
 
LRESULT CSkinEdit::OnMouseHover(WPARAM wParam, LPARAM lParam)
{
	m_bHover = TRUE;
	DrawBorder();
	return 0;
}
void CSkinEdit::OnSetFocus(CWnd* pOldWnd)
{
	CEdit::OnSetFocus(pOldWnd);
	m_bFocus = TRUE;
	DrawBorder();
}
 
void CSkinEdit::OnKillFocus(CWnd* pNewWnd)
{
	CEdit::OnKillFocus(pNewWnd);
	m_bFocus = FALSE;
	DrawBorder();
}
void CSkinEdit::OnNcPaint()
{
	CEdit::OnNcPaint();
	DrawBorder();
}
void CSkinEdit::OnPaint()
{
	CEdit::OnPaint();
	DrawBorder();
}
 
void CSkinEdit::DrawBorder()
{
	CDC * dc = GetWindowDC();
	CRect rc;
	GetWindowRect(&rc);
	rc = CRect(0, 0, rc.right - rc.left, rc.bottom - rc.top);
	if (m_bHover) {
		dc->FrameRect(rc, &m_HotOrderBrush1);
		rc.InflateRect(-1, -1);
		dc->FrameRect(rc, &m_HotOrderBrush2);
	}
	else if (m_bFocus) {
		dc->FrameRect(rc, &m_ClientBrush);
		rc.InflateRect(-1, -1);
		dc->FrameRect(rc, &m_hOrderBrush);
	}
	else {
		dc->FrameRect(rc, &m_ClientBrush);
		rc.InflateRect(-1, -1);
		dc->FrameRect(rc, &m_hOrderBrush);
	}
	ReleaseDC(dc);
	dc = NULL;
}


关于VC中DrawItem()函数 [问题点数：0分]
https://bbs.csdn.net/topics/19523
我创建了一个以CButton为基类的按钮，编写DrawItem函数时存在一些疑问(1)。一般windows的按钮，平时显示是一种状态，多用鼠标左键按下去时是另一种状态，这时如果不松开鼠标而移动鼠标，当鼠标离开按钮时，按钮又还原为原来的样子，这种情况该如何实现？(2)对于CCombox的DrawItem()函数，如果要绘制在整个组合框的外面画一个框之类的装饰物该怎么办？(3)许多程序中的按钮都有这样的功能（如IE的“后退”、“前进”大按钮）：多鼠标移动按钮上时显示鲜艳一点的图象，鼠标离开时又还原为暗一点的图象，该如何实现？

用Timer太……了吧，传统做法应该是在OnLButtonDown中SetCapture，在OnMouseMove中判断鼠标是否在按钮区域内以及左键有否按下并设置按钮位图，在OnLButtonUp中ReleaseCapture。不过最简单的方法还是用CBitmapButton。

VC中DrawItem重绘及背景图片问题 [问题点数：20分，结帖人kawayi_kai]
https://bbs.csdn.net/topics/310105039
1、定义一个成员变量保存图片路径或是图片内容，写一个接口函数来动态设置图片路径或图片内容，DrawItem的时候根据路径读取图片或显示设置好的图片内容
2、两种方法：
   重载对话框OnCtrColor函数，将所有控件背景画刷设置为NULL_BRUSH
   重载控件或子类化控件，将控件背景画为对应的对话框背景内容

第一个一定要把控件的属性改为OWNERDRAW
第二个就是OnCtlColor 
nCtrlID = IDC_STATIC 就行了
如果你将按钮的属性修改成了OWNERDRAW，那么你必须在你子类（从CButton）重载DrawItem(LPDRAWITEMSTRUCT)函数，
实现你自己的重绘代码，否则MFC会调用基类CButton的DrawItem函数，不出叉才怪


怎么才能让DrawItem函数被调用？ [问题点数：0分]
https://bbs.csdn.net/topics/457341
我重载了CStatusBar的DrawItem函数，但发现他从来没有被调用
?什么？是StatusBar吗？
只有an owner-draw button control, combo-box control, list-box control, or menu
可以具有调用OnDrawItem的风格
否则是不能调用这个函数的
好像你的那个就不是这其中之一吧，当然无法调用了

为什么非要使用DrawItem？
其实，你只要把一个控件的Parent设置成StatusBar即可在状态条上显示任何控件。
这个方法也适用于其他控件

DrawItem
https://blog.csdn.net/jiftlixu/article/details/4893505
今天从CButton派生了一个类CUIButton，主要用于自绘，按照基本的流程，重写DrawItem方法。

步骤如下：点击CUIButton按钮，在右键弹出菜单中选择“add windows message Handler"，

找到DrawItem，为其添加消息映射，添加的代码如下：

void CUIButton::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct)

结果在使用到CUIButton的地方用SubClassDlgItem就会出问题。

后来调试发现，不应该按照上面的添加此消息的映射，而是为CUIButton类重写DrawItem函数，添

加方法：

在类CUIButton右键，在弹出菜单中选择"Add Virtual Function"，弹出的添加虚函数框中选

择"DrawItem"，向导为我们生成的代码如下：

void CUIButton::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)

在这里添加所需的自绘代码就ok了
附： how to implement control to self-draw

1、从CButton类派生自己的CUIControl类

2、借助于MFC向导生成工具，为期添加虚函数DrawItem()和OnEraseBkgnd()。

     注意：DrawItem()是控件重定义的函数，不是OnDrawItem()。

3、在DrawItem()中近控件的自绘处理，这里给出一个实例代码，用于一个自定义Button，在

     Button上面绘图：
4、为OnEraseBkGround()添加代码。这里很简单，直接返回True即可：
5、在你的对话框中使用CUIButton按钮，首先在dialog资源中添加一个按钮（CButton）。
6、在对话框类的头文件中定义一个成员CUIButton m_CtlUIBtn；注意变量的类型是CUIButton而
    不是CButton
7 、在OnInitDialog中用SubClass技术：


MFC CStatic控件在DrawItem中自绘
https://blog.csdn.net/xuanyuanlei1020/article/details/52698635
转载轩辕泪1020 最后发布于2016-09-29 09:28:39 阅读数 2561  收藏
展开
转载自：也已时过境迁的MFC CStatic控件在DrawItem中自绘

实现PreSubclassWindow
void CStaticHref::PreSubclassWindow()
{
// TODO: Add your specialized code here and/or call the base class

DWORD dwStyle = GetStyle();  
SetWindowLong(GetSafeHwnd(),GWL_STYLE,dwStyle | SS_OWNERDRAW);
//ModifyStyle(NULL, SS_OWNERDRAW);

CStatic::PreSubclassWindow();
}

在virtual void DrawItem(LPDRAWITEMSTRUCT /*lpDrawItemStruct*/);中完成相关绘制

确保消息映射中不能有：ON_WM_PAINT（也可以直接在OnPaint中绘制）、ON_WM_DRAWITEM 消息，否则DrawItem函数不会被调用

注：第二步的是DrawItem而非OnDrawItem。OnDrawItem是ON_WM_DRAWITEM消息的处理函数，是处理子控件发送过来的自绘消息的


解决C++中DrawItem()函数不被调用的问题
原创读不懂的下卷 最后发布于2013-10-15 15:18:55 阅读数 3168  收藏
展开
? 当在自绘一个控件时，比如自绘一个CMyButton的时候，在DrawItem()中改变了button的颜色，但是在程序执行时，DrawItem()函数并没有被执行，原因在于按钮的类型并不是BS_OWNERDRAW,所以我们需要把它改为“所有者绘制”。

解决方法：

可以重载一个PreSubclassWindow()函数，在该函数中调用ModifyStyle(）函数来设置类型，比如：

void?CMyButton::PreSubclassWindow()

{
CButton::PreSubclassWindow();??

ModifyStyle(0,?BS_OWNERDRAW);?
}
――――――――――――――――
版权声明：本文为CSDN博主「读不懂的下卷」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/ssslpk/article/details/12750251

DrawItem（）和WM_DRAWITEM
https://blog.csdn.net/lzrocking/article/details/7934831
如果我们要重写一个CButton取名为CMyButton，我们可以重写CMyButton的DrawItem（）函数来实现我们的需求，但CMyButton：：DrawItem（）是在什么时候调用呢？它是在它的宿主类的OnDrawItem（）中被调用，OnDrawItem（int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct ）正是对WM_DRAWiTEM的相应函数。

宿主类可以根据nIDCtl来判定是哪个子控件。其实我们可以在OnDrawItem函数里对子控件进行绘制，但是有很多的子控件看起来不好，所以我们应该在子类的DrawItem对子类绘制，例如CMyButton::DrawItem。所以可以这样理解，OnDrawItem是画窗口中的子控件的，因为它的入口参数LPDRAWITEMSTRUCT带入不同子控件的相关参数，而且，你得把字控件设置成“自画”类型，才会调用到OnDrawItem。

当自绘按钮(owner-draw button)，下拉列表框(combo box)，列表框(list box)视觉属性，或者菜单发生变化时，框架为他们的owner调用OnDrawItem(发送WM_DRAWITEM)，在宿主类调用子类的DrawItem(发送WM_DRAWITEM消息)。我们可以重载子类的DrawItem可以绘制自己需要的控件，不是所有设置成自画类型的控件都会调用父窗口的OnDrawItem，例如ListBox的自画，你就必须重载CListBox的DrawItem方法和MeasureItem方法才可以，但象菜单，按钮等的自画则会调用OnDrawItem。在SDK中，子类是不可能受到WM_DRAWITEM，在MFC中可以，这是类的设计者设计的(反射)，这的确不错。


MFC OnDrawItem方法没有执行
https://blog.csdn.net/zhouyingge1104/article/details/103641357
MFC项目，已经通过向导添加了OnDrawItem方法，也定义好了要自定义处理的控件ID

void CStartCheckDlg::OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	if(
		nIDCtl == IDC_BUTTON1||
		nIDCtl == IDC_BUTTON2
	  ){
		//...
      }
}
但是实际运行时，OnDrawItem没有执行。

想了一会儿，原来是控件的“所有者绘制”这个属性没有设置。

在设计器中右击控件->属性->样式，勾选“所有者绘制”。
再次运行，OnDrawItem方法正常执行，按钮控件批上了新的样式。

请问DrawItem方法什么时候被调用 [问题点数：100分，结帖人laomai]
https://bbs.csdn.net/topics/40390920
DrawItem不会被执行，CButton自画要在父窗口重载OnDrawItem消息，有些自画是必须在DrawItem中的CHeaderCtrl；
规律好像是凡是需要MeasureItem的都要DrawItem，凡是不需要MeasureItem的，就重载父窗口的OnDrawItem，不过不敢肯定；
有一点可以肯定就是MFC中有些类的DrawItem里面只有一句就是ASSERT(FALSE)，就是一定会出错的意思，这些类一定要重载DrawItem，而不是父窗口的OnDrawItem

MFC控件的SubclassDlgItem
https://www.cnblogs.com/lujin49/p/5345313.html
要在程序中创建新设计的控件，显然不能用自动创建的办法，因为对话框模板对新控件的特性一无所知．程序可以用手工方法创建控件，在调用派生类的Create函数时，派生类会调用基类的Create函数创建控件．用Create函数创建控件是一件比较麻烦的工作，程序需要为函数指定一大堆的控件风格以及控件的坐标和ID．特别是控件的坐标，没有经验的程序员很难确切地安排控件的位置和大小，往往需要反复调整．利用MFC的CWnd::SubclassDlgItem提供的动态连接功能，可以避免Create函数的许多麻烦，该函数大大简化了在对话框中创建派生控件的过程．
　　大家知道，在用手工方法创建控件时，先要构建一个控件对象，然后再用Create函数在屏幕上创建控件窗口，也就是说，控件的创建工作是由控件对象完成的．动态连接的思路则不同，SubclassDlgItem可以把对话框中已有的控件与某个窗口对象动态连接起来，该窗口对象将接管控件的消息处理，从而使控件具有新的特性．SubclassDlgItem函数的声明为
BOOL SubclassDlgItem( UINT nID, CWnd* pParent );
　　参数nID是控件的ID，pParent是指向父窗口的指针．若连接成功则函数返回TRUE，否则返回FALSE．
　　综上所述，要在程序中使用派生控件，应该按下面两步进行：
在对话框模板中放置好基类控件．
在对话框类中嵌入派生控件类的对象．
在OnInitDialog中调用SubclassDlgItem将派生类的控件对象与对话框中的基类控件相连接，则这个基类控件变成了派生控件．
　　例如，如果要在对话框中使用新设计的编辑框控件，应先在对话框模板中的合适位置放置一个普通的编辑框，然后，在OnInitDialog函数中按下面的方式调用SubclassDlgItem即可：
BOOL CMyDialog::OnInitDialog()

{
CDialog::OnInitDialog();
m_MyEdit.SubclassDlgItem(IDC_MYEDIT, this);
return TRUE;
}
还有个前提  就是edit1还在生命周期内。你可以试试在主类里建个CEditnew类的指针 的成员变量，然后在初始化里给这个指针赋值为new CEditnew()  后面照旧。试试
比如成员变量 CEditnew m_myEdit;
然后在初始化中：m_myEdit = new CEditnew();
m_myEdit->SubclassDlgItem(IDC_EDIT1,this);

m_myEdit->ShowWindow(SW_SHOW);

这样试试。
 


subclassdlgitem
https://baike.baidu.com/item/subclassdlgitem/3693947?fr=aladdin
该函数用来子类化一个控件.
Subclass(子类化)是MFC中最常用的窗体技术之一。子类化完成两个工作：一是把窗体类对象attach到一个windows窗体实体中（即把一个窗体的hwnd赋给该类）。另外就是把该类对象的消息加入到消息路由中，使得该类可以捕获消息。
SubclassDlgItem可以把对话框中已有的控件与某个窗口对象动态连接起来，该窗口对象将接管控件的消息处理，从而使控件具有新的特性．SubclassDlgItem函数的声明为
BOOL SubclassDlgItem( UINT nID, CWnd* pParent );
参数nID是控件的ID，pParent是指向父窗口的指针．若连接成功则函数返回TRUE，否则返回FALSE．
综上所述，要在程序中使用派生控件，应该按下面两步进行：
在对话框模板中放置好基类控件．
在对话框类中嵌入派生控件类的对象．
在OnInitDialog中调用SubclassDlgItem将派生类的控件对象与对话框中的基类控件相连接，则这个基类控件对象变成了派生控件对象


Command line error D2016 : '/O2' and '/GZ' command-line options are incompatible
https://zhidao.baidu.com/question/80138398.html
'/GZ' __stdcall calling convention
'/O2' maximize speed
这两个 编译开关 不兼容.
编译命令行 去掉 速度优化 '/O2'

VS2010 不生成pdb 和ilk文件
https://blog.csdn.net/WloveqB/article/details/50457766
不生成pdb文件,Generate Debug Info禁止掉,调试信息
不生成ilk文件,Enables incremental Linking 禁止掉(增长链接)

求教如何让编译时不产生.pch文件，太大了占硬盘 [问题点数：0分]
https://bbs.csdn.net/topics/70329395
pch一般情况下有助于加快增量开发时编译的效率,最好别关。方法是在工程设置里关闭预编译头生成:
project set->c/c++ ->precompiled header。默认是使用stdafx.h生成预编译头（use precompiled header file)改为not using precompiled headers

mfc自定义按钮
https://download.csdn.net/download/ymv852147/8405845
所需积分/C币：3 上传时间：2015-01-29 资源大小：28.91MB

MFC开发小例子（界面开发、自定义按钮、PNG图像...
https://download.csdn.net/download/qq_22300209/9741095
所需积分/C币：9 上传时间：2017-01-19 资源大小：14.01MB

一个MFC的自定义按钮类
https://download.csdn.net/download/l350290017/4824866
所需积分/C币：15 上传时间：2012-11-29 资源大小：8KB

好用的MFC自定义按钮CButton
https://download.csdn.net/download/dingkun721/10788147
所需积分/C币：16 上传时间：2018-11-16 资源大小：325KB

MFC自定义界面包括按钮标签等，用于工控，展示等
https://download.csdn.net/download/hhhh63/6961889
所需积分/C币：12 上传时间：2014-02-25 资源大小：225KB

MFC自定义按钮
https://download.csdn.net/download/lh806732/8221891
所需积分/C币：9 上传时间：2014-12-03 资源大小：704KB

MFC自绘Button按钮分析和实现
https://blog.csdn.net/c_base_jin/article/details/53726209
自绘制需要的两个基础步骤：
1.控件类型设置为 BS_OWNERDRAW
2.添加WM_DRAWITEM消息响应函数或者重写DrawItem函数。

MFC自定义按钮的实现
https://blog.csdn.net/liuyi1207164339/article/details/46679809
但是对于按钮来说上述方法是不起作用的，只能寻找其他解决办法。实际上，要想改变按钮的背景色和文本颜色，需要使用CButton类的一个成员函数DrawItem,该函数的声明如下：// Overridables (for owner draw only)

以上代码就是对对话框的进行了一个布局，这样就看起来比较规整，按钮的大小和间隔都是一样的！
 
//对话框顶部凸起部分的实现
 
CPoint pts[7] = { CPoint(0, 10), CPoint(40, 10), CPoint(50, 0), CPoint(60, 10), CPoint(250, 10), CPoint(250, 315), CPoint(0, 315)};
 
//创建一个多边形区域，以上面定义的七个顶点为边界
 HRGN poloy = CreatePolygonRgn(pts, 7, ALTERNATE);
 CRgn rgn;
 rgn.Attach(poloy);
 SetWindowRgn(rgn,TRUE); //设置窗口的多边形形状
 rgn.Detach();
 
以上代码就可以把对话框设置成各种形状了，是不是很Cool ^_^。


c++中 try 和catch的用法
https://zhidao.baidu.com/question/148731691.html
今天看了msdn，里面有个
catch(object^) 什么意思。。。。
我想要测试一个堆栈弹出空值是否会报错，如果没有报错，我要把它打印出来。问题在于，我发现这个堆栈他没有报错，而我要把这个错误打印出来的时候，程序他出一个框说程序出错了，所以下一句（打印命令）无法执行。
请问可以利用try和catch直接捕获这个出错，让他不中止程序好让我执行下一条命令（打印出下一句话）吗。
那要用什么方法？

什么时候使用Try Catch(转)
https://www.cnblogs.com/huangfenggu/p/4503803.html
try{A程序块} catch{Exception e}{B程序块} 。。。。。  
  
A程序块比较有可能会出错的地方，B则是如果A中有了错误，进行的处理。就好比，一个流水线上，如果有个地方有个产品堵住了不通了，如果没人处理，则整个流水线就没法动作了，要想保证整个流水线的运作则要有人把这个产品给处理了。try语句就是对A程序块的语句进行捕捉有可能出错的地方，相当于流水线上那个检查的人，catch语句则是处理的.  
  
什么情况下需要用try-catch呢，那就是不使用这种try结构时，代码报错退出就无法继续执行。有的代码出错就应该退出，有的出错尚可以补救，就不应该退出。对于这种出错不应该退出的就需要使用这种结构，在catch中进行补救。例如，写入一个日志文件，如果这个日志文件被锁定或者占用，那么写入就会出错退出，但是我们并不想看到这样的情况，我们完全可以换一个名字再写入。  

慎用try catch
https://www.jianshu.com/p/a108e2bf33ef
慎用try catch
try catch最适合处理那些我们无法控制的错误，如I/O操作等，后端nodeJs或java读取I/O操作比较多比如读数据库，所以用try catch比较多。前端可以用在上传图片、使用别人的js库报错、async await同步调接口等地方适用。

作者：前端妹子ice
链接：https://www.jianshu.com/p/a108e2bf33ef
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

try catch 如何正确使用(java)
https://jingyan.baidu.com/article/08b6a5916a455614a80922cd.html

try catch 用法(java)
https://blog.csdn.net/this_tall_people/article/details/76512417

C++异常处理（try catch throw）完全攻略
http://c.biancheng.net/view/422.html
鉴于上述原因，C++ 引入了异常处理机制。其基本思想是：函数 A 在执行过程中发现异常时可以不加处理，而只是“出一个异常”给 A 的调用者，假定为函数 B。
C++ 通过 throw 语句和 try...catch 语句实现对异常的处理。throw 语句的语法如下：
throw  表达式;
该语句出一个异常。异常是一个表达式，其值的类型可以是基本类型，也可以是类。
try...catch 语句的语法如下：
try {
    语句组
}
catch(异常类型) {
    异常处理代码
}
...
catch(异常类型) {
    异常处理代码
}
catch 可以有多个，但至少要有一个。try...catch 语句的执行过程是：
执行 try 块中的语句，如果执行的过程中没有异常出，那么执行完后就执行最后一个 catch 块后面的语句，所有 catch 块中的语句都不会被执行；
如果 try 块执行的过程中出了异常，那么出异常后立即跳转到第一个“异常类型”和出的异常类型匹配的 catch 块中执行（称作异常被该 catch 块“捕获”），执行完后再跳转到最后一个 catch 块后面继续执行。


能够捕获任何异常的 catch 语句
如果希望不论出哪种类型的异常都能捕获，可以编写如下 catch 块：
catch(...) {
    ...
}



出异常而不加处理会导致函数 A 立即中止，在这种情况下，函数 B 可以选择捕获 A 出的异常进行处理，也可以选择置之不理。如果置之不理，这个异常就会被给 B 的调用者，以此类推。

如果一层层的函数都不处理异常，异常最终会被给最外层的 main 函数。main 函数应该处理异常。如果main函数也不处理异常，那么程序就会立即异常地中止。

我们不要去猜底部在哪，而应该观察什么时候开始稳定回升启动.....

美股暴跌！“股神”巴菲特：我活了89年也没见过这种场面
https://new.qq.com/omn/20200312/20200312A0FIMQ00.html
他还说，如果市场是实时交易的，那么很大程度上它就会对新闻做出反应。股市不像房地产、农场等市场，所以我们昨天（3月9日）就触发了熔断机制，这就是市场的反应。这不像1987年10月19日，但不管怎样，也是够吓人的。

巴菲特：活89年来第一次遇到这种股市暴跌
https://news.china.com/socialgd/10000169/20200312/37905439.html
据香港东网，“股神”巴菲特接受外媒访问时表示，近日股市暴跌，主要是受到新冠肺炎疫情和国际油价暴跌两大因素“左右夹击”，直言“他活着89年以来，也是第一次经历到这种事情。”
对于市场恐慌情绪，他说：“现时情况不是1987年股灾，但属于相似的情况．．．（而2008年金融海啸时）市场更加恐慌，仅就目前发生的事来看（截至周一）。”

美股史无前例周内2次熔断后 个人投资者机会在哪里?
http://news.163.com/20/0313/08/F7J7QHGV00018AOR.html
对此，新京报记者采访了中信建投金融工程与大类资产配置总监、首席分析师丁鲁明，他认为，整体的市场环境都会受到美股下跌的连带影响，在此环境下，还是建议配置A股。
丁鲁明表示，首先，整体的市场环境都会受到连带影响，在此环境下，还是建议配置A股。因为疫情在欧美的蔓延，特别是美国在最近一两周之内才开始对新冠疫情有一个加强认识，而中国的疫情防控已经到了接近完全胜利的状态，将疫情看作是利空的话，A股其实是相对安全的避风港。
这个跌幅连巴菲特都没见过，可以说是史无前例的。一旦疫情超跌修复，恐慌性的杀跌结束以后的反弹也会非常的迅速，到了那时A股也会受到一部分的正面影响。再者本身经济复苏快，所以可能A股也会是率先反弹的。


暴跌！美股史上第三次熔断！
http://finance.sina.com.cn/stock/relnews/us/2020-03-13/doc-iimxxstf8604731.shtml
美股的大跌是有着多重原因，是多年积累的大牛市泡沫的诟病，还有就是美联储的处置不当问题，当然还有特朗普等人的反应过激。而昨天的熔断，还有额外一个原因，真是川普颁布的，今天早上非常疯狂的禁止欧洲旅行禁令，来维持市场。
更愚蠢的是特朗普为了控制疫情，禁止美国人民去欧洲旅行，以匀出一些资本来投入市场缓解危机。但这样子融资只会加重人民对市场的恐慌情绪，反而使股市更加暴跌，甚至昨天晚上的熔断很大一部分原因都是因为这个禁令。
但是美国一周内两次熔断，将直接面临的就是一场金融风暴。

美股触发历史上第二次熔断 道指暴跌超过2000点
https://baijiahao.baidu.com/s?id=1660752319686943128&wfr=spider&for=pc
美股十年牛市宣告结束

所谓熔断机制，简单来说，就是当股市跌到一定幅度之后，市场自动停止交易一段时间，可能是几分钟，也可能是全天交易就此终止。这样做的主要目的就是，防范恐慌情绪进一步扩散，给市场带来更大的冲击。

美国推出熔断机制的动因是1987年的“黑色星期一”。1987年10月19日，道指暴跌508.32点，跌幅22.6%。3个月之后，1988年2月美股熔断机制出台。

美股这次触发熔断机制是历史上的第二次。上一次，是1997年10月27日，当天道指暴跌7.18%。而这一次，道指盘中的跌幅一度超过了7.8%。在莫尼塔研究首席经济学家钟正生看来，这意味着美股十年牛市的结束。“美联储上一次紧急降息50个基点，资本市场并不买账。预计这次，3月18日还会如期的降息50个基点。但是大家觉得未来美联储的货币政策空间非常有限，整个发达经济体的财政政策的空间也非常有限。



美股熔断历史上只发生过三次。 上一次熔断，还要追溯到2020年3月9日。 那天我的记忆很深刻，那感觉，仿佛就在几天之前。

美股熔断历史上只发生过三次。 上一次熔断，还要追溯到2020年3月12日。 那天我的记忆很深刻，那感觉，仿佛就在昨天。

2020.03.13

MFC 定时器用法 SetTimer、KillTimer
https://www.cnblogs.com/yangxx-1990/p/4837327.html
UINT_PTR SetTimer(
  HWND hWnd,              // 窗口句柄
  UINT_PTR nIDEvent,      // 定时器ID，多个定时器时，可以通过该ID判断是哪个定时器
  UINT uElapse,           // 时间间隔,单位为毫秒
  TIMERPROC lpTimerFunc   // 回调函数
);

例如
SetTimer(m_hWnd,1,1000,NULL); //一个1秒触发一次的定时器
在MFC程序中SetTimer被封装在CWnd类中，调用就不用指定窗口句柄了
当不需要计时器的时候调用KillTimer(nIDEvent);
例如：KillTimer(1);


C函数_filelength函数了解
https://blog.csdn.net/hgj125073/article/details/8293970
取文件长度字节数.

_splitpath函数使用
https://blog.csdn.net/weikangc/article/details/45744445
需要的头文件是:<stdlib.h>
函数原型如下：
void _splitpath( const char *path, char *drive, char *dir, char *fname, char *ext);
其中包含5个参数，第一个是待处理的完整的文件名路径，例如：“c:\windows\myfile.txt”，当然这个文件名也可以不是那么完整，即使是"myfile.txt"这样的字符串也可以成功处理。
后面四个参数分别代表四个需要从原始文件路径中截取的字符串，有驱动器盘符(drive)，中间的路径（dir），文件名(fname)，和后缀名（ext）。
只要在这四个参数中传入对应的字符串指针，函数返回时即可获取对应截取的字符串，不想获取的可以直接填入NULL进行忽略，比如我只想截取文件的后缀名，那么这个函数可以如下调用：

用_makepath_s，创建的目录是现实存在的还是虚拟的？ [
https://bbs.csdn.net/topics/390194424
MSDN:

Create a path name from components. 

只是driver + dir + filename + ext连接起来， 不创建物理路径和文件

_splitpath(path, NULL, NULL, NULL, ext);

其中ext必须是已经分配了内存空间的字符串指针，否则会出错（c语言的基本特性，我就不赘述了）

CString		m_szFileName ;
BOOL CLog::Init( const char* pszFileName, int nMaxFileSize, BOOL	bKeepFileOpen )
{
	m_szFileName = pszFileName ;
...}

_splitpath函数使用
https://blog.csdn.net/weikangc/article/details/45744445

OnQueryDragIcon
https://baike.baidu.com/item/OnQueryDragIcon/4023583?fr=aladdin
OnQueryDragIcon是在用户拖拉最小化窗口的时候显示光标的函数

关于OnPaint()和OnQueryDragIcon() [问题点数：30分，结帖人xianglitian]
https://bbs.csdn.net/topics/250034623
CWnd::OnQueryDragIcon   ()其实是一个回调函数，就是当鼠标拖动到CWnd的窗口上的时候，系统自动调用这个函数来确定显示什么样的拖动图标。
oskycar
Bbs2	
ON_WM_PAINT只有当需要对窗口进行绘制时才有用，你如果不做任何绘制工作，这个函数自然没用；   
  ON_WM_ERASEBKGND当背景擦除时被调用，你如果不需要定制背景，DefWindowProc自然会用窗口类的刷子绘制背景，你也不必操心；   
  ON_WM_QUERYDRAGICON只有窗口在最小化时被拖动、而且窗口类没有注册缺省图标时才有用，而事实上，MFC的窗口类总是会注册图标的（DefWindowProc会返回这个图标），即使没有，Windows也会使用系统缺省图标，因此没有它也无关紧要


WM消息大全
https://www.cnblogs.com/tmdsleep/p/5558271.html
WM_ICONERASEBKGND
0x0027
 此消息发送给某个最小化窗口，仅当它在画图标前它的背景必须被重画

GetWindowRect和GetClientRect的区别详解
https://www.cnblogs.com/wb-DarkHorse/archive/2013/07/08/3178201.html
GetWindowRect得到的是相对于当前界面的整个窗口左上角的坐标，比如一个对话框程序，那就是相对于对话框左上角的坐标，从左往右是X方向，从上往下是Y方向。
注意：这个函数的相对坐标原点分两种情况：
1 窗口还没有初始化完成时：原点是整个窗口的左上角
2 初始化完成后，原点是设备屏幕左上角
GetClientRect得到的是相对于窗口客户区左上角的坐标。


GetSystemMetrics()函数的用法
https://www.cnblogs.com/lidabo/archive/2012/07/10/2584725.html
可以用GetSystemMetrics函数可以获取系统分辨率，但这只是其功能之一，GetSystemMetrics函数只有一个参数，称之为「索引」，这个索引有75个标识符，通过设置不同的标识符就可以获取系统分辨率、窗体显示区域的宽度和高度、滚动条的宽度和高度。
int x, y;
x = GetSystemMetrics(SM_CXSCREEN); //屏幕宽度
y = GetSystemMetrics(SM_CYSCREEN); //屏幕高度
GetSystemMetrics(SM_CXFULLSCREEN); //获取最大化窗体的显示区域宽度
GetSystemMetrics(SM_CYFULLSCREEN); //获取最大化窗体的显示区域高度
下面是GetSystemMetrics函数参数nIndex的定义：

SM_ARRANGE 返回是否预备最小化.
SM_CLEANBOOT 返回系统启动方式:
    0 正常启动
    1 安全模式启动
    2 网络安全模式启动
SM_CMOUSEBUTTONS 返回值为系统支持的鼠标键数，返回0，则系统中没有安装鼠标。
SM_CXBORDER,
SM_CYBORDER 返回以相素值为单位的Windows窗口边框的宽度和高度，如果Windows的为3D形态，则
等同于SM_CXEDGE参数
SM_CXCURSOR,
SM_CYCURSOR 返回以相素值为单位的标准光标的宽度和高度
SM_CXDLGFRAME,
SM_CYDLGFRAME 等同与SM_CXFIXEDFRAME and SM_CYFIXEDFRAME
SM_CXDOUBLECLK,
SM_CYDOUBLECLK 以相素值为单位的双击有效的矩形区域
SM_CXEDGE,SM_CYEDGE 以相素值为单位的3D边框的宽度和高度
SM_CXFIXEDFRAME,
SM_CYFIXEDFRAME 围绕具有标题但无法改变尺寸的窗口（通常是一些对话框）的边框的厚度
SM_CXFRAME,SM_CYFRAME 等同于SM_CXSIZEFRAME and SM_CYSIZEFRAME
SM_CXFULLSCREEN,
SM_CYFULLSCREEN 全屏幕窗口的窗口区域的宽度和高度
SM_CXHSCROLL,
SM_CYHSCROLL 水平滚动条的高度和水平滚动条上箭头的宽度
SM_CXHTHUMB 以相素为单位的水平滚动条上的滑动块宽度
SM_CXICON,SM_CYICON 系统缺省的图标的高度和宽度（一般为32*32）
SM_CXICONSPACING,
SM_CYICONSPACING 以大图标方式查看Item时图标之间的间距，这个距离总是大于等于
SM_CXICON and SM_CYICON.
SM_CXMAXIMIZED,
SM_CYMAXIMIZED 处于顶层的最大化窗口的缺省尺寸
SM_CXMAXTRACK,
SM_CYMAXTRACK 具有可改变尺寸边框和标题栏的窗口的缺省最大尺寸，如果窗口大于这个
尺寸，窗口是不可移动的。
SM_CXMENUCHECK,
SM_CYMENUCHECK 以相素为单位计算的菜单选中标记位图的尺寸
SM_CXMENUSIZE,
SM_CYMENUSIZE 以相素计算的菜单栏按钮的尺寸
SM_CXMIN,SM_CYMIN 窗口所能达到的最小尺寸
SM_CXMINIMIZED,
SM_CYMINIMIZED 正常的最小化窗口的尺寸
SM_CXMINTRACK,
SM_CYMINTRACK 最小跟踪距离，当使用者拖动窗口移动距离小于这个值，窗口不会移动。
SM_CXSCREEN,
SM_CYSCREEN 以相素为单位计算的屏幕尺寸。
SM_CXSIZE,SM_CYSIZE 以相素计算的标题栏按钮的尺寸
SM_CXSIZEFRAME,
SM_CYSIZEFRAME 围绕可改变大小的窗口的边框的厚度
SM_CXSMICON,
SM_CYSMICON 以相素计算的小图标的尺寸，小图标一般出现在窗口标题栏上。
M_CXVSCROLL,
SM_CYVSCROLL 以相素计算的垂直滚动条的宽度和垂直滚动条上箭头的高度
SM_CYCAPTION 以相素计算的普通窗口标题的高度
SM_CYMENU 以相素计算的单个菜单条的高度
SM_CYSMCAPTION 以相素计算的窗口小标题栏的高度
SM_CYVTHUMB 以相素计算的垂直滚动条中滚动块的高度
SM_DBCSENABLED 如果为TRUE或不为0的值表明系统安装了双字节版本的USER.EXE,为FALSE或0则不是。
SM_DEBUG 如果为TRUE或不为0的值表明系统安装了debug版本的USER.EXE,为FALSE或0则不是。
SM_MENUDROPALIGNMENT 如果为TRUE或不为0的值下拉菜单是右对齐的否则是左对齐的。
SM_MOUSEPRESENT 如果为TRUE或不为0的值则安装了鼠标，否则没有安装。
SM_MOUSEWHEELPRESENT 如果为TRUE或不为0的值则安装了滚轮鼠标，否则没有安装。(Windows NT only)
SM_SWAPBUTTON 如果为TRUE或不为0的值则鼠标左右键交换，否则没有。


SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);
https://blog.csdn.net/lionhenryzxxy/article/details/53007676
SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);
这个函数，是发送WM_ICONERASEBKGND到本窗口消息队列，(WPARAM) dc.GetSafeHdc(), 是响应这个消息的函数的参数。
WM_ICONERASEBKGND发送给某个最小化窗口，仅当它在画图标前它的背景必须被重画
后面获取图标信息，设置，然后重新画
(以下参考自MSDN)


VC++ - 各种DC及DC资源释放
https://blog.csdn.net/mituan1234567/article/details/17760183
区别在于CPaintDC在构造函数中封装了BeginPaint函数，析构函数封装了EndPaint，并由BeginPaint返回DC，因此CPaintDC在构造DC时会清空WM_PAINT事件，所以当CPaintDC析构的时候不会再触发WM_PAINT。也就是说在OnPaint函数中必须用CPaintDC函数否则每当OnPaint函数结束的时候就会再触发OnPaint，会不停循环下去。
在重绘时最靠谱的作法就是使用CPaintDC提供的dc进行重绘，因为这样会保证每次处理一次WM_PAINT消息之后会清空WM_PAINT，这样会适当避免闪烁的显像。
1、首先，对DC进行解释一下：

Windows应用程序通过为指定设备（屏幕，打印机等）创建一个设备描述表（Device Context, DC）在DC表示的逻辑意义的“画布”上进行图形的绘制。DC是一种包含设备信息的数据结构，它包含了物理设备所需的各种状态信息。Win32程序在绘制图形之前需要获取DC的句柄HDC，并在不继续使用时释放掉。 

2、然后，理顺CDC的派生类关系：

CObject 
public |------CDC 
public |------|------CClientDC 
public |------|------CPaintDC 
public |------|------CWindowDC 
public |------|------CMetaFileDC 
(注意: 除CMetaFileDC以外的三个派生类用于图形绘制.) 
具体的区别，在下面：

CDC是Windows绘图设备的基类
CClientDC：
(1)（客户区设备上下文）用于客户区的输出，与特定窗口关联，可以让开发者访问目标窗口中客户区，其构造函数中包含了GetDC,析构函数中包含了ReleaseDC


CPaintDC：
(1)用于响应窗口重绘消息（WM_PAINT）是的绘图输出。
(2)CPaintDC在构造函数中调用BeginPaint()取得设备上下文，在析构函数中调用EndPaint()释放设备上下文。EndPaint()除了释放设备上下文外，还负责从消息队列中清除WM_PAINT消息。因此，在处理窗口重画时，必须使用CPaintDC，否则WM_PAINT消息无法从消息队列中清除，将引起不断的窗口重画。
(3)CPaintDC也只能用在WM_PAINT消息处理之中。

CWindowDC：
(1)可在非客户区绘制图形，而CClientDC，CPaintDC只能在客户区绘制图形。
(2)坐标原点是在屏幕的左上角，CClientDC，CPaintDC下坐标原点是在客户区的左上角。
(3)关联一特定窗口，允许开发者在目标窗口的任何一部分进行绘图，包含边界与标题，这种DC同WM_NCPAINT消息一起发送

说明：在绘图时推荐使用CClientDC,CPaintDC和CWindowDC对象，而不推荐直接使用CDC对象。

对于释放DC，请记住：
GetDC之后要ReleaseDC，
CreateCompatibleDC之后需要DeleteDC

CClientDC dc(this);类会自动回收的 不用进行删除。



关于OnPaint()函数
https://zhidao.baidu.com/question/1510613461037026060.html
void CDlgBookInfo1::OnPaint()
{
CPaintDC dc(this); // device context for painting
}
这个函数是重绘客户区，请问 CPaintDC dc(this);是什么意思呢？？？
结合本函数讲解一下
声明 dc 是 CPaintDC 对象，并调用构建函数 构建此对象。
构建函数 的形参 是 CWnd* pWnd ， 实参 用了 "this",
this 就是 CPaintDC 对象 所属的当前窗口 -- 接收到 WM_PAINT 消息的窗口。
OnPaint() 函数就是 接收到 WM_PAINT 消息时 的处理函数。


关于OnPaint()函数的用法 [问题点数：20分]
https://bbs.csdn.net/topics/390095928
求该函数的每一句的详解，谢谢
void CDEMOExDlg::OnPaint()//这个是MFC默认的响应WM_PAINT消息的绘图函数
{
  if (IsIconic())//判断当前窗体是否最小化！
  {
  CPaintDC dc(this); //当前设备DC

  SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);
//发送WM_ICONERASEBKGND消息WM_ICONERASEBKGND发送给某个最小化窗口，仅当它在画图标前它的背景必须被重画

  // Center icon in client rectangle
  int cxIcon = GetSystemMetrics(SM_CXICON);//获取图标尺寸
  int cyIcon = GetSystemMetrics(SM_CYICON);
  CRect rect;
  GetClientRect(&rect);//获取用户区域RECT数据
  int x = (rect.Width() - cxIcon + 1) / 2;
  int y = (rect.Height() - cyIcon + 1) / 2;

  // Draw the icon
  dc.DrawIcon(x, y, m_hIcon);//绘制图标
  }
  else
  {
  CDialog::OnPaint();//调用进行默认绘制--界面部分
  }


MFC中的Invalidate、OnDraw、OnPaint函数的作用、区别和联系？
https://zhidao.baidu.com/question/314348918.html
一、Invalidate介绍
　　void Invalidate( BOOL bErase = TRUE );
　　该函数的作用是使整个窗口客户区无效。窗口的客户区无效意味着需要重绘，例如，如果一个被其它窗口遮住的窗口变成了前台窗口，那么原来被遮住的部分就是无效的，需要重绘。这时Windows会在应用程序的消息队列中放置WM_PAINT消息。MFC为窗口类提供了WM_PAINT的消息处理函数OnPaint，OnPaint负责重绘窗口。视图类有一些例外，在视图类的OnPaint函数中调用了OnDraw函数，实际的重绘工作由OnDraw来完成。参数bErase为TRUE时，重绘区域内的背景将被擦除，否则，背景将保持不变。
二、与UpdateWindow( )的区别
　　UpdateWindow( )的作用是使窗口立即重绘。调用Invalidate等函数后窗口不会立即重绘，这是由于WM_PAINT消息的优先级很低，它需要等消息队列中的其它消息发送完后才能被处理。调用UpdateWindow函数可使WM_PAINT被直接发送到目标窗口，从而导致窗口立即重绘。
OnPaint是WM_PAINT消息的消息处理函数，在OnPaint中调用OnDraw，一般来说，用户自己的绘图代码应放在OnDraw中。为什么需要OnDraw呢，是为了让OnDraw一个函数服务于不同的绘图环境，比如显示器，打印机，绘图仪 ,mfc在调用OnDraw之前会把适当的CDC对象传给OnDraw函数。这样窗口的打印功能就可以和显示共用一个函数。
OnPaint是WM_PAINT消息的消息处理函数，在OnPaint中调用OnDraw，一般来说，用户自己的绘图代码应放在OnDraw中。
当没有添加WM_PAINT消息处理时,窗口重绘时,由OnDraw来进行消息响应...
当添加WM_PAINT消息处理时,窗口重绘时,WM_PAINT消息被投递,由OnPaint来进行消息响应.这时就不能隐式调用OnDraw了.必须显式调用( CDC *pDC=GetDC(); OnDraw(pDC); )..
隐式调用:当由OnPaint来进行消息响应时,系统自动调用CView::OnDraw(&pDC).


OnPaint()函数的作用原理
https://www.cnblogs.com/BeyondTechnology/archive/2011/03/25/1995942.html
所以解决方法有三个半:
1.用OnEraseBkGnd实现,不要调用原来的OnEraseBkGnd函数.
2.用OnPaint实现,同时重载OnEraseBkGnd,其中直接返回.
3.用OnPaint实现,创建窗口时设置背景刷为空
4.用OnPaint实现,但是要求刷新时用Invalidate(FALSE)这样
的函数.(不过这种情况下,窗口覆盖等造成的刷新还是要闪一
下,所以不是彻底的解决方法)
都挺简单的.
其OnPaint() c OnEraseBkgnd() 特性是有差的
1. OnEraseBkgnd()的要求是快速在e面的LD程式最好是不要太耗rg
因槊慨window元件有任何小佣R上呼叫OnEraseBkgnd()
2. OnPaint() 是只有在程式有空f的r候才被呼叫
3. OnEraseBkgnd() 是在 OnPaint() 之前呼叫的
所以 OnPaint()被呼叫一次之前 可能呼叫OnEraseBkgnd()好状
如果我是一个在做图形化使用者界面的人
常会需要把一张图片设为我们dialog的背景
把绘图的代码放在OnPaint() 之中 可能会常碰到一些问题
比方f拖拽一个窗口在我们做的dialog上面一直移动
则dialog会变成灰色 直到动作停止才恢复
这是因为每次需要重绘的r候 程序都会马上呼叫OnEraseBkgnd()
OnEraseBkgnd()就把dialog画成灰色
而只有动作停止之后 程序才会呼叫OnPaint() 这时才会把我要画的背景N上去

这个问题的解法 比较差劲的方法是把OnEraseBkgnd() 改写成不做事的function
如下所示
BOOL CMyDlg::OnEraseBkgnd(CDC* pDC)
{
return TRUE;
}
比^好的做法是直接⒗LD的程式OnPaint()移到OnEraseBkgnd()碜
如下所示

// m_bmpBKGND 橐CBitmap物件 且事先早已d入我的底D
// 底D的大小c我的窗client大小一致


BOOL CMyDlg::OnEraseBkgnd(CDC* pDC)
{
CRect rc;
GetUpdateRect(&rc);
CDC srcDC;
srcDC.CreateCompatibleDC(pDC);
srcDC.SelectObject(m_bmpBKGND);

pDC->BitBlt(rc.left,rc.top,rc.GetWidth(),
rc.GetHeight(),&srcDC,rc.left,rc.top,SRCCOPY);
return TRUE;
}

MFC中OnDraw与OnPaint的区别

在OnPaint中调用OnDraw，一般来说，用户自己的绘图代码应放在OnDraw中。

OnPaint()是CWnd的类成员，负责响应WM_PAINT消息。OnDraw()是CVIEW的成员函数，没有响应消息的功能.当视图变得无效时（包括大小的改变，移动，被遮盖等等），Windows发送WM_PAINT消息。该视图的OnPaint 处理函数通过创建CPaintDC类的DC对象来响应该消息并调用视图的OnDraw成员函数.OnPaint最后也要调用OnDraw,因此一般在OnDraw函数中进行绘制。

在OnPaint中，将调用BeginPaint，用来获得客户区的显示设备环境，并以此调用GDI函数执行绘图操作。在绘图操作完成后，将调用EndPaint以释放显示设备环境。而OnDraw在BeginPaint与EndPaint间被调用。（一个应用程序除了响应WM_PAINT消息外，不应该调用BeginPaint。每次调用BeginPaint都应该有相应的EndPaint函数。）
至于CPaintDC和CClientDC根本是两回事情 CPaintDC是一个设备环境类，在OnPaint中作为参数传递给OnPrepareDC来作设备环境的设置。真正和CClientDC具有可比性的是CWindowDC，他们一个是描述客户区域，一个是描述整个屏幕。
如果是对CVIEW或从CVIEW类派生的窗口绘图时应该用OnDraw。

OnDraw()和OnPaint()有什么区别呢？
首先：我们先要明确CView类派生自CWnd类。而OnPaint()是CWnd的类成员，同时负责响应WM_PAINT消息。OnDraw()是CVIEW的成员函数，并且没有响应消息的功能。这就是为什么你用VC成的程序代码时，在视图类只有OnDraw没有OnPaint的原因。而在基于对话框的程序中，只有OnPaint。
其次：我们在第《每天跟我学MFC》3的开始部分已经说到了。要想在屏幕上绘图或显示图形，首先需要建立设备环境DC。其实DC是一个数据结构，它包含输出设备（不单指你17寸的纯屏显示器，还包括打印机之类的输出设备）的绘图属性的描述。MFC提供了CPaintDC类和CWindwoDC类来实时的响应，而CPaintDC支持重画。当视图变得无效时（包括大小的改变，移动，被遮盖等等），Windows 将 WM_PAINT 消息发送给它。

最后：现在大家明白这哥俩之间的关系了吧。因此我们一般用OnPaint维护窗口的客户区（例如我们的窗口客户区加一个背景图片），用OnDraw维护视图的客户区（例如我们通过鼠标在视图中画图）。当然你也可以不按照上面规律来，只要达到目的并且没有问题，怎么干都成。补充：我们还可以利用Invalidate(),ValidateRgn(),ValidateRect()函数强制的重画窗口，具体的请参考MSDN吧。

OnDraw中可以绘制用户区域。OnPaint中只是当窗口无效时重绘不会保留CClientDC绘制的内容。

想象一下，窗口显示的内容和打印的内容是差不多的，所以，一般情况下，统一由OnDraw来画。窗口前景需要刷新时，系统会会调用到OnPaint，而OnPaint一般情况下是对DC作一些初始化操作后，调用OnDraw()。


OnEraseBkGnd()，是窗口背景需要刷新时由系统调用的。明显的一个例子是设置窗口的背景颜色（你可以把这放在OnPaint中去做，但是会使产生闪烁的现象）。
至于怎么界定背景和前景，那要具体问题具体分析了，一般情况下，你还是很容易区别的吧。

的确，OnPaint()用来响应WM_PAINT消息，视类的OnPaint()内部根据是打印还是屏幕绘制分别以不同的参数调用OnDraw()虚函数。所以在OnDraw()里你可以区别对待打印和屏幕绘制。
其实，MFC在进行打印前后还做了很多工作，调用了很多虚函数，比如OnPreparePrint()等。


另外OnInitialUpdate

视图窗口完全建立后第一个被框架调用的函数。框架在第一次调用OnDraw前会调用OnInitialUpdate，因此OnInitialUpdate是设置滚动视图的逻辑尺寸和映射模式的最合适的地方。



OnPaint
https://baike.baidu.com/item/OnPaint/639414
当Windows或应用程序请求重画应用程序窗口的一部分时，框架调用这个成员函数。WM_PAINT在调用UpdateWindow或RedrawWindow成员函数时发出。当设置了RDW_INTERNALPAINT标志并调用RedrawWindow成员函数时，窗口可能会接收到内部重画消息。在这种情况下，窗口可能没有更新区域。应用程序必须调用GetUpdateRect成员函数以确定窗口是否具有更新区域。如果GetUpdateRect返回0，则应用程序不应调用BeginPaint和EndPaint成员函数。
应用程序负责检查是否需要内部重画或更新，这可通过查看每条WM_PAINT消息的内部数据结构来完成，因为一条WM_PAINT可能是由于一个无效区域或由于使用RDW_INTERNALPAINT标志调用了RedrawWindow成员函数而引起的。
Windows只发送一次内部WM_PAINT消息。在通过UpdateWindow成员函数向窗口发送了内部WM_PAINT消息以后，将不会再向窗口发送其它WM_PAINT消息，直到再次使用RDW_INTERNALPAINT标志调用了RedrawWindow成员函数。

IsIconic()和OnPaint()函数 虽然没什么用 留个印象
https://blog.csdn.net/xs574924427/article/details/7355425
IsIconic()作用是判断窗口是否处于最小化状态（点击了最小化按钮之后）。

对于普通的对话框来说，如果你在if (IsIconic()) 下面加入AfxMessageBox("haha") ，你会发现消息框并不会弹出。

原因是，if (IsIconic()) 这段代码是在OnPaint()函数内，当你最小化了对话框之后，虽然IsIconic()的值是TRUE，但是OnPaint()函数并不会运行。因为OnPaint()响应的是WM_PAINT消息，而WM_PAINT消息是针对客户区的。一个最小化了的窗口不需要重绘客户区。

为了验证这一点，可以设置一定时器，在OnTimer()函数里写上
if(IsIconic()) MessageBeep(MB_OK);
当你点击最小化按钮后，你会听见嘟嘟声。

那么这段代码究竟有什么用？它是不是永远不会被执行呢？当然不是。举两个例子。
第一，如果你强行发送WM_PAINT消息，它会执行。
第二，特殊的对话框。比如一个ToolBox风格的对话框。这个对话框不显示在任务栏，在最小化之后它会变成一个很小的一条显示在桌面上。这时如果它被遮挡，就会出发WM_PAINT消息，从而执行那段代码。


MFC中如何判断当前窗口是否最小化
https://zhidao.baidu.com/question/267113507929074005.html
IsIconic()==true; 是最小化
IsZoomed()==true; 是最大化

CreateEvent
https://blog.csdn.net/u013407012/article/details/78585431
一、事件是很常用的多线程同步互斥机制
     函数原型如下所示，一共四个参数：
HANDLE CreateEvent(

　LPSECURITY_ATTRIBUTES lpEventAttributes,　// SECURITY_ATTRIBUTES结构指针，可为NULL
　BOOL bManualReset,     // 手动/自动
　                                    // TRUE：表示手动，在WaitForSingleObject后必须手动调用ResetEvent清除信号
　                                   // FALSE：表示自动，在WaitForSingleObject后，系统自动清除事件信号
　BOOL bInitialState,        //初始状态，FALSE为无信号，TRUE为有信号
　LPCTSTR lpName         //事件的名称
    );
二、下面是使用演示：
     1、首先在要使用时间的类中声明这个事件的句柄，用来标识这个事件，如下所示：


CreateEvent
https://baike.baidu.com/item/CreateEvent/917012?fr=aladdin
如果函数调用成功，函数返回事件对象的句柄。如果对于命名的对象，在函数调用前已经被创建，函数将返回存在的事件对象的句柄，而且在GetLastError函数中返回ERROR_ALREADY_EXISTS。
如果函数失败，函数返回值为NULL，如果需要获得详细的错误信息，需要调用GetLastError。


BEGIN_MESSAGE_MAP(CMsEditDlg, CDialog)
	//{{AFX_MSG_MAP(CMsEditDlg)
...
	ON_WM_TIMER()
...
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

MFC Edit Control 设置焦点无效
https://blog.csdn.net/u010921682/article/details/52603086
关于对话框OnInitDialog里设置edit控件输入焦点问题  
本人在edit.SetFocus()不起作用(edit是我关联的edit控件的edit变量) 
最后才发现原来在vs2010/vs2013的最后有提示说
[cpp] view plain copy
return TRUE;  // return TRUE unless you set the focus to a control  
// 异常: OCX 属性页应返回 FALSE  
所以把return TRUE 改成return FALSE就可以了


MFC中如何修改生成的exe图标
https://www.icode9.com/content-4-384814.html
CMsEdit_WendyDlg::CMsEdit_WendyDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CMsEdit_WendyDlg::IDD, pParent)
{
...
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}
SetIcon(m_hIcon, TRUE); // Set big icon 
SetIcon(m_hIcon, FALSE); // Set small icon;
修改可运行程序的启动图标通过修改resource.h对应的加载图标的ID为最小来实现;
修改关于对话框的图标可通过覆盖工程中res文件夹下的项目名.ico图标来实现.

关于SetIcon()函数的几个问题
http://bbs.bccn.net/thread-160801-1-1.html
SetIcon()是设置应用程序对话框窗口的大图标和小图标用的,我创立了一个基于对话框的应用程序,在函数OnInitDialog()中有调动了这个函数两次,如下:
SetIcon(m_hIcon, TRUE); // Set big icon
SetIcon(m_hIcon, FALSE); // Set small icon
当我将下面一个函数调动注释起来,再运行程序时,对话框左上角仍然显示小图标,只有当我把两个均注释起来时,对话框左上角才不显示小图标,这是为什么呢?两个函数都是设置程序的图标，只要调用SetIcon(handle,TRUE)或SetIcon(handle,FALSE）任意一个，都会显示图标。
一个是设置大图标，一个是设置小图标，图标尺寸是32*32，小图标是16*16

C++技巧：加载图标LoadIcon，SetIcon
https://www.cnblogs.com/mychj2008/p/3668902.html
其中IDR_MAINFRAME在资源下面可以找到.
　　因此如果想更改图标的话,可以自己改写m_hIcon,或者在OninitDialog中写:
　　SetIcon(::LoadIcon(NULL,IDI_APPLICATION),FALSE);
　　SetIcon(::LoadIcon(NULL,IDI_APPLICATION),TRUE);
　　考试大提示: SetIcon,它的第二个参数是BOOL,如果是TRUE,就是关闭了程序显示的图标,就是常说的快捷方式之类的图标;如果是FALSE,那么就是程序最大化,最小化或者正常显示时的标题兰上的图标. 

用VC向导生成的基于对话框的程序中SetIcon 的作用
https://blog.csdn.net/imxiangzi/article/details/37350951
哦，原来是向窗口(窗口句柄为m_hWnd)发送了一个WM_SETICON消息，再呼出MSDN，对于这个消息，MSND上有比较详细的解释。如消息名SETICON所揭示的那样，发送这个消息给窗口，是为了让这个窗口和大图标(large icon)或者小图标(small icon)关联。在用户按ALT+TAB键切换窗口时，显示的就是大图标，小图标就是对话框窗口标题栏上的那个图标。
同一的参数m_hIcon, 却带有TRUE或者FALSE，这是颇让人感到疑惑的地方。说白了其实也是很简单的事情，我们在用VC的资源编辑器编辑图标(icon)时，不是可以选择不同大小的图片来进行编辑吗？这些大小不同的图，最终都存入到同一个.ico文件中去了。所以m_hIcon指向的是一组图标，第二个参数(TRUE或者 FALSE)就是用来指定这一组图标中某一类大小的图标的，参数值为TRUE时，指明使用大图标(32*32相素)，FALSE指明使用小图标 (16*16像素)。


MFC中SetIcon详解
https://blog.csdn.net/lynn1258/article/details/52211156?utm_source=blogxgwz2
用软件自动创建的MFC工程，在初始化的时候OnInitDialog函数中可以看到2句这样的代码。

SetIcon(m_hIcon, TRUE); // 设置大图标
SetIcon(m_hIcon, FALSE); ? ? ? ?// 设置小图标

那么什么是大图标，什么是小图标呢？
大图标就是你按"alt+tab"切换软件的时候显示的图标。小图标就是程序界面最左上角显示的图标。
自己可以屏蔽试试，动手试下就知道了。


MFC学习笔记――ASSERT、GetSystemMenu、IDM_ABOUTBOX
https://blog.csdn.net/shanshangyouzhiyangm/article/details/51959038
// IDM_ABOUTBOX 必须在系统命令范围内。
    // 低4位是系统内部使用的
    ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);    
    // 如果一个应用程序增加命令到窗口菜单，应该使用小于0xF000的标识符数
    ASSERT(IDM_ABOUTBOX < 0xF000);
GetSystemMenu
GetSystemMenu
函数功能：该函数允许应用程序为复制或修改而访问窗口菜单（系统菜单或控制菜单）。
**函数原型：**HMENU GetSystemMenu(HWND hWnd,BOOL bRevert)；
参数：
hWnd：拥有窗口菜单拷贝的窗口的句柄。
bRevert：指定将执行的操作。如果此参数为FALSE，GetSystemMenu返回当前使用窗口菜单的拷贝的句柄。该拷贝初始时与窗口菜单相同，但可以被修改。
如果此参数为TRUE，GetSystemMenu重置窗口菜单到缺省状态。如果存在先前的窗口菜单，将被销毁。
返回值：如果参数bRevert为FALSE，返回值是窗口菜单的拷贝的句柄：如果参数bRevert为TRUE，返回值是NULL。
备注：任何没有用GetSystemMenu函数来生成自己的窗口菜单拷贝的窗口将接受标准窗口菜单。

窗口菜单最初包含的菜单项有多种标识符值，如SC_CLOSE，SC_MOVE和SC_SIZE。

窗口菜单上的菜单项发送WM_SYSCOMMAND消息。


学习打造自己的DEBUG_NEW
https://www.cnblogs.com/lisuyun/p/5744548.html
这里顺便提一下THIS_FILE，__FILE和__LINE__。__FILE__和__LINE__都是编译器定义的宏。当碰到__FILE__时，编译器会把__FILE__替换成一个字符串，这个字符串就是当前在编译的文件的路径名。当碰到__LINE__时，编译器会把__LINE__替换成一个数字，这个数字就是当前这行代码的行号。在DEBUG_NEW的定义中没有直接使用__FILE__，而是用了THIS_FILE，其目的是为了减小目标文件的大小。假设在某个cpp文件中有100处使用了new，如果直接使用__FILE__，那编译器会产生100个常量字符串，这100个字符串都是飧?/SPAN>cpp文件的路径名，显然十分冗余。如果使用THIS_FILE，编译器只会产生一个常量字符串，那100处new的调用使用的都是指向常量字符串的指针。


关于"#define new DEBUG_NEW"
https://blog.csdn.net/gggg_ggg/article/details/43407447
因此相应修改了两个符号的定义THIS_FILE是一个char数组全局变量，字符串值为当前文件的全路径

DestroyWindow函数解析

https://blog.csdn.net/xiaolongwang2010/article/details/10163611

归纳起来，主要有三层意思：

1、该函数销毁一个指定的窗口。

2、如果指定的窗口是一个父窗口，则该函数自动销毁与之管理的子窗口。

3、该函数也用于销毁用CreateDialog 函数创建的非模式对话框。

下面我们就来看看手动调用DestroyWindow后，该函数是如何销毁非模式对话框的，为了跟踪函数的执行流程，我们在关键位置设置了TRACE语句，其输出顺序为：

1、OnDestroy
2、OnNcDestroy
3、PostNcDestroy

 由以上TRACE语句的输出顺序可以看出，手动调用DestroyWindow后，该函数执行过程大致为：

1、该函数先发送WM_DESTROY 消息；

2、OnDestroy函数响应此消息（输出OnDestroy）；

3、OnDestroy函数发送WM_NCDESTROY消息；

4、OnNcDestroy函数响应此消息（输出OnNcDestroy）；

5、OnNcDestroy函数最后调用PostNcDestroy函数；（输出PostNcDestroy）

在这里，请注意PostNcDestroy函数，该函数经常被用户重载在函数结尾加以下语句：delete this，以删除非模式对话框对象。（DestroyWindow只是销毁了非模式对话框（窗口），但并没有删除其对象。）

因此，综上所叙，通过DestroyWindow函数和delete this语句就到达了分别删除非模式对话框（窗口）及其对象的目的！

 

另外，通过跟踪程序发现，在模式对话框下，调用OnOk()或者OnCancel函数（EndDialog），会触发WM_DESTROY消息，从而会依次调用OnDestroy、OnNcDestroy、PostNcDestroy函数。TRACE语句按以下顺序输出：

1、OnOK

2、EndDialog

3、OnDestroy

4、OnNcDestroy

5、PostNcDestroy

但是在非模式对话框下，调用OnOk()或者OnCancel函数（EndDialog），则不会触发WM_DESTROY消息，从而不会调用上述函数。这可能就是很多书籍上强调的无模式对话框不要调用OnOk()或者OnCancel函数来销毁而要调用DestroyWindow函数来销毁的原因了。TRACE语句按以下顺序输出：

1、OnOK

2、EndDialog

总结：非模式对话框下OnOk()或者OnCancel函数（EndDialog）不会触发WM_DESTROY消息。



2020.03.12

Compiling...
Log.cpp
E:\wendy_work\MsEdit_Wendy\Log.cpp(23) : error C2653: 'CWrapperPath' : is not a class or namespace name
E:\wendy_work\MsEdit_Wendy\Log.cpp(23) : error C2065: 'GetExtPath' : undeclared identifier
E:\wendy_work\MsEdit_Wendy\Log.cpp(90) : error C2653: 'CWrapperPath' : is not a class or namespace name
E:\wendy_work\MsEdit_Wendy\Log.cpp(90) : error C2065: 'SpitePath' : undeclared identifier
E:\wendy_work\MsEdit_Wendy\Log.cpp(217) : error C2653: 'CWrapperPath' : is not a class or namespace name


也不用百里挑一， 看懂就过。

#ifndef #define #endif 防止头文件被重复引用
https://www.cnblogs.com/limera/p/5658466.html
其实“被重复引用”是指一个头文件在同一个cpp文件中被include了多次，这种错误常常是由于include嵌套造成的。比如：存在a.h文件#include "c.h"而此时b.cpp文件导入了#include "a.h" 和#include "c.h"此时就会造成c.h重复引用。
头文件被重复引用引起的后果：
有些头文件重复引用只是增加了编译工作的工作量，不会引起太大的问题，仅仅是编译效率低一些，但是对于大工程而言编译效率低下那将是一件多么痛苦的事情。
有些头文件重复包含，会引起错误，比如在头文件中定义了全局变量(虽然这种方式不被推荐，但确实是C规范允许的)这种会引起重复定义。


c++ 防止头文件重复include问题
https://zhidao.baidu.com/question/112685790.html
#ifndef的方式依赖于宏名字不能冲突，这不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件不会被不小心同时包含。当然，缺点就是如果不同头文件的宏名不小心“撞车”，可能就会导致头文件明明存在，编译器却硬说找不到声明的状况
#pragma once则由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。带来的好处是，你不必再费劲想个宏名了，当然也就不会出现宏名碰撞引发的奇怪问题。对应的缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名碰撞引发的“找不到声明”的问题，重复包含更容易被发现并修正。
方式一由语言支持所以移植性好，方式二 可以避免名字冲突。



如何防止头文件被重复包含或引用?
https://blog.csdn.net/sharp_up/article/details/71971184
// Test1.h
#ifndefine ?TEST1_H
#defineTEST1_H
...
#endif

// Test2.h
#pragma once
...

// Test.cpp
#include "Test1.h"// line 1
#include "Test1.h"// line 2
#include "Test2.h"// line 3
#include "Test2.h"// line 4 这里的Test2.h是同一物理文件

预处理器在执行这四句的时候，先打开Test1.h然后发现里面的宏TEST1_H没有被定义，所以会包含这个文件，
第二句的时候，同样还是会打开Test1.h的发现宏已定义，就不包含该文件按了。
第三句时，发现之前没有包含Test2,h则会把该文件包含进来，
执行第四句的时候，发现该文件已经被包含了，所以不用打开就直接跳过了
二、条件编译
#include"a.h"
#include"b.h"
看上去没什么问题。如果a.h和b.h都包含了一个头文件x.h。那么x.h在此也同样被包含了两次，只不过它的形式不是那么明显而已。
多重包含在绝大多数情况下出现在大型程序中，它往往需要使用很多头文件，因此要发现重复包含并不容易。要解决这个问题，我们可以使用条件编译。如果所有的头文件都像下面这样编写:
#ifndef _HEADERNAME_H
#define _HEADERNAME_H

由于工程中的每个.c文件都是独立的解释的，即使头文件有
#ifndef _TEST_H_ #define _TEST_H_ .... #enfif
在其他文件中只要包含了test.h就会独立的解释,然后每个.c文件生成独立的标示符。
在编译器链接时，就会将工程中所有的符号整合在一起，由于文件中有重名变量，于是就出现了重复定义的错误。

解决方法:
在.c文件中定义变量，然后再建一个头文件(.h文件)，在所有的变量声明前加上extern，注意这里不要对变量进行的初始化。
然后在其他需要使用全局变量的.c文件中包含.h文件。编译器会为.c生成目标文件，然后链接时，
如果该.c文件使用了全局变量，链接器就会链接到定义变量的.c文件?

问题扩展：?变量的声明有两种情况:
(1) 一种是需要建立存储空间的(定义、声明)。例如：int a在声明的时候就已经建立了存储空间。?
(2) 另一种是不需要建立存储空间的(声明)。例如：extern int a其中变量a是在别的文件中定义的。
前者是"定义性声明(defining declaration)"或者称为"定义(definition)",而后者是"引用性声明(referncingdeclaration)"。
从广义的角度来讲声明中包含着定义，但是并非所有的声明都是定义，例如:int a它既是声明，同时又是定义。
然而对于extern a来讲它只是声明不是定义。一般的情况下我们常常这样叙述，把建立空间的声明称之为"定义"，
而把不需要建立存储空间称之为"声明"。很明显我们在这里指的声明是范围比较窄的，也就是说非定义性质的声明。

extern int A; //这是个声明而不是定义，声明A是一个已经定义了的外部变量
                 //注意：声明外部变量时可以把变量类型去掉如：extern A;

用static来声明一个变量的作用有二：
    (1) 对于局部变量用static声明，则是为该变量分配的空间在整个程序的执行期内都始终存在
    (2) 外部变量用static来声明，则该变量的作用只限于本文件模块

另外一个好处是减小类A的大小
前置声明解决两个类的互相依赖
前置声明只能作为指针或引用，不能定义类的对象，自然也就不能调用对象中的方法了。



#define #if #ifdef #ifndef 作用和区别
https://blog.51cto.com/12104971/1857992
如果#ifndef…#endif在头文件中，千万不要忽略了头件的中的#ifndef，这是一个很关键的东西。
比如你有两个C文件，这两个C文件都include了同一个头文件。
而编译时，这两个C文件要一同编译成一个可运行文件，于是问题来了，大量的声明冲突。 


#ifndef 与 #if !define区别
https://blog.csdn.net/u011642774/article/details/71729148
我们要检查a是否定义（假设我们已经记不着这点了）,或者我们要给a一个不同的值，就加入如下句子 
#if defined a 
#undef a 
#define a 200 
#endif 
#error XXXX 
是用来产生编译时错误信息XXXX的，一般用在预处理过程中； 


"#if define A" 与 "#if defined A" 的区别 [问题点数：60分，结帖人zhaoxuxing]
https://bbs.csdn.net/topics/380226986
1/" #if define ABC " 这是一种错误的写法
2/" #elif define ABC " 这是一种错误的写法
这两种写法可能 能通过编译器，但执行的结果却是错误的！！！ 既然是错误的怎样改正呢？往下看
3/" #ifdef ABC " == " #if defined ABC " 这才是正确的写法 


#if、#ifdef、#if defined之间的区别
https://www.iteye.com/blog/quanminchaoren-1870977
#if的使用说明
#if的后面接的是表达式

#if (MAX==10)||(MAX==20)
 code...
#endif
它的作用是：如果(MAX==10)||(MAX==20)成立，那么编译器就会把其中的#if 与 #endif之间的代码编译进去（注意：是编译进去，不是执行！！）

#if defined的使用
#if后面接的是一个宏。

#if defined (x)
    ...code...
#endif
这个#if defined它不管里面的“x”的逻辑是“真”还是“假”它只管这个程序的前面的宏定义里面有没有定义“x”这个宏，如果定义了x这个宏，那么，编译器会编译中间的…code…否则不直接忽视中间的…code…代码。

另外 #if defined(x)也可以取反，也就用 #if !defined(x)

#ifdef的使用
#ifdef的使用和#if defined()的用法一致
#ifndef又和#if !defined()的用法一致。

最后强调两点：
第一：这几个宏定义只是决定代码块是否被编译！
第二：别忘了#endif


使用#if defined()组成复杂的预编译控制指令
https://blog.csdn.net/david_xtd/article/details/12652197
#ifdef只能判断单一的宏是否定义，而#if defined()可以组成复杂的判别条件；


对于单一的宏AAA来说，#ifdef AAA和#if defined(AAA)是完全相同的。


而要组成复杂的判别条件，用#if defined()就灵活方便了，比如：#if defined(AAA) && (BBB >= 10)

如果改用#ifdef则没法表示条件BBB>=10了。

#ifndef 与 #if !defined有区别吗？该怎么解决
https://www.cnblogs.com/lycrfx/articles/5766103.html
基本上一样，不过后者的应用范围更大，可以支持多个预编译变量的检查： 
#if (!defined(_DEBUG) && defined(USE_MYLIB)) 
.......... 
#endif 

这种情况用前一种方式就只能写一个嵌套的条件判断： 
#ifndef _DEBUG 
#ifdef USE_MYLIB 
................ 
#endif 
#endif


闰年的定义？？
https://zhidao.baidu.com/question/167039572.html
①、普通年能被4整除且不能被100整除的为闰年。（如2004年就是闰年,1901年不是闰年）地球公转示意图
②、世纪年能被400整除的是闰年。(如2000年是闰年，1900年不是闰年) 
③、对于数值很大的年份能整除3200,但同时又能整除172800则又是闰年.(如172800年是闰年，86400年不是闰年）
闰年
https://baike.baidu.com/item/%E9%97%B0%E5%B9%B4/27098
闰年是怎么定义的
https://zhidao.baidu.com/question/28992622.html

白增多
https://baike.baidu.com/item/%E7%99%BD%E5%B8%A6%E8%BF%87%E5%A4%9A/7716427?fr=aladdin
先查后做(v ok)

#ifdef #if defined #ifndef和#if !defined区别
https://blog.csdn.net/tmd_mcu/article/details/78140229
预处理指令包含了以下内容：
　　1，宏定义   #define
　　2，文件包含 #include
　　3，条件编译 #if
　　#ifdef
　　#ifndef
　　#if defined
　　#if !defined
　　#elif
　　#else
　　#endif
　　#undef
　　指令都是以#开始的
宏可以带参数，也是常说的宏函数
　　#define 标识符（x1,x2...） 替换列表
　　特别注意的是标识符和(之间不能有空格，圆括号是必须的。
　　还可以写得更复杂一点，比如我们来写一个宏函数，用它来验证一个日期是否合法
　　#define ISLEAP(y) ((y)%4==0&&(y)%100!=0||(y)%400==0)
　　#define ISSMALL(m) ((m)==4||(m)==6||(m)==9||(m)==11)
　　#define NORMAL(m) (ISSMALL(m)?30:31)
　　#define DAYS(y,m) ((m)==2?28+ISLEAP(y):NORMAL(m))
　　#define IN(x, from,to) ((x)>=(from)&&(x)<=(to))
　　#define VALID(y,m,d) ((y)>1600&&IN(m,1,12)&&IN(d,1,DAYS(y,m)))

　　#if (comdition)
　　{//语句##；}
　　#endif

　#if  常量表达式
　　常量表达式为0时，预处理器删除#if 和#endif中间的代码
　　#if 会把没有定义过的标准符视做为0，　如果没有定义DEBUG, 则
　　测试#if DEBUG 会失败，但#if !DEBUG会成功。

　　可以用宏来定义文件名：
　　#if define(IA32)
　　#define CPU_FILE “ia32.h”
　　#elif defined(IA64)
　　#deifine CPU_FILE “ia64.h”
　　#elif defined(AMD64)
　　#define CPU_FILE “amd64.h”
　　#endif
　　#include CPU_FILE

　　#if defined VALUE              // 检验VALUE是否被定义 ，如果被定义
　　#undef VALUE            // 解除语句定义
　　#define VALUE 1000            //  重新定义VALUE 为1000
　　#endif

　　如果检验没有定义，可以这样写：
　　#ifndef VALUE               // 如果VALUE没有被定义
　　#define VALUE 1000          //  定义VALUE 为1000
　　#endif

　　#undef为解除定义;
　　#ifndef是if not defined的缩写，也可以写成#if !defined 即如果没有定义;
　　#ifdef是if defined的缩写，也可以写成#if defined 即检查是否定义过;

总结：
#ifdef只能判断单一的宏是否定义，而#if defined()可以组成复杂的判别条件；
对于单一的宏AAA来说，#ifdef AAA和#if defined(AAA)是完全相同的。
而要组成复杂的判别条件，用#if defined()就灵活方便了，比如：#if defined(AAA) && (BBB >= 10)
如果改用#ifdef则没法表示条件BBB>=10了。


C:\Users\Wendy\Desktop\temp\temp.txt
--->
E:\wendy_work\temp\temp_company.txt

军事管制

意料之外，预料之中
https://news.sina.cn/gn/2020-02-09/detail-iimxxstf0024695.d.html
李文亮是在1月8日接诊一位82岁的病人时感染新冠病毒的

幽螺莎星爆珠丸 幽门螺杆菌（简称HP）。
加上价格也很赞，一盒里面有30粒，只要39.9元，现在还有买一送一的活动，也就是39.9元到手60粒，简直不要太划算！
口气清新，你我更亲近！
两盒只要39.9元
买三送一，59.9元/4盒
买五送三，99.9元/8盒

湖北省卫健委书记被免职 昨日还在参加防治工作会
https://news.163.com/20/0211/10/F53LSRO70001899O.html

湖北省卫健委两名主要官员被免职
https://www.sohu.com/a/372114557_123753

湖北省l健委、主任被免，疫情的S金防控期楹e^？
https://news.fx168.com/opinion/column/gwzj/2002/3614068.shtml

湖北省卫健委两官员被免职！预计武汉所有疑似患者检测今日清零
https://3g.163.com/news/article/F541BCGE0517BMJU.html

湖北省卫健委党组书记、主任同时被免：还会有谁被问责？
http://blog.sina.cn/dpool/blog/s/blog_537368000102yrwf.html?md=gd&wm=3049_0007
而在武汉、湖北以外，据有关报道，除了黄冈市卫健委女主任唐某某被指一问三不知被免职外，2月10日，呼和浩特市已经被公示拟提升为副厅级的卫健委女主任也被免职。而2月11日一早被公开的“湖北省卫健委党组书记主任双双被免职”，恐怕是到目前为止，被问责职务最高的了。

专访卫健委派武汉第二批专家：为何没发现人传人？
http://finance.sina.com.cn/wm/2020-02-26/doc-iimxxstf4577235.shtml

20天，湖北换了3个卫健委主任！
https://news.sina.cn/gn/2020-02-21/detail-iimxyqvz4703931.d.html?from=wap

湖北被免职卫健委女主任：管理学教授 曾在高校任教15年
http://news.ifeng.com/c/7txNnFZqVWD
据央视新闻，2月10日，湖北省委常委会决定：免去张晋的省卫生健康委员会党组书记职务；免去刘英姿的省卫生健康委员会主任职务；上述两职务，由新到任的省委常委王贺胜同志兼任

湖北省卫健委书记被免职 昨日还在参加防治工作会
https://news.163.com/20/0211/10/F53LSRO70001899O.html
据央视报道，2月10日，湖北省委常委会决定，省委常委王贺胜兼任湖北省卫健委党组书记和主任。
免去张晋、刘英姿湖北省卫生健康委员会党组书记和主任职务。
您可透^Yg[器，惠r享用tt18.com及tt28.com 所提供之W上Y服眨热萜贩N繁多，其中有：

港信软件(深圳)有限公司
https://xin.baidu.com/company_detail_31982401048121

捷利港信软件(深圳)有限公司
https://www.11467.com/qiye/27552884.htm

E:\wen_test\dlgtest1\dlgtest1Dlg.cpp(119) : error C2065: 'printf' : undeclared identifier
D:\Program Files\Microsoft Visual Studio\VC98\MFC\Include\AFX.H
// Other includes from standard "C" runtimes
#ifndef _INC_STRING
	#include <string.h>
#endif
#ifndef _INC_STDIO
	//#include <stdio.h>
#endif

眼镜架结构详解 眼镜框各部分的功能介绍
https://www.maigoo.com/goomai/108147.html
一副眼镜架通常由镜圈、鼻托、桩头和镜脚等主要部分构成，除上述部件外，还有脚套、托叶螺丝、铰链螺丝等。

2020.03.11

---- stdio.h Matches (15 in 13 files) ----
Afx.h (vc98\mfc\include):	#include <stdio.h>
Atlbase.h (vc98\atl\include):#include <stdio.h>
Cstdio (vc98\include): #include <stdio.h>
Cstdio (vc98\include): #include <stdio.h>
Dprintf.h (vc98\include):#include <stdio.h>
Edk.h (vc98\include):#include <stdio.h>
Edkdebug.h (vc98\include):#include <stdio.h>
Isapi.cpp (vc98\mfc\src):#include <stdio.h>
Resapi.h (vc98\include):#include "stdio.h"
Snados.h (vc98\include):/* Echo the format of the ifdefs that stdio.h uses */
Stdio.h (vc98\include):*stdio.h - definitions/declarations for standard I/O routines
Stdiostr.h (vc98\include):#include <stdio.h>
Utassert.h (vc98\include):#include <stdio.h>
Wchar.h (vc98\include):*       Note: keep in sync with ctype.h, stdio.h, stdlib.h, string.h, time.h.
Wchar.h (vc98\include):/* also declared in stdio.h */




Find Source PRINTF.C.

printf源码
http://blog.chinaunix.net/uid-24567872-id-87686.html

E:\wendy_work\MsEdit_Wendy\StdAfx.h

// wendy 2020.03.10
#include "Datadef.h"
#include "Resource.h"

指数ETF或行业ETF

我自认为没本事能给大家推荐股票保证稳赢，所以我推荐指数ETF或行业ETF，至少不会被坑（不停牌，不暴雷，寿与天齐）

又一个被训诫的女医生（艾芬）浮出水面
http://www.cbfau.com/cbf-201585990.html

struct AFX_MSGMAP_ENTRY
{
	UINT nMessage;   // windows message
	UINT nCode;      // control code or WM_NOTIFY code
	UINT nID;        // control ID (or 0 for windows messages)
	UINT nLastID;    // used for entries specifying a range of control id's
	UINT nSig;       // signature type (action) or pointer to message #
	AFX_PMSG pfn;    // routine to call (or special value)
#ifdef _AFXDLL
#define BEGIN_MESSAGE_MAP(theClass, baseClass) \
	const AFX_MSGMAP* PASCAL theClass::_GetBaseMessageMap() \
		{ return &baseClass::messageMap; } \
	const AFX_MSGMAP* theClass::GetMessageMap() const \
		{ return &theClass::messageMap; } \
	AFX_COMDAT AFX_DATADEF const AFX_MSGMAP theClass::messageMap = \
	{ &theClass::_GetBaseMessageMap, &theClass::_messageEntries[0] }; \
	AFX_COMDAT const AFX_MSGMAP_ENTRY theClass::_messageEntries[] = \
	{ \

#define ON_COMMAND(id, memberFxn) \
	{ WM_COMMAND, CN_COMMAND, (WORD)id, (WORD)id, AfxSig_vv, (AFX_PMSG)&memberFxn },


#define END_MESSAGE_MAP() \
		{0, 0, 0, 0, AfxSig_end, (AFX_PMSG)0 } \
	}; \

#define PASCAL      __stdcall

struct AFX_MSGMAP
{
#ifdef _AFXDLL
	const AFX_MSGMAP* (PASCAL* pfnGetBaseMap)();
#else
	const AFX_MSGMAP_ENTRY* lpEntries;
};

d:\Program Files\Microsoft Visual Studio\VC98\MFC\Include\AFXWIN.H
#ifdef _AFXDLL
#define DECLARE_MESSAGE_MAP() \
private: \
	static const AFX_MSGMAP_ENTRY _messageEntries[]; \
protected: \
	static AFX_DATA const AFX_MSGMAP messageMap; \
	static const AFX_MSGMAP* PASCAL _GetBaseMessageMap(); \
	virtual const AFX_MSGMAP* GetMessageMap() const; \

#else

BOOL CMsEdit_WendyApp::InitApplication() 
{
	// TODO: Add your specialized code here and/or call the base class
	
#ifdef _AFXDLL
	int i;
#else
	asdfadf
#endif
	return CWinApp::InitApplication();
}


D:\Program Files\Microsoft Visual Studio\VC98\MFC\SRC\APPMODUL.CPP
extern int AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPTSTR lpCmdLine, int nCmdShow);

extern "C" int WINAPI
_tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LP InModalStateTSTR lpCmdLine, int nCmdShow)
{
	// call shared/exported WinMain
	return AfxWinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow);
}
--->
D:\Program Files\Microsoft Visual Studio\VC98\MFC\SRC\WINMAIN.CPP
int AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPTSTR lpCmdLine, int nCmdShow)
{
	ASSERT(hPrevInstance == NULL);

	int nReturnCode = -1;
	CWinThread* pThread = AfxGetThread();
	CWinApp* pApp = AfxGetApp();

	// AFX internal initialization
	if (!AfxWinInit(hInstance, hPrevInstance, lpCmdLine, nCmdShow))
		goto InitFailure;

	// App global initializations (rare)
	if (pApp != NULL && !pApp->InitApplication())
		goto InitFailure;

	// Perform specific initializations
	if (!pThread->InitInstance())
	{
		if (pThread->m_pMainWnd != NULL)
		{
			TRACE0("Warning: Destroying non-NULL m_pMainWnd\n");
			pThread->m_pMainWnd->DestroyWindow();
		}
		nReturnCode = pThread->ExitInstance();
		goto InitFailure;
	}
	nReturnCode = pThread->Run();

InitFailure:
...
	AfxWinTerm();
	return nReturnCode;
}



D:\Program Files\Microsoft Visual Studio\Common\MSDev98\BIN
--->> *.dll 复制缺少的dll动态库文件过去
D:\softs\VC6免安装绿色版\VC6\Common\MSDev98\Bin
(v ok)

用C++的时候，运行的时候总出现SHSQL,DLL 必需的文件不能加载，请重新安装Microsoft Visual C++
https://zhidao.baidu.com/question/386513237.html
你是不是安装的绿色版VC？一般完全安装的VC不会出现这个提示。
绿色版的VC有可能安装的位置（比如D盘）和它自己默认的位置（比如C盘）不一致，导致一些关键的DLL找不到（文件存在，但是它没找到）
可以按照以下方法解决：
点击VC主窗口中的“TOOLS（工具）”―>“Option（选项）”― >“Directories（目录）”重新设置“Excutable Fils、Include Files、Library Files、Source Files”这4个路径。正常情况可能就改个盘符。然后所有硬盘搜索SHSQL.DLL，找到后放进已安装的vc->common->MSDev98->Bin下就可以了。如果没找到，那就在网上搜一个下载，应该很好解决~

VC++6.0 Project Settings --> 选择"Link"属性页
Project Options中将/subsystem:console改成/subsystem:window， 这个选项在哪里？我是中文版的， 找了半天没有啊！！！

关于不同的程序入口，main(), _tmain()，WinMain()，wmain()？
https://blog.csdn.net/camel20/article/details/8481442
我读了MSDN里面的讲解才弄出点眉目了，其实我们以前所写的以main()函数开始的程序都是一个半成品，剩下的也是与系统息息相关的工作由编译器帮我们代劳了。怎么回事呢？编译器是如何帮我们代劳的呢？那么程序被系统加载时，准确的说是被系统中的加载器加载时又是如何知道编译器在我们写的程序上做了手脚呢？难道编译器和加载器之间有什么协定吗？这一些列的问题，做为刚入行的你是否在心里问过自己没有！？

???我们以前写的程序在编译器编译成为一个模块（可能是obj文件或其他形式），然后链接器会将一些所需要的库文件和刚才编译器生成的文件进行链接，最终生成一个exe文件，在所链接的库文件中就包含CRT运行时库，这就是我们今天谈论的主角。在运行时库里面有好一个已经定义如下的函数函数：

（1）mainCRTStartup（或wmainCRTStartup）???????//使用/SUBSYSTEM:CONSOLE 的应用程序

（2）WinMainCRTStartup（或 wWinMainCRTStartup） //使用/SUBSYSTEM:WINDOWS 的应用程序

（3）_DllMainCRTStartup????????????????????????//调用 DllMain（如果存在），DllMain 必须用 __stdcall 来定义

其中w开头的函数时unicode版本的,分割符‘//’后面的是入口点函数匹配的subsystem(msdn中查看subsystem)属性设置。

如果未指定 /DLL 或 /SUBSYSTEM （也就是subsystem选项）选项，则链接器将根据是否定义了 main 或WinMain 来选择子系统和入口点。 函数 main、WinMain 和 DllMain 是三种用户定义的入口点形式。

在默认情况下，如果你的程序中使用的是main()或_main()函数，这链接器会将你的使用（1）中的函数连接到你的exe中；如果你的函数是以WinWain（）函数开始的则连接器使用（2）中的函数连接进exe中；如果我们写的是DLL程序这连接进DLL的是（3）中的函数。

???用我们写的程序最终生成的exe执行时，一开始执行的就是上面的函数之一，而不是我们程序所写的main或WinMain等。那么链接器为什么要这样做呢？这就是因为我们写的程序必须要使用到各种各样的运行时库函数才能正常工作，所有在执行我们自己写程序之前必须要先准备好所需要的一切库，噢，明白了吧，之所以要链接它们是因为他们肩负着很重要的使命，就是初始化好运行时库，准备在我们的程序执行时调用。
...
修改入口点方法：proerties->Linker->Advanced->EntryPoint

如果函数与链接器的SubSystem的属性要一致的：

proerties->Linker->System->SubSystem

如果未指定 /DLL 或 /SUBSYSTEM 选项，则链接器将根据是否定义了 main 或 WinMain来选择子系统和入口点。 函数 main、WinMain 和 DllMain 是三种用户定义的入口点形式。

程序入口点
https://blog.csdn.net/H002399/article/details/46339877
WinMain()是WINDOWS的GUI程序入口,
wmain()是UNICODE版本的main(),
_tmain()是个宏,如果是UNICODE则他是wmain()否则他是main()
 ...

有关WinMainCRTStartup() 函数 [问题点数：0分]
https://bbs.csdn.net/topics/10406514
这个我好象见过有个程序是用汇编写的,最小有500多bytes吧,具体的忘记了,不好意思
WinMainCRTStartup其实是Windows 下 C Run-time 的入口点。
如果您的VC在安装时选择了C Run-time 的sourcecode，
那您可以在vc的目录中找到C Run-time 完整的sourcecode。
如果您觉得整个sourcecode过于庞大，您也可以选择一个小些的
C Run-time 的sourcecode进行阅读例如 tinylib。
tinylib更具体的说明请参考下面资料： 
http://www.microsoft.com/msj/defaulttop.asp?page=/msj/archive/s569.htm


关于main(),wmain(),winMain(),wWinMain(),_tmain(),_tWinMain()的理解。
https://blog.csdn.net/weixin_42732867/article/details/90202174
一般情况下，我们并不知道当前编译环境是否为unicode，这时候我们可以用_tmain()或_tWinMain()来代替main()/wmian()或者winMain()/wWinMain()，因为_tmain()和_tWinMain()函数会根据当前编译环境来决定调用对应的入口函数，比如用_tmain(),这样编译器会根据当前的编译环境是否为unicode来决定调用main()或者wmain(),如果编译器环境是unicode,则调用wmain(),否则调用main()函数。

? ? ?实际上，_tmain和_tWinMain都是宏定义，代码可以简单理解如下：

#ifdef _UNICODE
   #define _tmain     wmain
   #define _tWinMain  wWinMain
#else
   #define _tmain     main
   #define _tWinMain  winMain
 #endif
     这样编译器会自己根据当前编译环境是否为unicode来决定调用哪个入口函数，这样也是为了能够兼容unicode编译环境。
     注：以上为个人理解，如果有什么地方理解错误或者需要改进，希望各位大神不吝赐教！谢谢！ 


void CShowData::OnMenuitemInfo() 
{
	// TODO: Add your command handler code here

	pEINFO =  new CEINFO;

	m_list_data.GetItemText(m_indexOfCell.x,3,pEINFO->strTime,100);
	m_list_data.GetItemText(m_indexOfCell.x,4,pEINFO->strItemCode,100);

	pEINFO->Create(IDD_E_INFO);
	pEINFO->ShowWindow(SW_SHOW);
	
}

void CEINFO::OnClose() 
{
	// TODO: Add your message handler code here and/or call default
	CDialog::OnClose();
	DestroyWindow();
}

void CEINFO::PostNcDestroy() 
{
	// TODO: Add your specialized code here and/or call the base class
	CDialog::PostNcDestroy();
	if (AfxGetMainWnd()->IsWindowEnabled())
	{
		delete this;
	}
}
(v ok)


高信:
不会玩

awendy:
斗地主？象棋？ 


高信:
多年没玩了


awendy:
哦，那还是学习好吧，玩游戏没有进步的。玩个一百年一千年都是一个鸟样的。


awendy:
学习进步不同，一天一个样，学得多想法就多，业务门路就多.....


高信:
主要是没有那个闲情逸致



void CMsEdit_WendyDlg::OnRead() 
{...
	pShowData =  new CShowData;
	pShowData->Create(IDD_SHOWDATA);
	pShowData->ShowWindow(SW_SHOW);
...}

void CShowData::OnCancel() 
{
	// TODO: Add extra cleanup here
	
	CDialog::OnCancel();  //  availd for domodal dialog
	DestroyWindow();
}

void CShowData::PostNcDestroy() 
{
	// TODO: Add your specialized code here and/or call the base class
	CDialog::PostNcDestroy();
	if (AfxGetMainWnd()->IsWindowEnabled())
	{
			delete this;
	}
}
(v ok)

void CShowData::PostNcDestroy() 
{
	// TODO: Add your specialized code here and/or call the base class
	// //InModalState()
	//GetWindowWord(hWnd, GWW_HWNDPARENT);
	//GetParent(); ->IsWindowEnabled()
	//GetParent()->IsWindowEnabled(); v  GetOwner() AfxGetMainWnd()  this->GetParent()
	//或者也可以直接 ::FindWindow( )获取到对话框句柄 ，再::FromHandle( );  if (FromHandle(GetSafeHwnd())->IsWindowEnabled())
	//	if (!((CMsEdit_WendyDlg *)AfxGetMainWnd())->pShowData->IsWindowEnabled())
	if (AfxGetMainWnd()->IsWindowEnabled()) // (v ok)
	{
			delete this;
	}
	CDialog::PostNcDestroy();
}


vc 怎样取得一个模式对话框的指针
https://zhidao.baidu.com/question/554607433533632772.html
这要根据你打开对话框的方式了
比如
CMyDialog* dlg=new CMyDialog();
dlg->DoModal(); //dlg就是模态对话框的指针
或者也可以直接 ::FindWindow( )获取到对话框句柄 ，再::FromHandle( );
BOOL CWnd::IsWindowEnabled() const
{
	ASSERT(::IsWindow(m_hWnd)); 模式状态为真，非模式状态为假出错。
...}
void CShowData::PostNcDestroy() 
{
	// TODO: Add your specialized code here and/or call the base class
	//GetWindowWord(hWnd, GWW_HWNDPARENT);
	//GetParent(); ->IsWindowEnabled()
	//GetParent()->IsWindowEnabled(); v  GetOwner() AfxGetMainWnd()  this->GetParent()
	//或者也可以直接 ::FindWindow( )获取到对话框句柄 ，再::FromHandle( );  if (FromHandle(GetSafeHwnd())->IsWindowEnabled())
	if (!((CMsEdit_WendyDlg *)AfxGetMainWnd())->pShowData->IsWindowEnabled())
	{
			delete this;
	}


MFC获得主窗体和父窗体指针
https://www.cnblogs.com/cxchanpin/p/7306144.html
  MFC编程中经常遇到子窗体向父窗体传递⑹的情况，这就须要获得父窗体的指针。
        例：主对话框CMyMainDlg通过buttonButtonA进入对话框CMyParentDlg。CMyParentDlg在通过buttonButtonB进入对话框CMyChildDlg。如今须要在CMyChildDlg分别L问CMyParentDlg和CMyMainDlg的内容。须要在CMyChildDlg中增加下面两条语句：
        CMyMainDlg    *pMMD = (CMyMainDlg*)AfxGetMainWnd();     //获取主窗体指针
        CMyParentDlg *pMPD = (CMyParentDlg*)this->GetParent();   //获取父窗体指针

        当中，this代表当前窗体指针，指向CMyChildDlg。pMMD和pMPD便是指向主窗体和父窗体的指针。

vc 中如何获得最顶端得窗口指针（也许不是激活状态）
vc 中如何获得最顶端得窗口指针（也许不是激活状态）在vc中的GetForegroundWindow（）可以得到最顶端而且激活的窗口。而我现在需要得到最顶端但不激活的窗口（比如FlashGet的悬浮条）的窗口指针。

vc中如何获得当前窗口句柄 [问题点数：20分，结帖人hbtsm]
https://bbs.csdn.net/topics/20026627
this->m_hWnd;
m_hWnd;
this->GetSafeHwnd

VC中获取窗体句柄的各种方法
https://www.cnblogs.com/mfrbuaa/p/3839822.html

VC父窗口和子窗口
https://blog.csdn.net/rankun1/article/details/51425869
AfxGetMainWnd获取自身窗体句柄

HWND hWnd = AfxGetMainWnd()->m_hWnd;
GetTopWindow
函数功能：该函数检查与特定父窗体相联的子窗体z序（Z序：垂直屏幕的方向，即叠放次序），并返回在z序顶部的子窗体的句柄。
函数原型：HWND GetTopWindow（HWND hWnd）；
⑹：
　　hWnd:被查序的父窗体的句柄。假设该⑹为NULL，函数返回Z序顶部的窗体句柄。
返回值：
    假设函数成功，返回值为在Z序顶部的子窗体句柄。假设指定的窗体无子窗体，返回值为NULL。

GetForegroundWindow
函数功能：该函数返回当前系统的前台窗体的窗体句柄。
函数原型：HWND GetForegroundWindow（VOID）　　
返回值：函数返回前台窗回的句柄。

GetActiveWindow
函数功能：该函数能够获得与调用该方法的线程的消息队列相关的活动窗体的窗体句柄（就是取得当前进程的活动窗体的窗体句柄）。
函数原型：HWND GetActiveWindow（VOID）
返回值：返回值是与调用线程的消息队列相关的活动窗体的句柄。否则，返回值为NULL。

GetSafeHwnd
函数功能：获取某个窗体对象（CWnd的派生对象）指针的句柄（HWND）时，最安全的方法是使用GetSafeHwnd()函数。

IsWindowVisible
函数功能：该函数获得给定窗体的可视状态。

IsWindow：
函数功能：该函数确定给定的窗体句柄是否标示一个已存在的窗体。

FindWindow：
HWND FindWindow(LPCSTR lpClassName,LPCSTR lpWindowName );
⑹：
lpClassName
　　指向一个以null结尾的、用来指定类名的字符串或一个能够确定类名字符串的原子。

SetWindowText：
至于窗体标题的改变，我们能够通过SetWindowText来实现

InModalState
https://baike.baidu.com/item/InModalState/10114789?fr=aladdin
示例编辑
/****************************************************
演示函数原型：pFrame->InModalState();
程序功能说明：将框架设为模式状态。
****************************************************/
//如果框架处于非模式状态
if(!pFrame->InModalState())
{ //获得框架最顶级父窗体
CWnd *pTemp=pFrame->GetTopLevelParent();
BOOL bEnabled=pTemp->IsWindowEnabled();
//如果最顶级父窗体不为活动状态
if(!bEnabled)
{
//将框架设为模式状态
pFrame->BeginModalState();
//激活最顶级父窗体
pTemp->EnableWindow(TRUE);
}
}

2020.03.10

请问如何判断已经显示的窗体是否是模态的? [问题点数：200分，结帖人sonic_andy]
https://bbs.csdn.net/topics/340050646
没有父窗口的模式窗口和非模式窗口还是有区别的
其实真正的模式窗口并非只父窗口被禁用，而是线程内的所有窗口都被禁用
一般情况下，判断某个窗口是否为模式窗口可以这样测试
if iswindowenabled（ Getwindow(hwnd,gw_owner）） ＝0 then 某窗口为模式窗口

其实模态并不是窗口的状态。

模态窗口是这样一组操作的集合：
1 设置调用窗口为主窗口的子窗口
2 将主窗口的Enable设置为False
3 显示调用窗口
你可以用这个思路，获得当前窗口的父窗口，判断它是否Enable。


生粉 编辑 讨论
生粉是食谱中常出现的名词，多是用来勾芡用的，在大陆和台湾使用的生粉是马铃薯粉，在香港使用的生粉为玉米粉。生粉在中式烹调上除了勾芡使食物产生滑润的口感之外，亦常用来做为软化肉质的腌肉料之一。生粉的用途很广，可以作炒菜时的调料，也可以做凉粉，还可以用来摊煎饼，最主要用于肉类原料加工时上浆、勾芡等。
在中餐里就是指淀粉，炒菜时用于勾芡、上浆等， 有多种多样，比如红薯淀粉，川菜中使用的水豆粉，以及玉米淀粉等。生粉就是淀粉，可以有很多种，一般指玉米淀粉。
勾芡的学术概念是：借助淀粉在遇热糊化的情况下，具有吸水、粘附及光滑润洁的特点，在菜肴接近成熟时，将调好的粉汁淋入锅内，使卤汁稠浓，增加卤汁对原料的附着力，从而使菜肴汤汁的粉性和浓度增加，改善菜肴的色泽和味道。

面粉是一种由小麦磨成的粉末。按面粉中蛋白质含量的多少，可以分为高筋面粉、中筋面粉、低筋面粉及无筋面粉。面粉（小麦粉）是中国北方大部分地区的主食。以面粉制成的食物品种繁多，花样百出，风味迥异 。

蓝牙电脑适配器
蓝牙适配器 台式机电脑

羊UDJ J->最简单的没试?

都不是好友，哪里存在黑
---言多必失

你家牛会抽烟不?
许君聪:你有病,你家牛会呀!
那就是着火了

2020.03.09

submit commit

MsEditDlg.cpp

#include "ReadMds.h"
#include "log.h"
#include "Master.h"
#include "DataFile.h"

BOOL g_SendFilePause = FALSE;
CLog g_Log;
Master g_Master;
extern CString logstr;

stdafx.h
https://baike.baidu.com/item/stdafx.h/10326842?fr=aladdin
stdafx的英文全称为：Standard Application Framework Extensions（标准应用程序框架的扩展）。 [1]
编译器通过一个头文件stdafx.h来使用预编译头文件。stdafx.h这个头文件名是可以在project的编译设置里指定的。编译器认为，所有在指令#include "stdafx.h"前的代码都是预编译的，它跳过#include "stdafx. h"指令，使用projectname.pch编译这条指令之后的所有代码。
因此，所有的MFC实现文件第一条语句都是：#include "stdafx.h"。在它前面的所有代码将被忽略，所以其他的头文件应该在这一行后面被包含。否则，你将会得到“No such file or directory”这样让你百思不得其解的错误提示。 [2] 

名称的英文全称为：Standard Application Fram Extend 
stdafx的英文全称为：Standard Application Framework Extensions（标准应用程序框架的扩展）。 [1]

可以看到有3个选项：【创建预编译头】、【使用预编译头】和【不使用预编译头】。

stdafx.cpp肯定选择的是【创建预编译头】

============================================================================

再右击Test.cpp文件，选择【属性】-【C/C++】-【预编译头】-【创建/使用预编译头】

可见，它选择的是【使用预编译头】，下面选的文件是StdAfx.h文件，最下面指明的是pch文件的路径


请问c++中的#include "stdafx.h"是什么意思？
https://blog.csdn.net/lijun5635/article/details/13090341/
编译器认为，所有在指令#include "stdafx.h"前的代码都是预编译的，它跳过#include "stdafx. h"指令，使用projectname.pch编译这条指令之后的所有代码。 因此，所有的MFC实现文件第一条语句都是：#include "stdafx.h"。
当VisualC++编译随后的每个.cpp文件时，它阅读并使用它刚生成的.pch文件。VisualC++不再分析Windowsinclude文件，除非你又编辑了stdafx.cpp或stdafx.h。 
这个技术很精巧，你不这么认为吗？(还要说一句，Microsoft并非是首先采用这种技术的公司，Borland才是。)在这个过程中你必须遵守以下规则： 
当我们使用AppWizard来自动生成某些项目的时候,系统会自动把所需要include的头文件在stdafx.h中先include一下,这样,我们只需要直接include这个stdafx.h文件即可
4 与stdio.h的区别
我们一般用TC或vc编译C程序的时候都要首先包含这个stdio.h头文件，这个头文件里面包含了scanf和printf函数的定义，如果我们不在程序开头include这个文件，那么你调用上面这两个函数就不会成功，它其实和c++中的iostream.h文件的作用差不多的，它们一般都已经在stdafx.h文件中被包含。

stdafx.h
所谓头文件预编译，就是把一个工程(Project)中使用的一些MFC标准头文件(如Windows.H、Afxwin.H)预先编译，以后该工程编译时，不再编译这部分头文件，仅仅使用预编译的结果。这样可以加快编译速度，节省时间。
预编译头文件，把不太变的头文件包含进去，这样以后编译的时候只用编译一次，不变化就不需要重新编译了
如果你的项目设置了“使用预编译头(/Yu)”选项，那么项目中的任何cpp文件的最开头必须要#include stdafx.h，否则编译会出错的，你可以试试
我发现自己养成了一个比较好的习惯，有关编程的事情，一定知其然知其所以然

D:\softs\VC6免安装绿色版\VC6\Common\MSDev98\Bin\MSDEV.EXE (英文版)

Standard Application Fram Extend  
https://blog.csdn.net/mengxiangying504/article/details/4729413
1.你编写的任何.cpp文件都必须首先包含stdafx.h。
1.afxwin.h是MFC编程的必需文件，其中包含如CString，CEdit类运行所必需的头文件，最好保证该句在头文件首行；它还会调用windows.h，改头文件包含有数据类型的定义、API入口点定义和其它有用的参数信息；
3.#define WIN32_LEANAND_MEAN，在windows的头文件中拒绝接受MFC类库，以加速编译时间；
4.afx - afx中的af指的是Application Frame的缩写，曾经有一个技术开发团队专门作Application Frame，后来给这个团队命名用afx，x本身没有含义，只不过构成一个响亮的口号，后来就一直沿用下来。

Fram Extend
FRAM扩展

stdio.h是什么意思？
https://www.php.cn/faq/416714.html
在C语言或C++中，会把用#include的文件的扩展名叫 .h，称其为头文件，stdio.h就是standard input output.header，也就是“标准输入输出头文件”。
stdio.h文件的内容就是一些基本输入输出函数的声明，比如scanf()和printf()函数，你包含了stdio.h，就相当于声明了这些函数，所以你才可以在自己的程序中使用它们。
stdio 就是指 “standard input & output"（标准输入输出）
所以，源代码中如用到标准输入输出函数时，就要包含这个头文件。


include stdafx.h 是什么意思
https://zhidao.baidu.com/question/435733299951089524.html
stdafx.h
1名称的英文全称为：Standard Application Fram Extend

#include "ReadMds.h"
#include "DataFile.h"

class CMsEditDlg : public CDialog
{
// Construction
public:
	CMsEditDlg(CWnd* pParent = NULL);	// standard constructor

	ReadMds* readdlg;
	DataFile* loaddlg;
...
CListBox	m_loglist;
...
	afx_msg void OnReadmds();
	afx_msg void OnLoaddat();
	afx_msg void OnTimer(UINT nIDEvent);
	afx_msg void OnDestroy();
}

CMsEditApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CMsEditApp initialization

BOOL CMsEditApp::InitInstance()
{...
	CMsEditDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
...}


MS.cpp (msedit):CMSApp theApp;
MsEdit.cpp (msedit):CMsEditApp theApp;

MsEdit.dsp

*dlg *.dsp

动手调试 E:\wen_test\hanota2 书写会理解得更好

Please Input Num(>0) of Hanoto: Nun = 1
main call hanoi at step cnt = 1
Over cnt = 1 run_time=0.000571us

Please Input Num(>0) = 2
main call hanoi at step cnt = 2
Over cnt = 3 run_time=0.000656us

Please Input Num(>0) = 29
main call hanoi at step cnt = 268435456
Over cnt = 536870911 run_time=17.245971us

Please Input Num(>0) = 30
main call hanoi at step cnt = 536870912
Over cnt = 1073741823 run_time=34.540466us

Please Input Num(>0) = 35
main call hanoi at step cnt = 17179869184
Over cnt = 34359738367 run_time=1099.520271us

Please Input Num(>0) = 36
main call hanoi at step cnt = 34359738368
Over cnt = 68719476735 run_time=2450.936066us

Please Input Num(>0) =

数位顺序表
https://baike.baidu.com/item/%E6%95%B0%E4%BD%8D%E9%A1%BA%E5%BA%8F%E8%A1%A8/10065233?fr=aladdin
正 10的四十次方
载 10的四十四次方
极 10的四十八次方
恒河沙 代表的是10的五十二次方
阿僧 代表的是10的五十六次方
那由它 代表的是10的六十次方
不可思议 代表的是10的六十四次方
无量 代表的是10的六十八次方
大数 代表的是10的七十二次方
古戈尔 代表的是10的一百次方


个十百千万是什么单位
https://zhidao.baidu.com/question/1754804273950261028.html
个十百千万是计数单位。
我们常用的是十进制计数法，所谓“十进制”就是每相邻的两个计数单位之间的关系是：一个大单位等于十个小单位，也就是说它们之间的进率是“十”。

计数单位依次为 个、十、百、千、万、十万、百万、千万、亿、十亿、百亿、千亿 、兆、十兆、百兆、千兆、京、十京、百京、千京、垓、十垓、百垓、千垓、秭、十秭、百秭、千秭、穰、十穰、百穰、千穰、沟、十沟、百沟、千沟、涧、十涧、百涧、千涧、正、十正、百正、千正、载、
十载、百载、千载、极、十极、百极、千极、恒河沙、十恒河沙、百恒河沙、千恒河沙、阿僧祗、十阿僧祗、百阿僧祗、千阿僧祗、那由他、十那由他、百那由他、千那由他、不可思议、十不可思议、百不可思议、千不可思议、 无量大海、十无量大海、百无量大海、千无量大海、大数、十大数、百大数、千大数。

个十百千万后面是什么
https://zhidao.baidu.com/question/43316805.html
个、十、百、千、万、十万、百万、千万、亿后面接着是十亿、百亿、千亿……
数位表：
兆：代表的是10的十二次方。

京：代表的是10的十六次方。

垓：代表的是10的二十次方。

杼：代表的是10的二十四次方。

穰：代表的是10的二十八次方。

沟：代表的是10的三十二次方。

涧：代表的是10的三十六次方。

无量：代表的是10的六十八次方。

大数：代表的是10的七十二次方。


解决typedef unsigned long long DDWORD; 在VC下编译不过问题。
C/C++的64位整型
https://blog.csdn.net/scholety/article/details/22876417
在C/C++中，64为整型一直是一种没有确定规范的数据类型。现今主流的编译器中，对64为整型的支持也是标准不一，形态各异。一般来说，64位整型的定义方式有long long和__int64两种(VC还支持_int64)，而输出到标准输出方式有printf(“%lld”,a)，printf(“%I64d”,a)，和cout << a三种方式。
本文讨论的是五种常用的C/C++编译器对64位整型的支持，这五种编译器分别是gcc(mingw32)，g++(mingw32)，gcc(linux i386)，g++(linux i386)，Microsoft Visual C++ 6.0。可惜的是，没有一种定义和输出方式组合，同时兼容这五种编译器。为彻底弄清不同编译器对64位整型，我写了程序对它们进行了评测，结果如下表。


vc6.0下64位整数_Int64的应用
https://blog.csdn.net/abchcd/article/details/4552004
vc6.0下是不能编译通过long long 的,
欲用64位整型,可以加以下宏
#if defined (_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS  >=  64
typedef signed?? __int64??? int64; 
typedef unsigned  __int64 uint64; 
#else 
#error  __int64?? type?? not?? supported?
#endif 
以下为输出
printf("%I64d",test);


_INTEGRAL_MAX_BITS

C++编译器的预定义宏（WINDOWS版、LINUX版）
http://www.sunyuping.cn/?p=121

Visual C++从入门到实践(配光盘1张)
作者: 葛亮

Visual C++从入门到实践本书源文件
https://download.csdn.net/download/u010565021/6566023

2020.03.06

计算64层汉诺塔需要多长时间？
https://www.zhihu.com/question/48015041
java,最下边有源码圆盘10  移动了1023次    结束时间-开始时间的毫秒数:  0(0-1之间)圆盘20  移动了1048575次   结束时间-开始时间的毫秒数:  2圆盘25  移动了33554431次  结束时间-开始时间的毫秒数:  39圆盘30  移动了1073741823次  结束时间-开始时间的毫秒数:  1386圆盘35  移动次数超出int最大值...(34359738367)  结束时间-开始时间的毫秒数:  38315圆盘40没有尝试,按照这个规律恐怕是在10分钟以上

作者：天子第一号
链接：https://www.zhihu.com/question/48015041/answer/917571616
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


对于汉诺塔问题最快的计算机需要多长时间？ [问题点数：20分，结帖人wangmin_yjitx]
https://bbs.csdn.net/topics/30322935
移动次数是2^64-1，约为16*10^18次。
就算一次移动只需1个机器时间，按目前的万亿次计算机来算（当然啦！这种计算机你是没机会用的。），需要16*10^6秒，（一万亿是十的12次方），所以只要半年就可以了。

但按慢的算，假如用P4 2.4GHz的CPU，每3个指令周期计算一步（访问一次内存就得3个指令周期），则需要2*10^10秒（2.4G/3是8*10^8），也就是634年。

你说的10^9年（你记错了吧？应该是10^11年）是指僧侣搬盘子，按每秒搬一次计算，假如一天24小时，一年365天，不停地搬，需要5.85*10^11年。


把google的分布式系统拿过来算这个，他们的速度可以达到10万亿亿次每秒（当然要改程序啦），30年大概可以计算10的31次方，所以可以计算100阶
https://bbs.csdn.net/topics/60495261

汉诺塔：移动64块需要多少时间
在汉诺塔中，如果要移动60块的，至少要移动多少次才能完成，还有如果假设是一秒移动一次，那需要多少时间来完成？
https://zhidao.baidu.com/question/562976303.html
准确的来说是2的64次方减一次，584,942,417,355年26天7小时15秒
移64层的汉诺塔需2^64 -1=18,446,744,073,709,551,615步
如果是一秒一次的话，那么就是18,446,744,073,709,551,615秒。

error C2632: 'long' followed by 'long' is illegal
https://blog.csdn.net/shine1998/article/details/78701483
原因：

因为 VC6中所使用的编译器是C90标准的，而?long long 型是在C99中新加入的


（longlong int双长整型是C 99扩充的数据类型，同时扩充的还有float_complex，double_complex，long

long_complex，bool等），
故无法实现编译。（――此答案搜索于百度）



解决办法：

将long long 用 _int64 进行替换。

unsigned _int64 cnt;


怎样定义较大的整数，比如1亿 [问题点数：100分]
https://bbs.csdn.net/topics/392392631?page=1	
定义longlong a,b,c.
unsigned long long的最大值：1844674407370955161
long long的最大值：9223372036854775807
最小取值则是负数



c语言中，int型数据，能表示的最大十进制数是多少
https://zhidao.baidu.com/question/554665214323167252.html
除了int类型之外，还有short、long、long long类型可以表示整数。


c语言测试程序执行时间
https://blog.csdn.net/qiuchenl/article/details/8276994

C语言中如何看运行时间 [问题点数：20分]
https://bbs.csdn.net/topics/320067672
GetTickTime  该函数返回系统启动的时间,精确到毫秒

C语言测试程序运行时间――高精度
https://blog.csdn.net/ysz171360154/article/details/88086328

C语言 计算/测程序运行时间（精确到微秒）
https://blog.csdn.net/lizehao1973/article/details/85456872
#include<stdio.h>
#include <Windows.h>
int main() {
	int a[10002];
	int i = 0;
	double run_time;
	LARGE_INTEGER time_start;	//开始时间
	LARGE_INTEGER time_over;	//结束时间
	double dqFreq;		//计时器频率
	LARGE_INTEGER f;	//计时器频率
	QueryPerformanceFrequency(&f);
	dqFreq=(double)f.QuadPart;
	QueryPerformanceCounter(&time_start);	//计时开始
	for( i = 1; i <= 10000; i++)a[i]=i;	//要计时的程序
	QueryPerformanceCounter(&time_over);	//计时结束
	run_time=1000000*(time_over.QuadPart-time_start.QuadPart)/dqFreq;
	//乘以1000000把单位由秒化为微秒，精度为1000 000/（cpu主频）微秒
	printf("\nrun_time：%fus\n",run_time);
	return 0;
}


我想知道我的一段C语言代码执行了多长时间(精确到0.01豪秒) [问题点数：50分，结帖人yyttrr2007]
https://bbs.csdn.net/topics/350239336
可以采取多次循环求平均
#include<stdio.h>
#include<time.h> 
clock_t start = clock();
for(int i = 0; i< 1000; i++)
{
.... yourfunction();
}
clock_t end = clock();

yourtime = (end - start)/1000;
这个肯定能精确到0.01ms


ao3同文网站用本名写黄文
肖战粉丝举报ao3 那些把同人当黄文的,
写黄文的是肖战粉丝，阅读传播的是肖战粉丝，举报的是肖战粉丝，倒霉的是ao3
https://bbs.hupu.com/32795021.html

上百度查下就知道了，发的同人文章又黄又恶心，毒害青少年@阿文

备注：AO3是全世界文人交流的平台，不做任何思想限制，随意发挥创作的一个平台，被称为文学界里面最后的乌托邦。
H文我给大家推荐少妇白洁和《金鳞岂是池中物》，

对于递归有没有什么好的理解方法？
https://www.zhihu.com/question/31412436
用数学代入法来理解就好。
很简单，把式子展开即可：
f(6)
=> 6 * f(5)
=> 6 * (5 * f(4))
=> 6 * (5 * (4 * f(3)))
=> 6 * (5 * (4 * (3 * f(2))))
=> 6 * (5 * (4 * (3 * (2 * f(1)))))
=> 6 * (5 * (4 * (3 * (2 * 1))))
=> 6 * (5 * (4 * (3 * 2)))
=> 6 * (5 * (4 * 6))
=> 6 * (5 * 24)
=> 6 * 120
=> 720
看到递归了吗？
先递进，再回归――这就是「递归」。
以上是 SICP 原文（有删改）。
编辑于 2019-07-07
https://www.zhihu.com/question/31412436/answer/738989709


// hanota.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
//
//int main(int argc, char* argv[])
//{
//	printf("Hello World!\n");
//	return 0;
//}

#include <iostream>
#include <cstdio>
using namespace std;
 
int cnt;
 
void move(int id, char from, char to) // 打印移动方式：编号，从哪个盘子移动到哪个盘子
{
    printf ("step %d: move id=%d from %c->%c\n", ++cnt, id, from, to);
}
 
void hanoi(int n, char x, char y, char z)
{
    if (n == 0)
        return;
    hanoi(n - 1, x, z, y);
    move(n, x, z);
    hanoi(n - 1, y, x, z);
}
 
int main()
{
    int n;
    cnt = 0;
	printf ("Please Input Num(>0) of Hanoto: Nun = ");
    scanf ("%d", &n);
	while(n > 0)
	{
		hanoi(n, 'A', 'B', 'C');

		printf ("\nPlease Input Num(>0) = ");
		scanf ("%d", &n);
		cnt = 0;
	}
    return 0;
}


陈情令

肖战名下工作室均已注销, 代言产品遭网友抵制, 这是怕要凉凉啊!
http://k.sina.com.cn/article_7132918298_1a927b21a00100m4ns.html

肖战227事件怎么回事？王一博肖战著名711事件是什么
http://www.hxnews.com/news/yule/202003/04/1867604.shtml


肖战怎么了？全程回顾“227事件”，看他因何从顶红流量变成全民公敌？
https://new.qq.com/omn/20200304/20200304A0D0V900.html
事情至此，欧美、日韩、动漫、同人文、耽美等等圈子的创作者们揭竿而起，反对肖战粉丝举报创作平台，本来大家的圈地自萌，因为肖战粉丝按下的“举报”键，平衡彻底被打破，一场227圣战的起义，已经在各圈点燃火炬。


汉诺塔问题――递归（时隔9个月，终于懂了）
https://blog.csdn.net/qq_41705423/article/details/82025409

汉诺塔
https://baike.baidu.com/item/%E6%B1%89%E8%AF%BA%E5%A1%94/3468295?fr=aladdin

2020.03.05

C语言怎么把自定义头文件添加到函数库中
https://zhidao.baidu.com/question/757998494001014524.html
你可以把你的头文件复制到 stdio.h 所在的文件夹，并 修改 编译器自带的 stdio.h，
在 stdio.h 的 尾部 加一句 #include 你开发的头文件名 即可。以后，凡使用 stdio.h 就自动有了 你开发的头文件了。
这个操作很简单，但你要有管理员特权，才能修改stdio.h。
如果 可以自己 写 #include ...; 你可以 把自己开发的 头文件写在 自己 的 一个文件夹。把自己的文件夹路径 加入到 环境变量 INCLUDE 中。例如文件夹路径是 d:\my_head 用 命令：
set INCLUDE=%INCLUDE%;d:\my_head
就可加入。 使用头文件 用 #include <my_some.h>
my_some.h 是你开发的头文件之一，存放在 d:\my_head\ 下面。

c语言中如何将自定义库导入到标准库中？ 100
https://zhidao.baidu.com/question/385485520.html
我没试过，这是从别的地方粘过来的，你试试看
1,写文件“*.h”，文件“*.c”，文件.c中为函数实现；文件.h中为文件声明；
2，把该函数编译为.dll的一个入口函数;
3，提供*.lib,*.dll,*.h，三个文件；
4，把*.dll放到Path目录下；
5，把*.lib包含入工程，*.h，include到工程；
6，可以使用你写的函数；
什么编程软件？如果是Tc的话，把自定义的库放入库includ目录中，然后再程序中直接引用就成了，很简单.
直接放到标准库所在的目录即可

C语言中怎样把用户自定义的函数添加到标准函数库中？
https://zhidao.baidu.com/question/11615498.html
把你写的函数保存成*.h文件，用的时候再include
找到系统标准函数库,在其中添加你的函数,当然这不是真的标准函数STDIO.H了

C语言自定义库函数
C 语言自定义库
c语言中如何将自定义库导入到标准库中？
用户函数加入到库函数

常见排序算法
https://baike.baidu.com/item/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/5399605#4

各种排序算法性能比较
https://www.cnblogs.com/alamps/p/8473815.html

各种排序算法比较
https://www.cnblogs.com/lizr-ithouse/p/5839384.html

总结5种比较高效常用的排序算法
https://blog.csdn.net/hl_java/article/details/72499914

为什么快速排序比堆排序要快？
https://blog.csdn.net/nawuyao/article/details/52729518

八种排序算法效率比较
https://blog.csdn.net/m372897500/article/details/51478136

用cl工具编译MFC程序
https://blog.csdn.net/weixin_34015860/article/details/91974225

VC的编译器是cl.exe，这就是说调试器叫什么名字
http://m.myexception.cn/vc-mfc/1313437.html
调试器是devenv.exe。可以在命令行下使用，举例：Devenv.exe /debugexe MyApplication.exe
其实devenv.exe也是IDE，devenv是开发环境的缩写
两者没有分开

使用cl.exe在windows控制台下编译C++程序
https://blog.csdn.net/a10929/article/details/78171483?utm_source=blogxgwz1
工具
cl.exe 是控制 Microsoft C 和 C++ 编译器与链接器的 32 位工具。编译器将.cpp编译，生成中间代码目标文件(.obj)。链接器将目标文件链接，产生可执行文件 (.exe) 或动态链接库文件 (DLL)。

link.exe 是将目标文件和库链接起来以创建 32 位可执行 (.exe) 文件或动态链接库 (DLL) 的 32 位工具。

rc.exe 是将windows资源文件(.rc)编译成资源文件(.res),从而与目标文件链接，一般用于设置exe文件的图标和属性或者dll包含的资源。

lib.exe是将目标文件链接生成静态库文件(.lib)，也可以用于生成dll的lib文件。

环境配置
那么这4个exe文件在哪个目录下呢？我的vs装在了E盘，然后我在 E:\vs2013\VC\bin 目录下找到了cl.exe，link.exe，lib.exe，但是没找到rc.exe，于是我在C盘看了看，结果在C:\Program Files (x86)\Windows Kits\8.1\bin\x64 目录下找到了，后来我又发现这些exe似乎不止一份，在很多目录下都有，真奇怪。。。好吧，找到了后把所在目录加入Path环境变量就可以了。

光这样还不行，还得把一些头文件和lib库也加入环境变量，目录如下：

//这4个加入INCLUDE环境变量
E:\vs2013\VC\include;
C:\Program Files (x86)\Windows Kits\8.1\include\shared 
C:\Program Files (x86)\Windows Kits\8.1\include\um 
C:\Program Files (x86)\Windows Kits\8.1\include\winrt

//这2个加入LIB环境变量
E:\vs2013\VC\lib
C:\Program Files (x86)\Windows Kits\8.1\Lib\winv6.3\um\x64

使用
以生成dll为例：

先用cl命令将.cpp编译成.obj，-c选项的作用：只编译不链接，不然cl还会试图链接生成exe，但dll工程根本没有main函数，没法生成exe，所以就会出错了。
cl -c dllmain.cpp dllclass.cpp
如果有资源文件(.rc)，那么用rc.exe将.rc编译成.res
rc dllsource.rc
用link命令将.obj .rc等文件 链接，生成dll文件及对应的.lib .exp
link -dll dllmain.obj dllclass.obj dllsource.res

gcc 和VC++有什么区别呢，VC++编译时用的编译器 相当于gcc的是什么东西 
https://zhidao.baidu.com/question/241197025937086524.html
vc的编译器是CL 当还有其他的 clang 神马 你没必要搞清楚 你只要知道 vc好用易用 但是要钱买 ，express版、d版除外
gcc 不要钱 、开源、你感觉自己够强了可以去 研究其源代码

VC++和DEV都是集成开发环境，VC++是Windows平台最权威的开发工具，而dev就是新手练手用的。至于Gcc是Gun的一个项目，它是一个编译器，主要用在Linux中，它是跨平台的

C/C++ 开发环境和工具
https://www.iteye.com/blog/yanguz123-2178510

15 款最好的 C/C++ 编译器和集成开发环境
https://www.cnblogs.com/lonelyxmas/p/9083296.html

C/C++开发者必备：十款免费集成开发环境IDE
https://blog.csdn.net/dj0379/article/details/52451837
集成开发环境（IDE，Integrated Development Environment）



Visual Studio c++语言特点：
Visual Studio c++是由Microsoft启动的开发环境。Visual Studio c++可用于在Windows平台上创建Windows应用程序和网络应用程序，以及创建网络服务、智能设备应用程序和Office插件。Visual Studio是最流行的Windows平台应用程序开发环境。
Visual Studio c++6.0之后包括各种增强功能，例如Visual Designer（加速开发使用）。NET Framework 3.5），对Web开发工具的实质性改进，以及语言增强，可以加速所有类型数据的开发和处理。Visual Studio 为开发人员提供了所有相关的工具和框架支持，以帮助创建引人注目、令人印象深刻且支持Ajax的Web应用程序。

开发人员可以使用这些富客户端和服务器端框架轻松构建以客户端为中心的Web应用程序。这些应用程序可以集成任何后端数据提供程序，在任何当前浏览器中运行，并且可以完全访问ASP NET应用程序服务和Microsoft平台。



vc6.0中的dsp,dsw,ncb,opt,clw,plg,aps等文件的简单说明
https://blog.csdn.net/qq_35583007/article/details/81947906

.CLW   文件是VC   Class   Wizard信息文件。存放了Class   Wizard的信息。 

.NCB   文件是分析器信息文件，是由系统自动产生的。 

.OPT   文件是IDE的Option文件。 

.APS   文件是资源文件的二进制版本。 

 

.clw   支持ClassWizard 

.ncb   支持ClassView 

.opt   保存工作空间的配置 

.aps   支持ResourceView

.bsc   浏览器信息文件 

.dsp   项目文件 

.dsw   工作空间文件 

.mak   外部的创建文件 

.plg   建立日志文件 

 

.opt 工程关于开发环境的参数文件。如工具条位置等信息；

.aps (AppStudio File),资源辅助文件,二进制格式,一般不用去管他.

.clw ClassWizard信息文件,实际上是INI文件的格式,有兴趣可以研究一下.有时候ClassWizard出问题,手工修改CLW文件可以解决.如果此文件不存在的话,每次用ClassWizard的时候绘提示你是否重建.

.dsp (DeveloperStudio Project):项目文件,文本格式,不过不熟悉的话不要手工修改.DSW(DeveloperStudio Workspace)是工作区文件,其他特点和DSP差不多.

.plg 是编译信息文件,编译时的error和warning信息文件（实际上是一个html文件）,一般用处不大.在Tools->Options里面有个选项可以控制这个文件的生成.

.hpj (Help Project)是生成帮助文件的工程,用microsfot Help Compiler可以处理.

.mdp (Microsoft DevStudio Project)是旧版本的项目文件,如果要打开此文件的话,会提示你是否转换成新的DSP格式.

.bsc 是用于浏览项目信息的,如果用Source Brower的话就必须有这个文件.如果不用这个功能的话,可以在Project Options里面去掉Generate Browse Info File,可以加快编译速度.

.map 是执行文件的映像信息纪录文件,除非对系统底层非常熟悉,这个文件一般用不着.

.pch (Pre-Compiled File)是预编译文件,可以加快编译速度,但是文件非常大.

.pdb (Program Database)记录了程序有关的一些数据和调试信息,在调试的时候可能有用.

.exp 只有在编译DLL的时候才会生成,记录了DLL文件中的一些信息.一般也没什么用.

.ncb 无编译浏览文件(no compile browser)。当自动完成功能出问题时可以删除此文件。build后会自动生成。



vc6.0中dsp,dsw,ncb,opt,clw,plg,aps等文件的简单说明
https://blog.csdn.net/alongwilliam/article/details/27205701

.CLW文件

VC Class Wizard信息文件，存放了Class Wizard的信息。 ClassWizard信息文件，实际上是INI文件的格式,有兴趣可以研究一下。有时候ClassWizard出问题,手工修改CLW文件可以解决。如果此文件不存在的话,每次用ClassWizard的时候会提示你是否重建。

.NCB文件

无编译浏览文件(no compile browser)，当自动完成功能出问题时可以删除此文件。build后会自动生成。

.OPT文件

IDE的Option文件，工程关于开发环境的参数文件，如工具条位置等信息，保存工作空间的配置 。

.APS文件

资源文件的二进制版本，资源辅助文件，一般不用去管他。

.clw文件

支持ClassWizard。

.ncb文件

支持ClassView。

.aps文件

支持ResourceView。

.bsc文件

浏览器信息文件，用于浏览信息文件，如果用Source Brower的话就必须有这个文件。如果不用这个功能的话,可以在Project Options里面去掉Generate Browse Info File，可以加快编译速度。

.dsp文件

DeveloperStudio Project，项目文件，文本格式，不过不熟悉的话不要手工修改。

.dsw文件

DeveloperStudio Workspace，是工作区文件，其他特点和DSP差不多。

.mak文件

这是MFC项目的项目文件，这也是与NMAKE兼容的文件。如果选择了External make文件可选项，则可人工对它编辑，但不能利用Visual C++许多项目编辑特性。

.plg文件

建立日志文件，是编译信息文件，编译时的error和warning信息文件（实际上是一个html文件），在Tools->Options里面有个选项可以控制这个文件的生成。

.hpj文件

Help Project，是生成帮助文件的工程，用microsfot Help Compiler可以处理。

.mdp文件

Microsoft DevStudio Project，是旧版本的项目文件，如果要打开此文件的话，会提示你是否转换成新的DSP格式。

.map文件

是执行文件的映像信息纪录文件，除非对系统底层非常熟悉，这个文件一般用不着。

.pch文件

Pre-Compiled File，是预编译文件，可以加快编译速度，但是文件非常大。

.pdb文件

Program Database，记录了程序有关的一些数据和调试信息，在调试的时候可能有用。

.exp文件

只有在编译DLL的时候才会生成，记录了DLL文件中的一些信息。

转自：http://lang.9sssd.com/vcpp/art/1455



Source Insight 中文注释为乱码解决办法（完美解决，一键搞定）
Source Insight中文注释为乱码解决办法
https://www.cnblogs.com/jing1617/p/7525823.html
我网上查了一堆解决办法，但是都是2017年以前的，并且都是针对于source insight 3.5及以下版本的解决方案，软件版本都到4.0了，应该有新方法出现。
干货：Source Insight 4 的解决办法(source insight 3.5 及以下版本就到其他地方看看吧)
【解决办法】：

单个文件乱码解决办法：

      菜单栏中【File】 > 【Reload As Encoding...】 > 【Chinese Simplified (GB18030)】 > 选择后，点击load，问题解决！！！

所有文件乱码解决办法：

    我的理解，在做下面操作的时候，先设置，然后关闭所有打开的文件，然后再打开文件即可

    菜单栏中 【Options】 > 【Preferences】 >File标签中，最下面的“Default encod-ing” ：改成System Default(Windows ANSI)
    或者Chinese Simplified(GB2312) CP:936，点击确定，问题解决！！！


source insight 中文乱码的解决方案
https://jingyan.baidu.com/article/ae97a646a5e499bbfc461d54.html

source insight中文注释乱码问题的解决方案
https://cloud.tencent.com/developer/article/1417198
解决方案如下：
一、单个文件转换
对于单个文件，好说，只要将非ANSI码格式的文件转换成ANSI码格式即可，方法如下：
 1、将文件用ultraEdit32打开，选择 文件->转换->UTF-8到ANSI， 然后保存。重新用source insight打开就好了。
或者使用记事本打开非ANSI格式的源代码文件，另存为，在保存选项对话框中，在编码格式一栏中发现是UTF-8，选择ANSI一项，保存，再用Source Insight打开就可以正常显示中文注释了。具体可参考百度经验的一篇文章：source  insight 中文乱码的解决方案。(v ok)

access密码忘了怎么办

https://www.xiazaizhijia.com/news/20171006/132153_all.html
简易APV密码查看.zip
https://dl.pconline.com.cn/download/2283680.html
https://dl.pconline.com.cn/download/2283680-1.html

今天推荐个电视剧给大家，《安家》，孙俪，海清出演(阿文_黄文敏)

公路美人 换一批
https://zhidao.baidu.com/question/749936665102364652.html
《公路美人》作为一部公路题材的纯爱电影，开篇就必须要有一个极大的矛盾冲突，才会使这群人上路，而本片的开场却让人使料未及，以一档名叫《爱上你》的相亲节目开始，美女作家安东妮为了推销新书假装单身参加电视相亲，并与相恋三年的男友曾浩签署了协议。然而安东妮为了追求对浪漫不切实际的憧憬，在节目中违背协议与藏族摄影师秀巴牵手，并且非常任性的选择了不辞而别。一次偶然的劈腿，打开了一条追爱之路。

2020.03.04

怎样查看git本地仓库所有文件目录
盘符根目录下查找 gitk.cache

const关键字及其作用（用法），C语言const详解
http://c.biancheng.net/view/217.html
说 const 定义的是变量，但又相当于常量；说它定义的是常量，但又有变量的属性，所以叫常变量。用 const 定义常变量的方法很简单，就在通常定义变量时前面加 const 即可，如：const  int  a = 10;
const 和变量类型 int 可以互换位置，二者是等价的，即上条语句等价于：
int  const  a = 10;

用 const 定义的变量的值是不允许改变的，即不允许给它重新赋值，即使是赋相同的值也不可以。所以说它定义的是只读变量。这也就意味着必须在定义的时候就给它赋初值。用 const 修饰的变量，无论是全局变量还是局部变量，生存周期都是程序运行的整个过程。

我们知道，局部变量存储在栈中，静态变量存储在静态存储区中，而经过 const 修饰过的变量存储在内存中的“只读数据段”中。只读数据段中存放着常量和只读变量等不可修改的量。const定义的是变量，而define定义的是常量。define定义的宏在编译后就不存在了，它不占用内存，因为它不是变量，系统只会给变量分配内存。但const定义的常变量本质上仍然是一个变量，具有变量的基本属性，有类型、占用存储单元。可以说，常变量是有名字的不变量，而常量是没有名字的。有名字就便于在程序中被引用，所以从使用的角度看，除了不能作为数组的长度，用const定义的常变量具有宏的优点，而且使用更方便。所以编程时在使用const和define都可以的情况下尽量使用常变量来取代宏。


C语言中const用法解析
https://blog.csdn.net/he__yuan/article/details/81607804
一、修饰局部变量
二、常量指针与指针常量
常量指针说的是不能通过这个指针改变变量的值，但是还是可以通过其他的引用来改变变量的值的。
int a=5;
const int* n=&a;
a=6;
(常量指针指向的值不能改变x)，但是这并不是意味着指针本身不能改变，常量指针可以指向其他的地址。
int a=5;
int b=6;
const int* n=&a;
n=&b;
指针常量是指指针本身是个常量，不能在指向其他的地址，写法如下：
int *const n;
需要注意的是，指针常量指向的地址不能改变，但是地址中保存的数值是可以改变的，可以通过其他指向改地址的指针来修改。
int a=5;
int *p=&a;
int* const n=&a;
*p=8;
区分常量指针和指针常量的关键就在于星号的位置，我们以星号为分界线，如果const在星号的左边，则为常量指针，如果const在星号的右边则为指针常量。如果我们将星号读作‘指针’，将const读作‘常量’的话，内容正好符合。int const * n；是常量指针，int *const n；是指针常量。

是以上两种的结合，指针指向的位置不能改变并且也不能通过这个指针改变变量的值，但是依然可以通过其他的普通指针改变变量的值。
const int* const p;
三、修饰函数的参数
四、修饰函数的返回值
五、修饰全局变量


int main(int argc,char*argv[])中argc/argv怎么填写 [问题点数：40分，结帖人zoueryu]
https://bbs.csdn.net/topics/390939712
在IDE中：
VC6：
 工程、设置、Debug、U程序变量：填写命令行参数。
VS20XX：
 项目、属性、配置属性、调试、命令参数：填写命令行参数。

在使用时：
cmd窗口中执行命令：
cd /d 你的程序所在盘符和目录
你的程序 参数1 参数2 "参数 3"

快捷方式、属性、目标：你的程序 参数1 参数2 "参数 3"

相关注册表项：你的程序 参数1 参数2 "参数 3"

百里挑一

关于int main( int argc, char* argv[] ) 中arg和argv参数的解析及调试
https://blog.csdn.net/dgreh/article/details/80985928
一、argc、argv的具体含义 
        argc和argv参数在用命令行编译程序时有用。main( int argc, char* argv[], char **env ) 中 
        第一个参数，int型的argc，为整型，用来统计程序运行时发送给main函数的命令行参数的个数，在VS中默认值为1。 
        第二个参数，char*型的argv[]，为字符串数组，用来存放指向的字符串参数的指针数组，每一个元素指向一个参数。各成员含义如下： 
        argv[0]指向程序运行的全路径名 
        argv[1]指向在DOS命令行中执行程序名后的第一个字符串 
        argv[2]指向执行程序名后的第二个字符串 
        argv[3]指向执行程序名后的第三个字符串 
        argv[argc]为NULL 
        第三个参数，char**型的env，为字符串数组。env[]的每一个元素都包含ENVVAR=value形式的字符串，其中ENVVAR为环境变量，value为其对应的值。平时使用到的比较少。
#include <stdio.h>
using namespace std;
int main(int argc, char ** argv)
{
    int i;
    for (i = 0; i < argc; i++)
        printf("Argument %d is %s\n", i, argv[i]);
    return 0;
}


C语言中的可变参数函数 三个点“…”
https://www.cnblogs.com/sticker/p/9988237.html
问题：运行时才确定的参数 
　　有没有办法写一个函数，这个函数参数的具体形式可以在运行时才确定？ 
　　答案与分析： 
　　目前没有"正规"的解决办法，不过独门偏方倒是有一个，因为有一个函数已经给我们做出了这方面的榜样，那就是main()，它的原型是: 
int main(int argc,char *argv[]); 
函数的参数是argc和argv。 

C语言学习小结--参数个数可变的函数
https://blog.csdn.net/mr_bean_1031/article/details/75912050
观察printf函数的原型，除了一个指向字符型常量地址（刚好是字符串常量的类型）的指针外，还有一个省略号，问题就出在这里。
与可变参数表相关的头文件是标准C库头文件”stdarg.h”，表示standard arguments（标准参数），找到里面几个用到的宏：

宏名称	描述	兼容
va_list	创建一个va_list类型变量	C89
va_start(v,l)	使va_list指向起始的参数	C89
va_arg(v,l)	检阅参数	C89
va_end(v,l)	释放va_list	C89
va_copy(v,s)	拷贝va_list的内容	C99
设一个可变参数表函数void func(int a, ...)。在使用可变参数表前，必须用va_list定义一个变量（假设变量名为ap），然后调用va_start(v,l)令ap指向该参数表的起始地址，va_start的第一个参数是va_list类型的变量ap，第二个参数是省略号前最后一个变量的变量名，初始化完成后就可以调用va_arg(v,l)依次检索参数了。va_arg的第一个参数是va_list类型的变量ap，第二个参数是将要检索的变量的类型名（如int，其本质是在内存中截取int长即2字节的数据赋给返回值后ap指向2字节以后的地址）。在检索完所有的参数后必须调用va_end(v)，使ap指向NULL（空指针），避免越界访问的问题。C99提供额外的宏”va_copy”，它能够复制va_list。而va_copy(v ,s)函数作用为拷贝s到v。

#include <stdio.h>
#include <stdarg.h>
/*用于测试可变参量表的打印函数，仅调用了putchar(int)函数*/
void print_test(char *string, ...);
/*将整数转换成字符串，value为输入的整形变量，s保存转换结果，radix = 10表示十进制，其他输出NULL*/
static char* inter2string(int value, char *s, int radix);
int main()
{
    int a = -67;
    char st[6];
    inter2string(a, st, 10);
    printf("%s\n", st);
    print_test("Tell me %s teleph%cne number:-n153 1418 %d-r188-n", "your", 'o', 1234);
    return 0;
}
/*--------------------------------------
  examples:
  print_test("%d.Sunny-r-nHello", inter);
---------------------------------------*/
void print_test(char *string, ...)
{
    int a;   //用来接收整形变量 
    char iTos[6];  //用来存放字符串型整数 
    char *c = string;  //避免直接使用string，导致string指向的地址发生变化 
    const char *s;  //用来指向指针常量，即字符串 
    va_list ap;  //定义一个va_list类型变量ap
    va_start(ap, string);  //初始化va，使va指向string的下一个地址 
    while(*c != '\0')
    {
        if(*c == '-')  //'-'，自定义的转义字符起始符 
        {
            switch(*++c)
            {
                case 'n':
                    putchar('\n');
                    break;
                case 'r':
                    putchar('\r');
            }
        } 
        else if(*c == '%')  //格式控制符 
        {
            switch(*++c)
            {
                case 'd':
                    a = va_arg(ap, int);  //检索变量
                    inter2string(a, iTos, 10);
                    for(s = iTos; *s != '\0'; s++)
                        putchar(*s);
                    break;
                case 'c':
                    a = va_arg(ap, char);
                    putchar(a);
                    break;
                case 's':
                    s = va_arg(ap, const char*);
                    while(*s != '\0')
                        putchar(*s++); 
            }
        }
        else
        {
            putchar(*c);
        }
        c++;  //指向下一个地址 
    }
    va_end(ap);   //不要忘记关闭ap
}

谁能详细讲解一下参数数量可变的函数 [问题点数：100分，结帖人earlier]
https://bbs.csdn.net/topics/60179018
我来抛砖引玉^_^
va_list是一种用来保存宏va_start,va_arg,va_end需要信息的数据类型，也就说要调用这几个宏就必须先申请一个va_list类型的数据
void va_start( va_list ap, argN ),该宏要在访问被省略的参数(就是...代表的部分啦)前调用，这样就初始化了ap，供后面的va_arg,va_end使用，而argN就是...之前的哪个参数啦
va_arg( va_list ap, type ),这个宏就是从被省略的部分的第一参数开始往后去参数，每调用一次就取得一个参数，ap就是va_start初始化的ap，type就是取得参数的类型，如果type与函数调用提供的参数类型不一致，结果不可预知

const

想睡时，动脑筋？

C 可变参数
https://www.runoob.com/cprogramming/c-variable-arguments.html
请注意，函数 func() 最后一个参数写成省略号，即三个点号（...），省略号之前的那个参数是 int，代表了要传递的可变参数的总数。为了使用这个功能，您需要使用 stdarg.h 头文件，该文件提供了实现可变参数功能的函数和宏。
定义一个函数，最后一个参数为省略号，省略号前面可以设置自定义参数。
在函数定义中创建一个 va_list 类型变量，该类型是在 stdarg.h 头文件中定义的。
使用 int 参数和 va_start 宏来初始化 va_list 变量为一个参数列表。宏 va_start 是在 stdarg.h 头文件中定义的。
使用 va_arg 宏和 va_list 变量来访问参数列表中的每个项。
使用宏 va_end 来清理赋予 va_list 变量的内存。


C语言_宏定义
https://blog.csdn.net/qq_41865229/article/details/86746707
#ifndef xxx //如果没有定义xxx
#define xxx //定义xxx
#endif //结束如果
“##”是一种分隔连接方式，它的作用是先分隔，然后进行强制连接。
宏参数中若包含另外的宏，那么宏参数在被代入到宏体之前会做一次完全的展开，除非宏体中含有#或##。

有如下宏定义：

#define A(y) X_##y
#define B(y) A(y)
#define SIZE 1024
#define S SIZE
1
2
3
4
A(S)会被展开成X_S。因为宏体中含有##，宏参数直接代入宏体。
B(S)会被展开成X_1024。因为B(S)的宏体是A(S)，并没有#或##，所以S在代入前会被完全展开成1024，然后才代入宏体，变成X_1024。

BOOL CLog::RawLogExt( LPCTSTR pszFormat, ... ) 
{
    char buf[1024*2] = "" ;
	va_list arglist;
	va_start(arglist, pszFormat);
    _vsnprintf( buf, 2048, pszFormat, arglist);
	va_end(arglist);

	return RawLog( buf ) ;
	
}

C语言中宏定义的使用
https://blog.csdn.net/imgosty/article/details/81901183#1-%E5%BC%95%E8%A8%80
C 语言提供的预处理功能有三种,分别为==宏定义==、文件包含和条件编译。
在 C 语言中,宏分为 有参数和无参数两种。无参宏的宏名后不带参数,其定义的一般形式为:
// 不带参数的宏定义
#define MAX 10
/*带参宏定义*/
#define M(y) y*y+3*y
/*宏调用*/
k=M(5);
宏定义只有在定义所在文件，或引用所在文件的其它文件中使用。 而全局变量可以在工程所有文件中使用，只要再使用前加一个声明就可以了。换句话说，宏定义不需要extern。
使用带参数的宏定义可完成函数调用的功能，又能减少系统开销，提高运行效率。
宏定义可完成简单的操作，但复杂的操作还是要由函数调用来完成，而且宏定义所占用的目标代码空间相对较大。
宏的定义很容易产生二义性，如：定义==#define S(a) (a)*(a)==，代码==S(a++)==，宏展开变成==(a++)*(a++)==这个大家都知道，在不同编译环境下会有不同结果。
函数体内有Bug，可以在函数体内打断点调试。如果宏体内有Bug，那么在执行的时候是不能对宏调试的，即不能深入到宏内部。
C++中宏不能访问对象的私有成员，但是成员函数就可以。
内联函数和宏的区别在于，==宏是由预处理器对宏进行替代 #80001e==，而==内联函数是通过编译器控制来实现的 #80000f==。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的==展开==，所以取消了函数的参数压栈，减少了调用的开销。可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。

内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样了。
对宏体和给引用的每个参数加括号，就能避免这问题。
通过==do{…}while(0) #80001e==能够解决上述问题
 宏参数重复调用
有如下宏定义：

#define min(X, Y)  ((X) < (Y) ? (X) : (Y))
1
当有如下调用时==next = min (x + y, foo (z));==，宏体被展开成==next = ((x + y) < (foo (z)) ? (x + y) : (foo (z)));==，可以看到，foo(z)有可能会被重复调用了两次，做了重复计算。更严重的是，如果foo是不可重入的(foo内修改了全局或静态变量)，程序会产生逻辑错误。
对自身的递归引用
有如下宏定义：

#define foo (4 + foo)
1
按前面的理解，==(4 + foo)==会展开成==(4 + (4 + foo))==，然后一直展开下去，直至内存耗尽。但是，预处理器采取的策略是只展开一次。也就是说，foo只会展开成==4 + foo==，而展开之后foo的含义就要根据上下文来确定了。

对于以下的交叉引用，宏体也只会展开一次。

#define x (4 + y)
#define y (2 * x)
1
2
x展开成(4 + y) -> (4 + (2 * x))，y展开成(2 * x) -> (2 * (4 + y))。

注意，这是极不推荐的写法，程序可读性极差。
在宏体中，如果宏参数前加个#，那么在宏体扩展的时候，宏参数会被扩展成字符串的形式。如：
#include <stdio.h>


#define PSQR(x) printf("the square of "#x" is %d.\n",((x)*(x)))

#define PSQR2(x) printf("the square of %s is %d.\n",#x,((x)*(x)))


int main() 
{
    
int R=5;

    
PSQR(R);  //the square of R is 25.
    
PSQR2(R); // the square of R is 25.

    
return 0;

}

#include "stdafx.h"
#define PSQR(x) printf("the square of #x is %d.\n",((x)*(x)))
#define PSQR2(x) printf("the square of %s is %d.\n",#x,((x)*(x)))
#define WARN_IF(EXPR)\
do {\
    if (EXPR)\
        fprintf(stderr, "Warning: EXPR \n");\
} while(0)

int main(int argc, char* argv[])
{
	int R=5;
	printf("Hello World!\n");
	PSQR(R);  //the square of R is 25.
    	PSQR2(R); // the square of R is 25.
	WARN_IF(R>0);
 	return 0;
}

可变宏：… 和_VA_ARGS
有些函数(如==prinft() #06906d==)可以接受可变数量的参数。

  int __cdecl printf(const char * __restrict__ _Format,...);
1
实现思想就是在宏定义中参数列表的最后一个参数作为省略号（三个句号）。这样，预定义宏_VA_ARGS就可以被用在替换部分中，以表明省略号代表什么，

可变数量的参数

   __FUNTION__  获取当前函数名 
    __LINE__ 获取当前代码行号 
    __FILE__ 获取当前文件名 
    __DATE__ 获取当前日期 
    __TIME__ 获取当前时间
    __STDC_VERSION__


易中天：别望子成龙，要望子成人 
https://www.sohu.com/a/60126055_356623
第二是善良。善良不是说要你到街头去做什么义工，或者学雷锋的那天去扶老太太过街。善良的底线是恻隐之心。恻隐之心就是不忍之心，不忍心人家受到

无辜的伤害，包括对小动物。所以不但不能行凶杀人，也不能虐待小动物。我们要在法律上保证公民的恻隐之心不受伤害。
第四个就是快乐。快乐是非常重要的。在孔夫子那里，做人的最高境界是仁，做事的最高境界是权（权衡），治学的最高境界是乐。知之者不如好之者，好之者不如乐之者，快乐是最高的境界。其实人很简单，成功不成功，是否出人头地，是否光宗耀祖，都不重要，重要的是你是否快乐。
比方说现在为什么千军万马过独木桥，大家都要去考公务员呢？我非常同情大学生毕业以后挤破脑袋去考公务员，虽然我不赞成，但是我非常理解非常同情，他缺乏的是安全感。
有一个农村来的孩子就这样对记者说的，我也不想考公务员，但是我爸我妈让我考。我爸我妈说，孩子，你要考上公务员，咱在村里就不受欺负了。他要的就是一个安全感。
所以我们的社会应该给每个公民提供足够的安全感，让每个公民有足够的尊严，不管他从事哪个职业，不管他在哪个岗位上，他都是一个安全的、有尊严的人，这样他才能快乐。

美卫生局局长说戴口罩会增加普通人感染风险，呼吁民众停止购买
https://new.qq.com/omn/20200303/20200303A021A300.html?pgv_ref=aio2015&ptlang=2052

source insight的特定变量,宏定义等黑色,怎么办
//public:  //注释掉这个关键字即可.
或 隔离public 十个空白行以上即可(v ok)

微信娱乐看太多，影响计划看书.

2020.03.03

C语言中宏定义的使用
https://blog.csdn.net/imgosty/article/details/81901183?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task

C语言中宏定义的使用
https://blog.csdn.net/imgosty/article/details/81901183


C语言宏定义的几个坑和特殊用法
https://blog.csdn.net/qq997843911/article/details/62042697
宏体换行需要在行末加反斜杠\
宏名之后带括号的宏被认为是宏函数。
展开后的代码有利于CPU cache的利用和指令预测，速度快。缺点是可执行代码体积大。

C语言宏的特殊用法和几个坑
https://blog.csdn.net/miaomao1989/article/details/77481981
AFTERX(BUFSIZE)会被展开成X_BUFSIZE。因为宏体中含有##，宏参数直接代入宏体。
XAFTERX(BUFSIZE)会被展开成X_1024。因为XAFTERX(x)的宏体是AFTERX(x)，并没有#或##，所以BUFSIZE在代入前会被完全展开成1024，然后才代入宏体，变成X_1024。


如下解决在在source insight中，一般即使鼠标点在函数或者变量处，context windows窗口就会显示其定义信息。
其中绿色的变量或者函数，鼠标一点击，就能看到其定义。黑色的则看不到的问题(v ok)

D:\Program Files\Source Insight 3\C.tom
; wendy add
FUNC_DECL(factory_name) DECL_##factory_name

E:\wendy_work\MsEdit_Wendy\ShowData.cpp
#define FUNC_DECL(factory_name) DECL_##factory_name
...
void FUNC_DECL(FactoryA) (void)
{
	int i, j;
	i = 0;
	j = 1;
}

void FUNC_DECL(FactoryB) (void)
{
	int i, j;
	i = 0;
	j = 1;
}
...
int CShowData::op_delay(_tagTTDataFrame *pStFrame)
{
	DECL_FactoryA();
	DECL_FactoryB();
...
}

Source Insight解析Linux内核的c.tom文件内容
https://blog.csdn.net/nust20/article/details/46486947?locationNum=4
在C:\Documents and Settings\XXXX\My Documents\Source Insight目录下的C.tom文件中增加如下内容（需要不断完善，碰到不能解析的宏时添加进来）。
添加后，关闭SourceInsight工程，重新打开，重新同步。


source insight宏定义函数名显示问题 [问题点数：50分]
https://bbs.csdn.net/topics/392500161
本义是一套代码工程内，有多个模块功能类似，但是函数名不同，为了便于快速批量修改函数名，增加了这个宏定义。
这样修改函数名，只需要修改FUNC_DECL宏就行了，即针对T模块，把FUNC_DECL改成： FUNC_DECL(name) T_##name
这样改，编译是通过了，但是在source insight里面，显示不出函数名，如何才能显示出函数名全称，即能够包含模块名称的？
Source Insigh目录，其中有一个C.tom文件。修改该文件，在其中增加一行：
FUNC_DECL
试试

Source Insight 不能识别变量定义怎么解决？ [问题点数：40分，无满意结帖，结帖人Swordsemperor]
https://bbs.csdn.net/topics/392276081?page=1
解决了，因为类声明后面加了个宏定义 SHIT

source insight的特定变量,宏定义等黑色,怎么办
//public:  //注释掉这个关键字即可.(v ok)

/*
!% 
!?CChartingGroup.m_groupCode		[.] 类CChartingGroup属性: 市场代码
*/
	BYTE			m_groupCode ;	

https://zhidao.baidu.com/question/572897720.html
菜单中选择 Project -> Rebuild Project -> Re-Create the whole project from scratch -> OK
然后再看看是否好了.

在source insight中黑色变量的解决办法
https://blog.csdn.net/sishuirensheng66/article/details/35280513
在source insight中，一般即使鼠标点在函数或者变量处，context windows窗口就会显示其定义信息。
如下图所示，其中绿色的变量或者函数，鼠标一点击，就能看到其定义。
黑色的则看不到，可是我的这里面黑色的占了很大一部分比重.
解决方法：
没有同步文件，在“项目”（Project）->“同步文件”（Synchronize Files）。并勾1、2和4项，然后OK。就可以了


source insight 里的函数有时候会突然变黑
https://blog.csdn.net/chen_chuang_/article/details/48462615?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task
找到原因了方法自然就有了：project -> add and remove project files 重新把整个工程的代码添加下，然后同步。ok。

2020.03.02

天眼查
https://www.tianyancha.com/?jsid=SEM-BAIDU-PZ2001-SY-000001
浙江省义乌市廿三里街道通宝路1341号附近公司
实缴资本	100万人民币
法定代表人：杨秋兴 注册资本：100万人民币成立日期：2012-03-13
翁易华


开机黑屏只有鼠标,小编教你电脑开机黑屏只有鼠标箭头怎么解决
http://www.xiaobaixitong.com/win10jiaocheng/25651.html
电脑黑屏是比较容易出现的现象，尤其在一些较老的电脑或组装电脑中。如果你的电脑开机出现了黑屏，但是鼠标箭头可以动，那么可能就是explorer.exe系统文件造成的问题。
在打开的注册表编辑器窗口，依次展开：HKEY_Local_MACHINE\Software\Microsoft
在Microsoft的展开项中再依次展开：Windows NT\CurrentVersion
在CurrentVersion的展开项中找到：Winlogon，并左键单击：Winlogon
在Winlogon对应的右侧窗口，找到Shell，左键双击Shell，如果Shell的数值数据为：explorer.exe，则是正确的，如果不是explorer.exe，则把Shell的数值数据更改为：explorer.exe（如还有其它字符，请删除），再点击：确定

电脑开机后进入不了桌面只显示一个黑屏和鼠标箭头
https://zhidao.baidu.com/question/1241360265800857699.html
同时按“ctrl+shlft+exc”键，调出任务管理器。
点击任务管理器左下角的“详细信息”。
然后点击左上角“文件”里的“运行新任务”。
弹出新窗口，输入“explorer.exe”，然后点击“确定”。
以上就是电脑开机黑屏只有鼠标的解决办法，当然，上述方案不是对所有电脑都有用，因为电脑黑屏的原因有很多种，这里只是其中的几种解决办法。
1、可以直接使用“Ctrl + Shift + Esc”快捷键直接打开任务管理器程序；
2、弹出任务管理器后，在“进程”选项卡中找到“explorer.exe”进程；
3、选中“explorer.exe”点击下方的“结束进程”按钮，关闭资源管理器；
4、然后点击左上角的“文件”打开菜单，选择“新建任务(运行)”；
5、之后会弹出“新建新任务”窗口，输入刚刚关闭的进程名称“explorer.exe”，点击确定即可。

(3)如果通过手动启动explorer资源管理器不起作用，那可能是explorer被破坏了，可到备份中或系统光盘中提取个explorer.exe，或者到网上下载，也可以到其它电脑上复制一个放在C:\Windows下。如果上面的方法还不行，那就只有重做系统了。

做电脑维修多年了，这种情况是因为不正常关闭了桌面系统，造成了开机只有鼠标箭头和黑屏，Explorer可以新建一个。看看行不行，实在不行开视频指导看下。送修也就30-50.


疫情开始在日本全国蔓延？日本为什么不让3000多人下船？
https://baijiahao.baidu.com/s?id=1658756112490425875&wfr=spider&for=pc
考虑之一，这不是日本船
在日本政府看来，如果单放乘客入境，不让船员入关，有歧视之嫌；如果破例放这艘“外国船”自由入关，那么总得对其他邮轮一视同仁，而以日本为目的地的外国邮轮不在少数（2月份原定就有13艘），其中总有途经中国而乘客中出现发热咳嗽的，如果前例一开，后患将无穷――在别国被拒绝入境的邮轮，可能转道直奔日本来求助。事实上，日本2月6日拒绝了经停香港的荷兰“威士特丹”号邮轮的靠泊请求，后者只能在柬埔寨西哈努克港栖身。

考虑之二，日本医疗资源配给跟不上
尽管日本是长寿之国，应对各种灾难事故门儿清，但全国能收治新冠肺炎的病床有限（估计不到2000张）
检测试剂也不可能按需拨给“钻石公主”号，所以马上对邮轮上逾3700人一一检测，以便他们及早下船，就成了不可能的任务。
就算邮轮上的乘客以日本人为主（1200多人），但在检测时也不能单独给日本人开口子，否则有碍国际观瞻，邮轮经营方也不会轻易答应。而如果按照轻重缓急排队检测，那么很大部分被检测者并非日本国民，却要消耗掉日本目前有限的检测资源，这在工作优先度上就会被打折扣――哪怕国际上沸反盈天，日本政府都要先满足已入境的本国国民的需求。
换句话说，假设全体乘客上岸了，同样会被限制在小范围内活动，且服务人员未必有邮轮上那么周到，而日本国的应急医疗资源是向已确诊者倾斜的，普通邮轮乘客还是稍安勿躁为妙。

考虑之三，离日本首都圈近在咫尺
若等绝大多数乘客上岸后再进行甄别和收治，的确可以减少在邮轮密闭空间内的交叉感染概率，但却增加了病毒在日本本土扩散的风险。
尤为重要的是，横滨港背靠人口超过4000万的东京湾城市群，从这里打车去东京羽田机场不过十多分钟。若新冠病毒在这个日本的经济中枢暴发，有可能令日本经济整体陷入瘫痪。
我们还可以对比2011年福岛核电站事故。如果说，陆上核泄露范围相对固定，对首都圈影响不大，那么靠泊在横滨港的这艘英美邮轮，就相当于一座可移动的核电站，在关停之前如果任意移动潜在感染人群，后果将不堪设想。

以上种种思虑，可能主导了日方的“封船”决定。同时，日方也有3点疏忽，受到了诸多批评，所以后来做了某些变通和调整。

首先，负责“接诊”的日本厚生劳动省，动作不够麻利。
日方怀着侥幸心理，在邮轮从香港抵达冲绳时，对每一位乘客与船员测了体温，说是“太平无事”（实际上是潜伏期）；

其次，高估了“钻石公主”号自身的防护、隔离措施。
“公主邮轮公司”所做的，除了提供免费的无线网络和室内娱乐活动，就是退还乘客旅行费用，同时免收隔离期间的餐饮住宿费，再送下次搭乘的优惠券；对于乘务人员，承诺其在乘客隔离期间工作日加薪2倍，以后允许所有船员带薪休假两个月。
钱的确能安抚部分人心，但阻止不了病毒扩散。邮轮上的英美人士，并不像亚洲人那么好说话。来自英国的婚礼策划师大卫・阿贝尔（David Abel），在脸书上定时直播船上情况，一度表示自己与妻子已经超过14小时没有获得食物。

众目睽睽之下，“邮轮惊魂”不仅拷问着日本的“战疫”力，也关系到东京奥运会能否正常举行――目前已有多项奥运预选赛受到疫情影响推迟举行。东京奥运被认为将吸引国内外约1000万游客，如果疫情无法平息，或者海外观感不佳，现有的巨额投入将会打水漂……




借力打力，复这边贴那边......（象棋，微信...）呵呵



电脑开机黑屏只有一个鼠标箭头处理办法
https://jingyan.baidu.com/article/6fb756ec87ce0c241858fb11.html
同时按下shift+alt+delete键或shift+ctrl+esc键调用任务管理器程序。
打开任务管理器，然后选择”进程“选项卡,在进程中找到 explorer.exe 个进程。
点击结束进程按钮，结束该进程。
点击文件-新建任务。
在弹出的对话框中输入”explorer.exe“，点击确定。
计算机中毒了，或是启动项太多了，杀毒，或者实在不行，重新做系统吧
这种情况大多数是系统问题，但出在那没实地看说不清

平凡的世界
https://baike.baidu.com/item/%E5%B9%B3%E5%87%A1%E7%9A%84%E4%B8%96%E7%95%8C/166?fr=aladdin
平凡的世界 （路遥著长篇小说） 编辑 讨论92
《平凡的世界》是中国作家路遥创作的一部百万字的小说。这是一部全景式地表现中国当代城乡社会生活的长篇小说，全书共三部。1986年12月首次出版。
该书以中国70年代中期到80年代中期十年间为背景，通过复杂的矛盾纠葛，以孙少安和孙少平两兄弟为中心，刻画了当时社会各阶层众多普通人的形象；劳动与爱情、挫折与追求、痛苦与欢乐、日常生活与巨大社会冲突纷繁地交织在一起，深刻地展示了普通人在大时代历史进程中所走过的艰难曲折的道路。1991年3月，《平凡的世界》获中国第三届茅盾文学奖。2019年9月23日，该小说入选“新中国70年70部长篇小说典藏”。 [1]

养成想到就做的习惯: 万卷网站. 93VC1 98VC6 200多个类库.4号线和3号线少年宫.wizard typical等.

工程->设置->连接
D:\Johnny\W2T20140130c\DataCenter\bin\MsEdit.exe
工程->设置->调试
D:\Johnny\W2T20140130c\DataCenter\bin\MsEdit.exe

GetModuleFileName
https://baike.baidu.com/item/GetModuleFileName/9585201?fr=aladdin
GetModuleFileName 编辑 讨论
获取当前进程已加载模块的文件的完整路径，该模块必须由当前进程加载。
如果想要获取另一个已加载模块的文件路径，可以使用GetModuleFileNameEx函数。


AI换脸产业链起底,可定制女明星不雅视频,150元打包700部视频

https://baijiahao.baidu.com/s?id=1639369194218993604&wfr=spider&for=pc
不雅视频将女明星AI换脸成主角售卖：迪丽热巴，杨幂，赵丽颖，佟丽娅，刘亦菲，Angelababy......

海关发现男子所带花生不对劲 剥开壳一看直接惊呆
https://wxn.qq.com/cmsid/AUS2020021700606401

一个月！广东口罩日产量从不足十万涨到逾二千万
https://new.qq.com/omn/20200227/20200227A0PXQ900.html?pgv_ref=aio2015&ptlang=2052

2020.02.28 

小米之家维修小米手机基带多少钱
https://zhidao.baidu.com/question/1769392383725435300.html
100～200元左右吧

淘来一个小米8，有通病基带版本未知没信号，拆解我教你修复它
https://www.iqiyi.com/v_19rvxtlw8k.html

网上寄修米8，本来只是基带坏了，他把我整个cpu都修坏了该怎么弄？
http://tieba.baidu.com/p/6115558680
除了官方其他都是坑，修好了还好，修不好就说你咬我呀！我修电脑也遇见过
我现在手机以后除了官方维修其他一律不信，我小米6摔爆屏拿去修，屏幕不是原装，然后手机还留下一些毛病比如闹钟不响，打手机不响等等，边框我记得之前是没痕的，修了以后多了几道深痕，我看十成是换了，后盖也被换了，整台手机怕不是能换都换了，换一些次品给我，我没法只好买小米9了

小米8老是没网，又是无线都断网，而且没有信号，一直无服务状态，这是怎么回事，怎么修理，跪求
http://tieba.baidu.com/p/6076365784?pn=1
贴吧用户_00G9CMt: 修了吗，我的也是，维修说是我摔得问题，要我500块，还没修 2019.12.09
青春染指浮华丶: 我也是一模一样，去售后说我主板坏了要修我主要200还不一定修好卧槽 2019.12.17

求助 小米八有一点发热就断网 数据wifi失灵
http://tieba.baidu.com/p/6494405626?pid=130017305151&cid=#130017305151

维修点地址：深圳市龙华新区和平路宝银坊商场L2-53号（龙华地铁站D出口）深圳市龙瑞贸易商行
售后服务电话：0755-88863922/29560669 预约维修
区域：广东深圳龙华新区
营业时间：10:00-18:00（支持周三晚8点服务）
售后维修产品类型：小米手机维修,小米平板维修,小米笔记本维修,小米扫地机器人,小米全系产品维修


小米8修个基带小米8基带坏了怎么修？（看简介）？
https://www.zhihu.com/question/372920555
这是小米8的通病，有很多小米8用户都出现类似状况。例如WiFi无法打开，sim卡不识别等情况。这一般都是因为基带虚焊引起的，可以修。建议前往当地比较大的修理店。去了直接说手机基带可能虚焊了，价格在150左右。不要被骗换主板！不要被骗换主板！不要被骗换主板！

作者：花自飘零水自流
链接：https://www.zhihu.com/question/372920555/answer/1028844903


小米8没有信号WIFI打不开，设置显示基带版本未知，看大神如何完美修复它
https://www.bilibili.com/video/av89530814/


小米8信号断断续续有时候打电话发不出去，接也接不了。这是卡的问题还是手机的问题啊
http://tieba.baidu.com/p/6074881895
辣鸡小米 我的也一样故障，突然就没信号了，售后说基带坏了，换主板1000多，以后誓死不买小米！售后太辣鸡！


退货服务。 使用服务星期六  499元.

我那时候就看过杨思敏

北京一女子确诊，22日从武汉回京，此前发热多日！她是怎么离开武汉的？
https://mp.weixin.qq.com/s/ayQ33VXBrn4-IQjL9jIuQw
这个北京新冠确诊女人成为撞上风口的猪了。全国人民都看着这头飞上天的飞天猪如何摔下来了。
这新闻还真是疫情期间的一个炸弹。 所有被封城不满的情绪都会发泄在这些关系人身上了。

2020.02.27

查找:A00013 文件:today_A.dat

		if( strcmp( head.fileType, "chartingDayData" )!=0 || ( head.ver!=0.0 && head.ver!=0.1 )  )
			goto ErrExit ;


GroupsMng.dll
Groupmng.dll
查找其中的一部分.问沟通节省研究时间(v ok)

BOOL Master::CreateGroupsMng()
{
	if( m_pGroupsMng!=NULL )
		return TRUE ;
	
	HRESULT ret = CoCreateInstance( CLSID_TTGroupsMng, 
		NULL, CLSCTX_ALL,
		IID_IUnknown, (LPVOID*)&m_pGroupsMng );
	int n=GetLastError();
	if( ret!=S_OK || m_pGroupsMng==NULL )
	{
		m_pGroupsMng = NULL ;
		g_Log.Log("Groupmng.dll load fail!");
		return  FALSE ;
	}
	
	g_Log.Log("Groupmng.dll Ok.");
	CComQIPtr<ITTObject,&IID_ITTObject> pObj(m_pGroupsMng);

缺少组件: Groupmng.dll

2020-02-26 15:12:08(27256416), ==========================Start==========================
2020-02-26 15:12:42(27290424), Groupmng.dll load fail!
2020-02-26 15:22:37(27885724), ==========================Start==========================
2020-02-26 15:22:44(27892058), Groupmng.dll load fail!
2020-02-26 15:28:41(28248863), ==========================Start==========================
2020-02-26 15:28:44(28252358), Groupmng.dll load fail!


int (*a)[10] 和 int *a[10] 的区别
https://blog.csdn.net/u014183456/article/details/80348217
首先,int *a[10]  :   是数组指针,本质上就是数组元素是是个int型指针的一维数组,
int (*a)[10] :   a是指针，指向一个数组。此数组有10个int型元素


结构体的声明，定义及其初始化，C语言结构体完全攻略
http://c.biancheng.net/view/241.html

C/C++ typedef用法详解（真的很详细）
https://blog.csdn.net/andrewniu/article/details/80566324
第一、四个用途
用途一：
定义一种类型的别名，而不只是简单的宏替换。
用途二：
用在旧的C的代码中（具体多旧没有查），帮助struct
用途三：
用typedef来定义与平台无关的类型。
比如定义一个叫 REAL 的浮点类型，在目标平台一上，让它表示最高精度的类型为：
typedef long double REAL; 
在不支持 long double 的平台二上，改为：
typedef double REAL; 
用途四：
为复杂的声明定义一个新的简单的别名。
方法是：在原来的声明里逐步用别名替换一部分复杂声明，如此循环，把带变量名的部分留到最后替换，得到的就是原声明的最简化版。举例：
2. 原声明：void (*b[10]) (void (*)());
变量名为b，先替换右边部分括号里的，pFunParam为别名一：
typedef void (*pFunParam)();
再替换左边的变量b，pFunx为别名二：
typedef void (*pFunx)(pFunParam);
原声明的最简化版：
pFunx b[10];
理解复杂声明可用的“右左法则”：
从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：
int (*func[5])(int *);
func 右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个*，说明func的元素是指针（注意这里的*不是修饰func，而是修饰 func[5]的，原因是[]运算符优先级比*高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组的元素是函数类型的指 针，它指向的函数具有int*类型的形参，返回值类型为int。
也可以记住2个模式：
type (*)(....)函数指针 
type (*)[]数组指针
...
同样，可以象下面这样隐藏指针语法：
typedef char * pstr;int mystrcmp(pstr, pstr);
这里将带我们到达第一个 typedef 陷阱。标准函数 strcmp()有两个‘const char *’类型的参数。因此，它可能会误导人们象下面这样声明 mystrcmp()：int mystrcmp(const pstr, const pstr); 
这是错误的，按照顺序，‘const pstr’被解释为‘char * const’（一个指向 char 的常量指针），而不是‘const char *’（指向常量 char 的指针）。这个问题很容易解决：
typedef const char * cpstr; int mystrcmp(cpstr, cpstr); // 现在是正确的
#define与typedef引申谈 
　　1) #define宏定义有一个特别的长处：可以使用 #ifdef ,#ifndef等来进行逻辑判断，还可以使用#undef来取消定义。 
　　2) typedef也有一个特别的长处：它符合范围规则，使用typedef定义的变量类型其作用范围限制在所定义的函数或者文件内（取决于此变量定义的位置），而宏定义则没有这种特性。
 

2020.02.26

 QuickHider(快速隐藏任务栏图标工具)
http://mydown.yesky.com/pcsoft/413546249.html


电影《速度与激情8》详细剧情第1章：多一个朋友很重要
https://www.tvmao.com/movie/YmRnayRe/chapter


骑自行车专心一直向前，转弯或偏移要看旁边（专心）。经理传的项目没复制（向前想）

读MDS数据Dlg->添加文件->删除文件->读取数据->显示结果数据Dlg:
一直显示 search....ListIndex = 0, GetIndex=递增(x no)
void CShowData::OnTimer(UINT nIDEvent) 
{...
	if (InitClistGetHead == FALSE)
	{
		ps = mCListDataFrame.GetHeadPosition();  // wendy
		InitClistGetHead = TRUE;
	}
...}(v ok)

五一之前，不管新闻怎么说，防控怎么降级，尽量减少出门次数，出门带口罩，进门消毒，出去买菜一次多买点，不要天天出去，在家运动，必须上班的，单位和家两点一线，别乱逛，单位工作时刻警惕，口罩带好，别坐公交，别上饭店，别串门，为什么？一、到现在还没有特效药；二、治疗好的出院后还有反复；三、每天还是百人死亡；四、无症状患者的存在；五、病毒发源地不在武汉；六、疫苗最快四月底才临床试验，成功否还要验证半年；七、病毒排查试剂盒有效率才百分之五十；八、最长潜伏期有达到27天的；九、新冠病毒可能会与人类长期共存；十、该病毒不光影响肺部和呼吸，对心脏等其他脏器也有严重影响；十一、其他国家确证人数也在上升；十二、口罩还是买不到，医院除急诊和发热呼吸科外，其他科室都先停诊。以上所说的，希望我的家人们，要保持高度警惕，国家放松控制，允许人员流动，那是考虑国家经济方面，没办法再封村封路封小区，年前各类生产企业屯的库存也即将消耗殆尽，不开始生产，人们的日常生活所需接济不上，要保社会稳定，必须开工复工，但是不代表这场战役结束了，老人们身体弱，有很多基础病，要少出门，在家做运动，这个时候怕生病，医院诊所都不开！
(wx)

2020.02.25

中国各有多少个省和自治区和直辖市
https://zhidao.baidu.com/question/1705615336985242380.html
截至2018年10月1日，中国一共有34个省级行政区，包括23个省、5个自治区、4个直辖市、2个特别行政区。
23个省：河北省、山西省、辽宁省、吉林省、黑龙江省、江苏省、浙江省、安徽省、福建省、江西省、山东省、河南省、湖北省、湖南省、广东省、海南省、四川省、贵州省、云南省、陕西省、甘肃省、青海省、台湾省。
5个自治区：内蒙古自治区、广西壮族自治区、西藏自治区、宁夏回族自治区、新疆维吾尔自治区。
4个直辖市：北京市、天津市、上海市、重庆市。
2个特别行政区：香港特别行政区、澳门特别行政区。


MFC总结之CListCtrl用法及技巧（二） .
https://www.cnblogs.com/lidabo/archive/2012/08/23/2652792.html

MFC总结之CListCtrl用法及技巧（一） .
https://www.cnblogs.com/lidabo/archive/2012/08/23/2652786.html

MFC CListCtrl不响应LVN_GETDISPINFO消息
https://blog.csdn.net/kiss_xq/article/details/51019402?locationNum=11&fps=1
好吧，深呼吸，程序员是不怕坑的。总结一下：
在CListCtrl Create了之后再去设置LVS_OWNERDATA目测是没有用的，必须在Create的时候就把这个style写上。

last和latest做最新的，最近的时有什么区别
https://zhidao.baidu.com/question/100723010.html?qbl=relate_question_5&word=lastest

最新滚动新闻_网易新闻中心
http://news.163.com/latest

读书的方法和技巧 高效读书的10种方法
http://www.gaosan.com/gaokao/227405.html
读书不二法
波浪渐进法
比较品读法
垂直阅读法:因为有些书含金量太少，只用浏览。更快的方法也称之为“跳读“
字斟句酌法:用眼睛来读书只有眼见，用心去读书才有心得。字斟句酌法特别适合读经典。
精华提炼法:读完一本书，如果真能够提炼出几句有用的话来，就算没有白读。
高山仰止法:以欣赏的眼光读书，读出乐趣。
居高临下法
多维研读法
举一反三法:如何把书读活？“我思故我在，我用故我能。”
“我思”的第一个层次是要与作者交流，与作者擦出火花；第二个层次是要讲给别人听、写给别人看，与众人擦出火花。“我用”的第一个层次是理论指导自己的实践，让自己受益；第二个层次是在用中发现新问题，找到新方法，创造出新理论，超越前人。


其实 什么事情 兴趣是最好的老师
https://zhidao.baidu.com/question/8869441.html?sort=11&rn=5&pn=10#wgt-answers
好读书 不求甚解 这是说读书要快 诸葛亮就是这一点 他的知识超过他的两位师兄弟的
一楼刚开始说的是精读 就是慢读书
对于容易理解的东西就一目一行的读 对与不容易理解的 东西就是就精读了
我认为现在学校里的学生不会对教科书赶兴趣

高效快速阅读的四大方法和技巧
https://baijiahao.baidu.com/s?id=1637649005865475992&wfr=spider&for=pc
引导物阅读法
节拍阅读法
压痕阅读法经过反复联系，随着快速阅读能力的提升，将可以做到视点放在中间就可以看清整行甚至几行的文字，从而达到一目一行甚至三五行的效果。
面视阅读法
要达到这一效果，我们在整个阅读过程中，视点都必须始终保持在书页的中轴线做自上而下的垂直运动，利用眼睛的余光将两端的文字置于整个有效视幅范围内，达到快速识别理解阅读内容的目的。
需要强调的是，面视阅读在提高速度的同时一定要保证内容的理解
学以致用，活学活用。阅读的方法和技巧数不胜数，贵在精，难在勤。掌握要领，多读勤练，每天进步一点点，阅读速度的提升自然水到渠成。高效快速阅读，你能行！

如何正确的看书
https://jingyan.baidu.com/article/d3b74d64f4e8141f77e60994.html(MM v ok)
要学会思考问题。看书如果只会麻木的看，就只会增添无用知识罢了，所以不要做个木偶，呆呆的看，要去思考。在看的过程中，要去问自己问题，不懂的话最好要仔细阅读。
不要狼吞虎咽。看书就好比吃饭，如果只顾着吃，却不懂的去品味，那就是个屠夫罢了，对生活并没有多大的帮助。因此，看书要注意，不要为了看几本书而去看，而是为了吸取他的精华而去品味咀嚼，这个是看书很重要的一个思想。
在看书的过程中不要边看边做笔记，这是十分会影响看书氛围的一个行为，虽然很多人看似觉得没什么关系，但是这会将你的思考打断，是不利于你看书的一个行为，所以最好是做好记录，哪里需要做，看完后再做笔记。
看书最好不要超过一个星期。要知道，人的记忆是有限的，如果你一个星期都没把一本书看完，那么里面的很多内容你是很难连接上的，这是很影响看书的。所以，给自己限制一个时间吧，学会约束自己。(v ok)
如果你看的这本书对你来说是十分有价值的，我觉得这本书是值得你读三遍的。因为好书读一遍是很难吸取到它的精华的，所以多读几遍才能将作者想表达的了解的更加透彻。(v ok)

怎样正确的看书
https://jingyan.baidu.com/article/f006222869d1f1fbd3f0c892.html
第一  阅读目录。
第二  阅读序言
第三 阅读正文。一般而言，正文内容比较多。但是。我们需要慢慢的阅读和理解。有些时候，作者为了使得读者理解这本书的内容，还编绘了一些图表，这样可以一目了然。作为读者来说，本书的前几章是比较重要的内容。
第四 精读和泛读。我们要明确哪些书籍需要精读和泛读。但这两者并不矛盾。当我们对一本书精读的时候，需要边阅读边思考。毕竟，思考的内容是自己的。
第五 阅读次数。不是所有的书籍都需要反复阅读。...反复阅读一本书能够使得你有着比较新的认识和理解。

怎么快速又有效的看书
https://jingyan.baidu.com/article/bea41d438bc7c5b4c41be648.html
当今网上卖的书都是很齐全的，可以买一些自己当下特别想升华自己的书籍，一个月最低计划四本书，不然你看这个经验并没有充分吸收到核心的看书方法。
总之，一本书在四至五天之内看完，但不宜看得过多，不然你会有排斥感，这种排斥感将导致你下次不想看书。
再谈速度，你必须明白你到底想在书本上获得什么知识，必须带着重度的目标感看书，这样看书精力集中了，速度提起来了，也不会乏味，不知不觉时间过去了，书也看完了，而且你会有所印象和感受，尽管这种印象不是很深刻，但好像能为你所用了，如果对于核心想关注的知识，再去看相关知识的精准页。
除了目标任务量和速度，你还需要全身心集中精力，切记不能边看书吃东西、听音乐、交谈等，你必须专心，只是看书，其他什么事都不做，当然上厕所和接电话等临时简短时间除外。(v ok)
在这里我就要说说签字笔的作用了，看书不是单纯的翻翻看看，那样不仅无趣，收获效率太低，所以，在你看书的同时，你需要对你感兴趣和目标知识点做勾勾画画，融入自己所思所想写下来，不要嫌刚买的新书就画脏了，你有这种思维本身就是错的，即使你字写得太差也没关系，看书是为了收获知识，并不是买来当收藏品。(拍照)
最后，你需要结合你自己的实际了，理论联系实际，看书不能指导和服务生活，又有什么用，你需要不断联系实际，为自己的世界添加色彩。

怎么提高学习效率
https://jingyan.baidu.com/article/a948d651af91574a2ccd2e0c.html
不要为结果而学习，只注重努力的过程，学习要有信心，养成记笔记的好习惯。

如何高效学习
https://jingyan.baidu.com/article/c35dbcb0b8d49f8916fcbc22.html
获取知识，理解所要学习的材料的内容。
验证知识.(v ok)
(复述所获得的主要内容。
用自己的方式以潜意识的形式复述所学到的知识。
纠错反馈，用所学到的知识解决实际问题。
反思，反思在思考的时候哪里卡了壳，这个过程至关重要。
检验，找一些综合问题来思维风暴一下。)

Source Insight 文件和源代码文件分离，如下填写
New project name: MsEdit_Wendy
Where do you want to store the project data files?
E:\sourceIns\MsEdit_Wendy
project source Directory- the main location of your source files:
E:\wendy_work\MsEdit_Wendy


New project name:project_name
Where do you want to store the project data files?
C:\Users\Wendy\Documents\Source Insight\Projects\project_name

project source Directory- the main location of your source files:(next page)
C:\Users\Wendy\Documents\Source Insight\Projects\project_name

Add and Remove Project Files(next page title)

E:\sourceIns\MsEdit_Wendy\readme.txt: E:\wendy_work\MsEdit_Wendy

2020.02.24

_UNICODE,UNICODE -> _MBCS,

VC++ 6.0中关于UNICODE和_UNICODE的问题总结
https://blog.csdn.net/u012132050/article/details/45113959
在TCHAR.H头文件中总体的结构如下： 
/* For backwards compatibility */为了向后的兼容性
#ifdefine _UNICODE     //如果定义了_UNICODE标识符，字符或字符串则按照宽字符集进行编码
1、在”工程项目“中设置属性，C/C++选项下的Preprocessor definition中，默认是按照多字节字符集进行编码的如图，即没有定义_UNICODE和UNICODE，所以_T(x)将按照x进行编码存储，即按照ASCII码。    MessageBox将按照MessageBoxA()进行输出，即按照ASCII码。 所以他们的编码表是一致的，所以输出正常。
2、如果在Preprocessor definition中添加UNICODE或者_UNICODE中的任何一个则上面的程序就出现乱码或者显示不完全的现象。

  如果添加UNICODE：

     则MessageBox将按照MessageBoxW进行输出，即宽字符输出，但是_T(x)由于没有定义_UNICODE,所以依然按照ASCII进行编码即为x,两个字码表不一致           

     所以就会出现乱码。

  如果添加_UNICODE:（注意前面有下划线）

     则MessageBox()将按照MessageBoxA进行输出，即ASCII或多字节字符集，但是_T(x)会按照L##x，即宽字符进行编码，即一个字符占用两个字节，低字节在前，高字节在后，所以在输出字符时候，比如编码为0x0041,而存储的顺序则为0x41,0x00,所以MessageBox再按照ASCII码进行输出时只会输出一个字符而把0x00当做字符串结束标识。所以最终只会输出一个字符。

     

因此在VC++6.0中需要将两个同时添加到里面才会显示正常，如图。


error C2664: '_wcsicmp' : cannot convert parameter 1 from 'const char *' to 'const unsigned short *'
_UNICODE,UNICODE -> _MBCS, (v ok)

error C2664: “FindFirstFileW”: 不能将参数 1 从“char [260]”转换为“LPCWST
https://blog.csdn.net/jindou910101/article/details/9188029
解决方法：
1、把工程设置里去掉UNICODE宏定义
      项目->XXX属性->配置属性->常规->字符集 改为 “未设置” 就去掉了unicode支持，不过应该回报一个警告
 
      如果实在找不到也可以在#include <windows.h>之前加上一句
      #undef UNICODE
      来解决
2、或者，你全部使用
      TCHAR替换char
      字符串常量用_T()括起来，如_T("*")



#include "..\common\DataProxy.h" 

#include "..\Common\DataProxy_i.c"

(v ok)

SOURCE=..\Common\WTTCommon.idl
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# Begin Source File

SOURCE=..\Common\DataProxy.idl
# ADD MTL /tlb ".\DataProxy.tlb" /h "DataProxy.h" /iid "DataProxy_i.c" /Oicf
# End Source File
# Begin Source File





怎么在VC++6.0环境下编译一个IDL文件？ [问题点数：50分，结帖人firecityplans]
https://bbs.csdn.net/topics/310068194
把接口ITimeBeijing的声明放到 library TimeBeijingLib 内
或者在Project Settings中去掉"MkTypLib compatible"


求助 Regsvr32注册成功 但在注册表CLSID里没有发现该键值 [问题点数：100分，结帖人yanweiqi]
https://bbs.csdn.net/topics/340192507
Bbs1	
谢谢啦--oyljerry
果然是rgs文件的事情，我手工修改了rgs文件后就可以了。

492E31D4-B80D-11D3-AF24-00A0CC23E698 vv
492E31D4-7117-11D3-AF24-00A0CC23E698 xx

0012F77C-33D4-002A-D4F6-12002E509B75 F5 CLSIDFromProgID(OLESTR("Options.TTOptions.1"),&clsid); ??
492E31D4-7117-11D3-AF24-00A0CC23E698 ??

regsvr32 G:\Tele-Trend\Bin\DataProxy.dll 成功但找不到注册表中的相关信息(x no)

怎么样不注册一个ACTIVEX控件就可以使用它呢? [问题点数：100分，结帖人duankuanjun]
https://bbs.csdn.net/topics/30262349
你可以按创建Com对象的方式使用它，你首先将ActiveX这个Dll加载到程序中，然后调用这个Dll的导出函数DllGetClassObject获得该ActiveX的类厂对象，然后通过该类厂对象，在创建你的需要的接口对象，然后调用你需要调用的接口函数。这样你就可以不用注册了!

#import "G:\Tele-Trend\bin\DataProxy.dll" no_namespace
DataProxy.tlh
struct __declspec(uuid("81f75143-6265-11d3-be13-00a0cc23e61b"))
TTDataProxy;
    // [ default ] interface ITTDataProxy
    // [ default, source ] interface _ITTDataProxyEvents

struct __declspec(uuid("8d5dc90e-641f-11d3-be14-00a0cc23e61b"))
ITTDataProxy : IDispatch
{...}

creating a blank workspace and adding the project.

2020.01.21 

IUnKNown接口――QueryInterface函数
https://blog.csdn.net/lixiangminghate/article/details/74165002

用CWnd::CreateControl创建的控件，如何得到它的接口 [问题点数：20分，结帖人yongdu]
https://bbs.csdn.net/topics/20125176
CWnd::GetControlUnknown()可以取得控件的IUnknown接口指针。

怎样动态创建OCX控件 [问题点数：40分，结帖人morrisyuan]
https://bbs.csdn.net/topics/390329334
IClassFactory *pClf = NULL;
//::CLSIDFromProgID(pwszProgID, &clsid);
::CoGetClassObject(clsid, CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory, (void**)&pClf);
_DDataSa* pDataSa = NULL;
pClf->CreateInstance(NULL, __uuidof(_DDataSa), (void**)&pDataSa);
//pDataSa->Create((long)this, cPoint.x, cPoint.y);
pDataSa->Release();
CoUninitialize();
终于成功了，可以访问控件里面的方法了，，不过传参数怎么办，比如我要在我VC工程的某个VIEW里面创建这个控件
哪里用这么麻烦，如果你想用这样的方式创建的话用CoCreateInstance都行。怎么不用CAxWindow方法 来创建了
用CWnd m_Wnd;
 m_Wnd.CreateControl(_T("XX.XX.1") ,NULL,WS_CHILD|WS_VISIBLE,CRect(0,0,200,200), this, 1 );


请问CoCreateInstance创建了COM控件后接下来如何在窗口中显示它？ [问题点数：100分，结帖人sproll]
https://bbs.csdn.net/topics/80218253
wshcdr：
IShockwaveFlash是vc根据控件文件自动生成的接口类，没有SHOW方法。
krh2001(边城浪子) ：
如果控件正确注册的话，使用VC7"添加类"->"ActiveX控件中的MFC类"，然后选择根据注册表可以生成一继承自CWnd的类，那就可以用Create，不过我想纯粹使用COM接口或者ATL而不是MFC或者API创建控件。
谢谢firmbird(firmbird) ，loverx(烟花) ，我想你们的方法更接近我要找的。
要动态地加载控件，需要创建一个“AtlAxWin7”宿主窗口并指定此窗口应承载的控件。执行此操作主要有两种方法： 
使用标准窗口创建 API 和 ATL 宿主 API。此技术在知识库文章“Adding ATL Control Containment Support to Any Window”(Q192560) 中进行了描述。可以在 MSDN Library 中或 http://support.microsoft.com 上找到知识库文章。 
按照如下所述使用 CAxWindow 类： 
确保已经调用 AtlAxWinInit。 
AtlAxWinInit();
AtlAxWinInit 初始化控件宿主代码。 
创建一个 CAxWindow 对象： 
CAxWindow wnd;
CAxWindow 是一个从 CWindow 派生的用于创建和操作“AtlAxWin7”窗口的包装。 
通过调用 Create 创建宿主窗口和控件。 
RECT rect = { 0, 0, 100, 100 };
wnd.Create(m_hWnd, rect, _T("MSCAL.Calendar"), WS_CHILD | 
   WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, WS_EX_CLIENTEDGE);
传递给 Create 函数的窗口标题（第三个参数）是一个标识要创建的控件的字符串。该字符串可以是一个 CLSID（带有大括号）、ProgID、URL 或原始 HTML（以 MSHTML: 为前缀）。如果提供了 URL 或原始 HTML，则 Web 浏览器将与此信息一起加载。 



MFC如何动态加载ActiveX控件? 求大腿解答下 [问题点数：40分，结帖人qq_23847507]
https://bbs.csdn.net/topics/391813627
OleCreate就可以了
CreateControlEx

vc6.0 调用ocx控件
https://blog.csdn.net/Road2010/article/details/24515973

最后面我想说的是：使用ActiveX控件并不难，关键在于你对这个控件提供的函数、成员变量了解多少以及能响应的事件等，能灵活应用。
关于Active控件的开发另见其他文章。
转自：http://blog.csdn.net/sllins/article/details/5525580

今天做了一下ActiveX的使用测试，总结一下：
首先使用MFC创建一个activeX的控件譬如ActiveXTest，编译成ocx并注册，然后另外编写一个测试程序来调用该控件，发现有几种方式：
 
1:使用project-->Add to Project-->Components and Controls, 然后选择要加入的ocx或者dll,系统会自动生成.cpp和.h文件.并自动加入AfxEnableControlContainer(),这样就可以使用了.
 
2:由于activeX一般都有界面，所以可以在dialog里面插入控件的方式来使用，该方式是最简单的一种。创建一个dialog，然后点击右键选择Insert ActiveX Control，在控件库里面找到刚才注册的控件，这时在Controls（按钮栏）里面会出现一个ocx的按钮，可以直接拖进去使用。这时MFC会自动产生一个类，就是包含该控件的类（CActiveXTest），同时在InitInstance()方法里面添加控件初始化函数AfxEnableControlContainer();这样就可以直接在dialog使用控件的方法了。譬如定义ocx按钮的名字为actx，则直接调用
     actx->ShowHello();
 
3:利用上述方法产生包含该控件的类（CActiveXTest），不使用dialog，这时必需手工添加包含该控件的窗体。方法是调用控件类的Create（）方法。
CAcitveXText*  actx = new CAcitveXText;
if(!actx->Create("NN", WS_CHILD|WS_VISIBLE, CRect(0,0,0,0), this, IDC_ACITVEXTEXTCTRL, NULL, FALSE, NULL))
{
  TRACE0("Failed to create the FPWT Control\n");
  return;      // fail to create 
}
actx->ShowHello();
 
4:利用class wizard添加该控件时，相对比较麻烦一些。这时要在InitInstance()里面添加初始化函数AfxOleInit();
然后在使用时要调用CreateDispatch（）来创建控件，然后调用。
 
 wchar_t progid[] = L"ACITVEXTEXT.AcitveXTextCtrl.1";
 CLSID clsid;
 CLSIDFromProgID(progid, &clsid);
 COleException *e = new COleException;
 _DAcitveXText dac;   //产生的类名是_DAcitveXText
 if(dac.CreateDispatch(clsid), e)
   dac.ShowHello();
 else
   throw e;
 但是由于这时是将控件当作normal automation server来使用，必需要重载一下IsInvokeAllowed（），让它直接返回true，否则将不成功，被告之是灾难性失败，错误是编号是：8000ffff。该函数在生成ActiveX的时候重载。（不是在测试程序中）In order
 to use an OLE control only as an automation server, you need to override COleControl::IsInvokeAllowed()and return TRUE.If any of the control's properties and methods should not be accessed when invoked as a normal automation server, then
 that automation function could be bypassed and/or an error code can be returned when COleControl::m_bInitialized is FALSE.
 
BOOL IsInvokeAllowed (DISPID)
{
// You can check to see if COleControl::m_bInitialized is FALSE
// in your automation functions to limit access.
――――――――――――――――
版权声明：本文为CSDN博主「Road2010」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Road2010/article/details/24515973



怎样在运行时动态加载ActiveX控件?急!!!!!(70分)
https://wedelphi.com/t/108805/
找到了答案：

如果我们要动态创建任意的ActiveX控件那么该怎么办呢？可以利用OLE Container控件来达到我们的目的！我们可以动态创建TOLEContainer控件，然后OleContainer有可以动态创建任意的对象，例如：
procedure TForm1.Button1Click(Sender: TObject);
begin
OleContainer1.CreateObject(Edit1.Text,False);
OleContainer1.DoVerb(ovShow);
end;
然后我们运行程序，在Edit里面输入'ShockwaveFlash.ShockwaveFlash.1'点击Button1，然后在Edit里面输入Word.Document，然后点击Button，你会发现我们已经能够动态创建任意的ActiveX控件了。 :)。
注意，若目标机器上面没有安装OCX控件，我们可以在程序的最开始使用WinExec或者ShellExecute()运行regsvr32 来注册OCX控件即可，否则可能无法创建控件。



调用DoVerb激活控件总是失败 [问题点数：100分，结帖人youxi3505]
问题如标题
https://bbs.csdn.net/topics/390245182
HRESULT CreateAxControl(HWND hWnd,const wchar_t * ProgId,IUnknown ** ppControlUnknown,IUnknown ** ppContainerUnknown)
{
HRESULT hr;
CLSID cls;
IOleObject * pObject = NULL;
CControlContainer * pContainer = NULL;
hr = CLSIDFromProgID(ProgId,&cls);
if (FAILED(hr)) goto exit1;

hr = CoCreateInstance(cls,NULL,CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER|CLSCTX_LOCAL_SERVER,IID_IOleObject,(void**)&pObject);
if (FAILED(hr)) goto exit1;

pContainer = new CControlContainer(hWnd);
hr = pObject->SetClientSite(pContainer);
if (FAILED(hr)) goto exit1;
///////////////此处总是失败//////////////////
hr = pObject->DoVerb(OLEIVERB_SHOW,0,pContainer,0,hWnd,0);
if (FAILED(hr)) goto exit1;
/////////////////////////////////////////

    pObject->QueryInterface(IID_IUnknown,(void**)ppControlUnknown);
pContainer->QueryInterface(IID_IUnknown,(void**)ppContainerUnknown);
hr = S_OK;
exit1:
if (pObject) pObject->Release();
if (pContainer) pContainer->Release();
return hr;
}

当我调用CreateAxControl载入flash时会成功
HRESULT hr = CreateAxControl(hWnd,L"ShockwaveFlash.ShockwaveFlash",&pControl,&pContainer);
但是当我载入自己写的一个ActiveX控件则会失败
HRESULT hr = CreateAxControl(hWnd,L"MYGAMEX.MyGameXCtrl.1",&pControl,&pContainer);
代码调试发现在激活控件时总返回失败
hr = pObject->DoVerb(OLEIVERB_SHOW,0,pContainer,0,hWnd,0);

紧急求救这是为啥


Win32编程点滴3 - 简单ActiveX控件的使用
https://www.cnblogs.com/xumaojun/p/8528593.html
HRESULT CreateAxControl(HWND hWnd,const wchar_t * ProgId,IUnknown ** ppControlUnknown,IUnknown ** ppContainerUnknown)
{
    HRESULT hr;
    CLSID cls;
    IOleObject * pObject = NULL;
    CControlContainer * pContainer = NULL;
    
    //通过ProgId得到CLSID
    CLSIDFromProgID(ProgId,&cls);
    
    //创建ActiveX控件的对象，顺便得到IOleObject指针
    CoCreateInstance(cls,NULL,CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER|CLSCTX_LOCAL_SERVER,
        IID_IOleObject,(void**)&pObject);
    
    //CControlContainer是实现了IOleClientSite和IOleInPlaceSite接口的类
    pContainer = new CControlContainer(hWnd);
    
    //调用IOleObject::SetClientSite，传入容器指针
    pObject->SetClientSite(pContainer);
    
    //调用IOleObject::DoVerb，显示控件
    pObject->DoVerb(OLEIVERB_SHOW,0,pContainer,0,hWnd,0);
    
    //一些返回的参数
    pObject->QueryInterface(IID_IUnknown,(void**)ppControlUnknown);
    pContainer->QueryInterface(IID_IUnknown,(void**)ppContainerUnknown);

    if (pObject) pObject->Release();
    if (pContainer) pContainer->Release();
    return S_OK;
}


WIN7打印机无法打印显示本地下层文本正在删除
https://zhinan.sogou.com/guide/d316513699185.htm?ch=zn.xqy.related.pc

KEEPING-PC  192.168.0.100

先仿做，尽量不要创做。仿做量变到质变再创做。

MFC 对话框中动态加载OCX控件
https://blog.csdn.net/yumulinxiang/article/details/78385822

MFC OCX三种调用方法
https://blog.csdn.net/fly0413/article/details/86649294
1、以ATL的方式进行调用，ocx的本质是ATL，所以可以用调用ATL的方法进行调用。不过在插入头文件的时候跟ATL不同，需要以文件的形式加载读取他的头文件（因为ocx是控件只会生成在"ActiveX控件中的MFC类"，不会生成在"ATL类型库里面的MFC类"）。
选择完文件之后，即可添加对应的接口类。
void Ctest5Dlg::OnBnClickedTestBt(){	// TODO: 在此添加控件通知处理程序代码	CoInitialize(NULL); 	m_lpOCX = new COFDReaderActiveX();    //加载控件 指定要创建的IDispatch连接对象的类ID。	BOOL bRet = m_lpOCX->CreateDispatch("suwellreaderax.OFDReaderActiveX.1"); 	if(m_lpOCX != NULL)	{		CString csParam1 = "C:\\Users\\lyf\\Desktop\\PDF\\blank.pdf";		CString csParam2 = "C:\\Users\\lyf\\Desktop\\PDF\\blank.ofd";		CString csParam3 = ""; //C:\\Users\\lyf\\Desktop\\PDF\\bmeta.xml		CString csRet = m_lpOCX->getAllCompsiteNames();		MessageBox(csRet);		//BOOL bRet = m_lpOCX->openFile(csParam1);		//BOOL bRet = m_lpOCX->convertFile(csParam1, csParam2, csParam3);		int a = 3;		a = 4;		return;	} 	if(m_lpOCX != NULL)	{		m_lpOCX->ReleaseDispatch();	} 	if(m_lpOCX != NULL)	{		delete m_lpOCX;		m_lpOCX = NULL;	} 	CoUninitialize();}
2、在对话框中插入ActiveX，之后对插入的资源添加变量，即可生成对应的类。该方法创建时候有边框的资源。
3、在类导向中点击 “ActiveX控件中的MFC类”，选取对应的ocx，后可以进行动态添加ocx，或者也可以在资源对话框中创建资源，然后进行添加变量。如有有存在对应的OCX类则，添加变量时不会添加新文件。


tortoisegit 常见错误disconnected no supported authentication methods available(server sent: publickey)
https://blog.csdn.net/yym6789/article/details/53807640
1.安装好小乌龟git后，用小乌龟的pull 从github上拉取项目，遇到错误：
disconnected no supported authentication methods available(server sent: publickey) 
或者是 git did not exit cleanly (exit code 1)
亦或者是 git did not exit cleanly (exit code 128)
多半是因为git和小乌龟有冲突，解决方法：
右键--小乌龟---settings--network--修改ssh client为git的ssh.exe
https://blog.csdn.net/Hello_World_QWP/article/details/82216345


Disconnected: No supported authentication methods available (server send: publickey)


VC6.0中的dsp和dsw文件有什么区别和联系？
https://blog.csdn.net/pursuitbeauty/article/details/9768433
dsp是:Developer studio Project   工程   开发工作室项目
dws是:Developer studio workspace  工作空间   开发工作室空间

VC6.0 cannot find the definition (implementation) of this function解决方法
https://blog.csdn.net/gordennizaicunzai/article/details/78608495
点击VC6.0左侧工作区ClassView窗口中的类中的函数时，出现cannot find the definition (implementation) of this function弹框提示，解决方法是：关闭工程，然后删除工程目录下面的*.opt *.ncb *.plg文件，再打开工程，最后重新编译即可，之前删除的文件会自动再生成。
.ncb文件是无编译浏览文件，当自动完成功能（自动显示成员变量列表）出问题时，可删除它，build 后自动重建。
.opt是开发环境参数（如工具条位置）文件。
.plg是编译信息(如error和warning信息)文件，html格式。
其它文件：
.dsp为工程文件，文本格式，不可丢失或损坏。
.dsw是工作区文件，丢失或损坏时，可点击.dsp文件打开工程，.dsw文件自动重建。
.clw是ClassWizard信息文件，ini格式，ClassWizard出问题时可删除它再重建。
.map是映像信息文件，编制DLL写.def文件时，若不知道函数导出顺序，可在Prject/Settings/Link页中选中“Generate mapfile”，rebuild，用记事本或其它类似程序打开生成的.map文件，里面可看到函数导出表。
.aps是资源辅助文件，二进制格式。
.pch为预编译文件，可加快编译速度，但改文件非常大。
.pdb文件记录程序相关的数据和调试信息。
.exp是dll信息文件，编译dll时才会生成。
.bsc文件用于浏览项目信息，可在Prject/Settings/Link页中勾掉“Generate Browse Info File”，禁止生成.bsc文件，以加快编译速度，但若使用Source Browser的话就必须有这个文件。

Cannot find the definition (implementation) of this function

2020.01.20

几款Git GUI客户端工具
https://www.cnblogs.com/ups216/p/5603199.html
TortoiseGit

使用Git获取最新版本到本地
http://blog.csdn.net/u011127019/article/details/55044061
一、使用Git UI
1.获取远程最新版本
2.合并远程版本到本地
二、使用Git Brush 、
1.带有查看版本变更详细
2、简单方式
git pull：相当于是从远程获取最新版本并merge到本地
git pull origin master



润园四季 蓉悦 海底捞 八合里 

在 ATL 项目中添加新接口
https://docs.microsoft.com/zh-cn/cpp/atl/reference/adding-a-new-interface-in-an-atl-project?view=vs-2017
当将接口添加到对象或控件时，该接口中创建无存根函数为每个方法。 在您的对象或控件，可以添加仅当前在现有类型库中找到的接口。 此外，在其中添加了接口的类必须实现BEGIN_COM_MAP宏或，如果项目属性化，它必须具有coclass属性。

若要在类视图中使用代码向导将接口添加到现有对象或控件
在中类视图，右键单击一个控件的类名。 例如，完全控制或复合控件或在其标头文件中实现 BEGIN_COM_MAP 宏的任何其他控件类。
在快捷菜单上，单击外，然后单击实现接口。
选择要在中实现的接口实现接口向导。 如果接口不存在任何可用的类型库中，然后你必须将其添加手动到.idl 文件。
若要手动添加新接口
将新接口的定义添加到.idl 文件。
派生对象或从接口的控件。
创建一个新COM_INTERFACE_ENTRY接口或者，如果项目属性化，添加coclass属性。
该接口上实现方法。

若要手动添加新接口
1,将新接口的定义添加到.idl 文件。
2,派生对象或从接口的控件。
3,创建一个新COM_INTERFACE_ENTRY接口或者，如果项目属性化，添加coclass属性。
4,该接口上实现方法。

ATL如何添加一个新接口？如何用简便的方法添加？ [问题点数：20分，结帖人sinall]
https://bbs.csdn.net/topics/60191735
new 一个atl object
这是新增一个类。虽然可以增加接口，但不属于原来的类。类包括多个接口。
vc6好象只能用手工添加，至少我是这样。

idl文件
在原来的那个后添加一个
[
object,
uuid(xxxxxxxxxxx),
helpstring("xxxx Interface"),
pointer_default(unique)
]
interface xxxx : Ixxxxxxxx
{
};


library xxxxxxxxLib
{
coclass xxxxx
{
添加
interface xxxx;
};
}

h文件里
主类从Ixxxx派生,加句public Ixxxx


BEGIN_COM_MAP(Cxxx)
加
COM_INTERFACE_ENTRY(Ixxx)
END_COM_MAP()


SVN和Git比较，哪个好用，适用？
https://jingyan.baidu.com/article/676629976401a154d51b8430.html
SVN 和 Git 哪个更适用于项目管理？
      首先说一下，我是一个研发团队的项目经理，SVN和Git我都用过，SVN更适用于项目管理， Git仅适用于代码管理。
     一个研发队伍的成员正常包括：需求分析、设计、美工、程序员、测试、实施、运维，每个成员在工作中都有产出物，  包括了文档、设计代码、程序代码，这些都需要按项目集中进行管理的。SVN能清楚的按目录进行分类管理， 使项目组的管理处于有序高效的状态。


svn、git的区别，优缺点，使用范围
https://www.jianshu.com/p/e0072bba0b33
转载自：https://blog.csdn.net/mine_song/article/details/70770467

简单总结：

GIT是分布式的，SVN不是
GIT把内容按元数据方式存储，而SVN是按文件
GIT分支和SVN的分支不同
GIT没有一个全局的版本号，而SVN有
GIT的内容完整性要优于SVN
为什么要用GIT而不是SVN？
转载自：https://blog.mimvp.com/article/47.html
使用了近一年的git之后，再使用svn，发现自己svn这种版本管理工具是十分低效的，主要原因有以下几个方面：

从使用者角度分析：

1） svn下载源代码慢。在git中一个几G的版本库，一般一二十分钟就能下载完毕，但是在svn中要一个小时左右；

2）svn随时都得要与服务器交互，无论是查看log，还是查看以往的版本，你必须跟服务器相连，并且速度奇慢务必，而git做这些几乎是瞬间的事；

3）各个分支之间的补丁迁移麻烦，在git上只要两三个命令就可以完事的(其实一个命令，因为需要查找与分支切换)，但是在svn上你必须要下载每个分支的代码，然后比较修改，再上传；

4）git查看历史版本速度快，并且不需要联网，保存在本地.git目录下。svn必须跟服务器相连才能取得版本、日志等信息，并且取版本非常慢；

5）git自带有优化过的grep，使得我们查询相关字符串的效率大大提高

下面从服务器角度说为什么要用git

1）git版本库占用空间小（几乎是svn的分支数之一也就是说如果有四个分支，svn的版本库的体积将接近git的四倍），SVN每个分支都是一份代码的copy，而git每个分支只是各个提交点的hash值的集合，分支几乎不占用什么空间；

2）git是分布式管理系统，我们完全可以不对代码进行备份，但SVN不行，一旦你服务器的硬盘挂掉你整个代码库就完了；

3）git不用时时联网查询，并且对文件进行压缩，使得文件体积大大减小，并且传输速度快，svn是单个文件，git是压缩后的，在使用svn时我已经碰到过好几次服务器无响应了。由于git很多都可以在本地操作的，所以大大降低了客户端对服务器的连接，出现这种情况的概率会大大减小；

4）如果客户端离服务器端非常远，在网速糟糕的情况下，用svn下代码简直是个噩梦

0人点赞
git github cmd


作者：吾爱真理更爱葛巾
链接：https://www.jianshu.com/p/e0072bba0b33
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


Git与SVN区别，各自优缺点
https://blog.csdn.net/zhezhebie/article/details/82563568
Git优点：

1、分布式，每个参与开发的人的电脑上都有一个完整的仓库，不担心硬盘出问题； 
2、在不联网的情况下，照样可以提交到本地仓库，可以查看以往的所有log，等到有网的时候，push到远程即可； 
3、非常强大的分支管理功能。 
4、Git的内容的完整性要优于SVN: GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。

Git缺点：

权限管理不是很方便，需要安装插件gitolite，配置有点麻烦，或者直接使用gitlab管理。

SVN优点

1、较好的权限管理功能，可以精确控制每个目录的权限； 
2、使用相对git要简单一点。

SVN缺点

1、集中式，如果中心服务器出现问题，所有人都不能正常干活，恢复也很麻烦，因为SVN记录的是每次改动的差异，不是完整文件； 
2、分支功能没有git强大； 
3、速度没有git快，如果有五个分支，是把五个分支的文件全部拷下来； 
4、必须联网才能commit。
――――――――――――――――
版权声明：本文为CSDN博主「SHUIPING_YANG」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zhezhebie/article/details/82563568


浅谈为什么Git没有取代SVN
https://blog.csdn.net/u013519551/article/details/52485487
在做开发的过程中，发现Git对于代码的版本控制和管理也是挺好用的，但是为什么还有很多软件公司一直在用svn呢？本人做了一下简单的分析：
1.一般的非纯技术开发公司更倾向于svn；
2.公司一直使用svn，所以公司的项目团队和员工也需要使用；

3.svn的安全控制和权限管理相较于Git更好。git 下，如果一个人clone以后，所有代码和历史都泄漏了。而 svn 有细致的按照目录级的权限控制；
4.源代码管理工具，还是 svn 更强；
5.Git 有一定的学习成本，分布式的工作方式，需要转换思维方式；

6.服务器公司统一控制管理；
7.安全机制, 不会每个人都拷贝一份, 可以对组员限制, 也可以分配不同组；
8.团队合作开发起来传递的数据量不会过大, Git因为都是镜像, 如果有个美工传个500mb的psd, 不相关的人员也要去下载, 很浪费流量和更新时间；
9.每个人的电脑大小不一定能装下特别大的项目, 对于svn来讲, 公司配备一个足够大的服务器硬盘就好了, 而且哪个项目完成, 直接删掉本地目录就好, 完全没有保留的必要；
10.网游公司, 广告公司这些需要大量媒体设计混合到程序的项目中, 很需要svn这样的服务器；
11.svn相对于Git分支确实弱爆了, 但是并不能通过鄙视svn就能把所有人的习惯改过来；
12.Git在这方面来讲更倾向于开源和纯代码开发；
13.毕竟svn使用的最普及和广泛，很多项目团队和个人都用的很顺手，改掉习惯也是需要时间的；
――――――――――――――――
版权声明：本文为CSDN博主「独家记忆0408」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u013519551/article/details/52485487


SVN与Git比较的优缺点差异
https://blog.csdn.net/baidu_38661691/article/details/94456873
优缺点比较
SVN优缺点
优点：
1.管理方便，逻辑明确，符合一般人思维习惯。
2.易于管理，集中式服务器更能保证安全性。
3.代码一致性非常高。
4.适合开发人数不多的项目开发。
缺点：
1.服务器压力太大，数据库容量暴增。
2.如果不能连接到服务器上，基本上不可以工作，看上面第二步，如果服务器不能连接上，就不能提交，还原，对比等等。
3.不适合开源开发（开发人数非常非常多，但是Google app engine就是用svn的）。但是一般集中式管理的有非常明确的权限管理机制（例如分支访问限制），可以实现分层管理，从而很好的解决开发人数众多的问题。
Git优缺点
优点：
1.适合分布式开发，强调个体。
2.公共服务器压力和数据量都不会太大。
3.速度快、灵活。
4.任意两个开发者之间可以很容易的解决冲突。
5.离线工作。
缺点：
1.学习周期相对而言比较长。
2.不符合常规思维。
3.代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息。




Git 版本回退的几种操作方法
https://www.cnblogs.com/revel171226/p/11360844.html
1， 结合使用 git reset --hard <commit id> , git reset --hard HEAD^,  git reflog , git log

　　1) 使用 git log 查看你需要回退版本的commit id, 如果git log显示的结果看着不舒服可以多加一个参数 --pretty=oneline (git log --pretty=oneline)

　　2)  使用git reset  --hard <commit id>

　　3)  在第2)的时候需要找到对应的commit id， 

　　　　Scenario 1 : 你已经回退到某个你指定的版本，但是你这时后悔了想再次回到最新的版本，可以通过 git reset --hard HEAD^ 实现。

　　　　Scenario 2 : 你已经回退到你指定的A版本，但是你实际上应该回退到A版本后面的B版本，你这是又无法通过 git log查看commit id；这时你可以执行git reflog找到B版本的commit id。

　　　　　　　　　　这时你可以通过第2）步的命令来实现。

 PS : 这种方法是不会再当前比较粗暴的方式，因为他不会保留你已经回退的版本之后版本的log（有点拗口），下面我们介绍一种回退到你指定的某个版本，并且保留log的方法

 

 

2，结合使用git checkout  <commit id> -- <paths>, git reflog, git commit -m 'xxxxxxx'

　　1) 使用git log 或者 git reflog 找到你想要回到的哪个版本的commit id

　　2) 使用 git checkout <commit id> -- <paths> 返回到你想要返回的版本， <paths>参数代表的是你想要指定哪个或者哪几个文件 

　　3) 执行完第2)步之后需要执行git commit -m '' 命令提交你当前的修改


git pull 提示 There is no tracking information for the current branch
https://blog.csdn.net/qq_28351609/article/details/86165502
在执行git pull的时候，提示当前branch没有跟踪信息
是因为本地分支和远程分支没有建立联系 (使用git branch -vv 可以查看本地分支和远程分支的关联关系) .
对于这种情况有两种解决办法，就比如说要操作master吧，一种是直接指定远程master：
git pull origin master
另外一种方法就是先指定本地master到远程的master，然后再去pull：
git branch --set-upstream-to=origin/master master
git pull
这样就不会再出现“There is no tracking information for the current branch”这样的提示了。


git pull出现There is no tracking information for the current branch
https://blog.csdn.net/MyheartMylove/article/details/78863973
问题是指本地的分支和远程的分支之间需要建立联系。如：本地master对应远程的master
git branch --set-upstream-to=origin/master master


git强制覆盖本地代码（与git远程仓库保持一致）
https://blog.csdn.net/jal517486222/article/details/82663177
 git fetch --all
 git reset --hard origin/master
 git pull


git强制覆盖：
    git fetch --all
    git reset --hard origin/master
    git pull
git强制覆盖本地命令（单条执行）：
    git fetch --all && git reset --hard origin/master && git pull
https://www.cnblogs.com/pinganzi/p/11593189.html


git放弃修改&放弃增加文件
https://blog.csdn.net/qq_40713392/article/details/86653082

1. 本地修改了一堆文件(并没有使用git add到暂存区)，想放弃修改。 
 单个文件/文件夹： 
$ git checkout  filename1

所有文件/文件夹： 
$ git checkout .1

2. 本地新增了一堆文件(并没有git add到暂存区)，想放弃修改。 
 单个文件/文件夹： 
$ rm filename / rm dir -rf1

所有文件/文件夹： 
$ git clean -xdf1

// 删除新增的文件，如果文件已经已经git add到暂存区，并不会删除！

3. 本地修改/新增了一堆文件，已经git add到暂存区，想放弃修改。 
 单个文件/文件夹：
$ git reset HEAD filename1

所有文件/文件夹：
$ git reset HEAD .1

4. 本地通过git add & git commit 之后，想要撤销此次commit 
$ git reset commit_id1

这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位 
// 撤销之后，你所做的已经commit的修改还在工作区！ 
$ git reset --hard commit_id1

这个id是你想要回到的那个节点，可以通过git log查看，可以只选前6位 
// 撤销之后，你所做的已经commit的修改将会清除，仍在工作区/暂存区的代码不会清除！ 




git gui 提交整个目录

git 提交 全部文件
https://blog.csdn.net/lan861698789/article/details/90928715
原文：https://www.cnblogs.com/smuxiaolei/p/7484678.html 
1. git add . 
git add xx命令可以将xx文件添加到暂存区，如果有很多改动可以通过 git add -A .来一次添加所有改变的文件。注意 -A 选项后面还有一个句点。 git add -A表示添加所有内容， git add . 表示添加新文件和编辑过的文件不包括删除的文件; git add -u 表示添加编辑或者删除的文件，不包括新添加的文件
2. git commit -m "提交注释"
3. 
git push origin  分支名称，一般使用：git push origin master
正常来说这三部就够了


https://github.com/hwdcxm/wendy_work.git
git@github.com:hwdcxm/wendy_work.git

https://github.com/-> sign in or https://github.com/login
name: hwdcxm or 23465028@qq.com
passwd: o + birthday

Git GUI可视化操作教程
https://www.cnblogs.com/zhoumiao/p/8018249.html


之后，只要本地做了修改提交，就可以使用git push origin master命令进行文件推送。
https://www.cnblogs.com/imyalost/p/8762522.html

git commit 报 "Changes not staged for commit:"是怎么回事? - ...
https://segmentfault.com/q/1010000004428943?_ea=613759
你 git add 了吗
我今天也遇到这个问题了，但是还不太一样，这个是很有可能会踩得坑 所以想分享一下：
我是clone了一个文件夹下来，然后想把这个文件夹添加上去，使用了git add .，但是一直报Changes not staged for commit的错误，并且那个文件夹后面有(modified content)，解决如下：
因为是clone下来的文件，所以有.git文件，将.git文件删除就ok啦
git commit -am "modified Cheatsheet.html"
-a 表示 add
git commit -am 管用
-a 表示 all
git commit -am "modified Cheatsheet.html"
我用了git add. git commit -m "",出现了这样的Changes not staged for commit:提示，后来发现时我提交时路径错了


1 git add "文件名" //用户添加文件
2 git add . //可以用来添加当前目录下的所有文件
3 git commit -m "提交的内容" //提交版本信息
4 git push //这一步才是真正的上传




环境部署（六）：Git关联github
https://www.cnblogs.com/imyalost/p/8777684.html
我们使用Git进行版本管理，前面的博客也介绍了Linux下安装Git以及Git基础教程，这篇博客，简单介绍下如何使用Git关联github。。。
更多关于Git的内容，可参考下列内容：
Git官方文档
深入理解学习Git工作流
1、拥有github账号
由于本地仓库和远程的github仓库需要关联，首先需要登录github，注册一个账号，然后建立一个仓库。
注册链接：https://github.com/join?source=header-home
成功注册后，登录github，首页如下：
2、创建SSH Key
Git和github之间是通过SSH加密的，因此需要执行下面的操作：
①、在本地主目录查找，是否有.ssh目录，如果有，打开该目录，一般会有这两个文件：id_rsa和id_rsa.pub，如果有的话，直接跳过，如果没有的话，打开命令行，输入如下命令：
ssh-keygen  -t rsa CC “youselfemail@email.com”（你自己的邮箱地址，推荐和注册github的邮箱保持一致）, 我本地已经有了这些文件，如下所示：
PS：如果本地还未生成SSK key，可以通过该命令生成： ssh-keygen -t rsa -C "youremailaddress@mail.com" 
②、登录github，右上角：设置→settings-SSH and GPR keys→New SSH key，然后输入你的标题，输入上面的公钥，然后点击保存。
3、创建仓库
点击右上角，添加→New repository，按照下图所示创建仓库：
然后进入创建的仓库，点击Clone or download，找到你的仓库地址：
然后通过命令:git remote add origin https://github.com/zwg481026/APITest.git，
将本地仓库和github仓库连接就好了。

 git remote add origin https://github.com/hwdcxm/wendy_work.git



https://github.com/hwdcxm/wendy_work.git
git@github.com:hwdcxm/wendy_work.git

Git命令行添加整个文件夹及目录
https://blog.csdn.net/xinqingwuji/article/details/79391453
git add 文件夹/            添加整个文件夹及内容
git add *.文件类型       添加目录中所有此文件类型的文件
git放弃本地修改：
放弃所有修改
git checkout .
放弃某个文件的修改
git checkout -- filepathname

Git基础使用教程
https://www.cnblogs.com/imyalost/p/8762522.html
一、Windows上安装Git
一般我们工作的电脑都是Windows系统，要使用git首先要进行安装。从软件管家或者其他平台找到git的安装包，下载后默认安装即可。
安装成功之后，可以在开始菜单里面找到git：
或者在桌面右键，也可以看到：
其中GUI为用户界面模式，Bash为命令行模式，这里就以Bash为例子介绍git的基本使用方法（其实相比于GUI，个人觉得Bash更容易学习理解）。
二、设置
由于git是分布式管理工具，需要输入用户名和邮箱以作为标识，因此，在命令行输入下列的命令：
PS：注意git config  --global参数，有了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱，根据个人情况设置。
三、工作原理
安装好之后，在使用前先来了解一下Git的工作原理，是很有必要的一件事，下面是Git的工作流程和简化原理图：
1、Git工作流程
2、Git简化原理图
四、基本用法
1、创建版本库
版本库就是我们所说的“仓库”，英文名repository，你可以理解为一个目录，这个目录里面的所有文件都可以被Git管理，文件的修改，删除Git都能跟踪，
以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。
下面是在我的电脑→D盘→TEST文件下，创建一个名为lianxi的版本库：
命令解析：
cd：进入某个目录
mkdir：创建一个文件
pwd：显示当前的目录路径
2、添加文件到版本库
要添加文件到版本库，首先需要将这个目录变为git可以管理的仓库，命令如下：
然后，在lianxi目录下创建一个文件，这里我创建的文件为0409.txt，内容为123456
使用下列的命令，将创建的文件添加到暂存区，然后提交到仓库：
命令解析：
git add：将文件提交到暂存区
git commit -m：将暂存区文件提交到仓库（单引号内为注释）
3、检查是否有未提交的文件
通过下面的命令，检查该版本库是否有文件未提交：
命令解析：
git status：检查当前文件状态us
4、检查文件是否被修改
修改0409.txt的文件，然后重新检查状态：
修改文件后，通过命令git status发现，文件已经被修改，但是未提交，如果要检查文件修改了什么内容，可以通过上图中的命令来查看，发现文件的第二行增加了666666的内容。
检查无误后，继续提交修改后的文件，提交命令和上面一样。
命令解析：
git diff：查看文件修改的内容
再次修改文件内容，第三行增加233333的内容，然后保存提交：
现在已经修改了2次文件，可以通过如下命令查看历史修改记录：
如上图所示：每次提交都会有自己的版本号，当然，入过觉得这样看起来比较费事，可以使用命令，获得精简版本的日志记录。
命令解析：
git log：获得历史修改记录
git log --pretty=oneline：使记录只显示主要的内容，一行显示
6、版本回退
首先通过命令行查看当前的文件内容：
然后通过下列的命令，执行版本回退：
可以看到内容已经回退到上一个版本，通过git log查看修改记录，发现最近的一次233333内容的记录已经看不到了，如果想回到最新的版本，可以通过如下命令进行回退：
从上图可以看到，文件版本又回退到了最新的状态。
命令解析：
cat：查看文件内容
git reset --hard HEAD^：回退到上一个版本
git reflog：获取历史版本号
git reset --hard 版本号：回退到该版本号对应的版本
PS：如果要回退到上上个版本，可以使用git reset --hard HEAD^^命令，但是这样稍显麻烦，如果回退到100个版本之前，只需要执行这个命令即可：git reset --hard HEAD~100；
五、将本地文件推送到github仓库
PS：关于Git和github关联，可以参考这篇博客：Git关联github，这里跳过不细说。
检查文件是否还有未提交或者修改的，然后将文件提交到github仓库，命令如下：
命令解析：
git remote add origin https://github.com/zwg481026/APITest.git是将你本地的仓库和github仓库进行关联，在操作时候，需要将github地址替换为自己的，否则无法推送！
然后执行下面的命令：
第一次推送master分支时，加上了 Cu参数，Git会将本地的master分支内容推送的远程新的master分支，还会把2个master分支关联起来，在以后的推送或者拉取时就可以简化操作。
推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了，登录你的github，从仓库中查看：
之后，只要本地做了修改提交，就可以使用git push origin master命令进行文件推送。
六、其他
关于git的命令还有很多，后续会不断更新，敬请期待。。。
https://www.cnblogs.com/imyalost/p/8762522.html

2020.01.17

Git的安装和使用
https://blog.csdn.net/wangligong/article/details/53591593

C:\Users\Wendy\.gitconfig
[user]
	name = wendy
	email = 23465028@qq.com


Git 中文详细安装教程
https://blog.csdn.net/sishen47k/article/details/80211002

Git的安装与使用（超详细版教程）
https://blog.csdn.net/u010074690/article/details/80209635

Git客户端下载及安装
Git客户端安装过程
1.双击安装程序“Git-2.10.2-64-bit.exe”，显示截图如下：
https://blog.csdn.net/zzfenglin/article/details/53147604


源代码管理工具 一一 Git-介绍与SVN的对比
https://blog.csdn.net/m0_37989980/article/details/79067733

常用源代码管理软件 及 比较
常用源代码管理软件

全称

出处

CVS

Concurrent Versions System

Open Source

SVN

Apache Subversion

Open Source

VSS

Visual Source Safe

Microsoft

TFS

Team Foundation Server

Microsoft

P4

Perforce

Perforce

Git

Git, 中文蠢货，作者自嘲之意

Open Source

CC

ClearCase

IBM Rational

https://www.cnblogs.com/dancewithautomation/archive/2012/01/12/2320793.html

几种代码管理工具比较
笔者有幸接触过以下几种常用的配置管理工具：VSS、SVN、Clearcase，在此做一个小小的总结
https://blog.csdn.net/isscollege/article/details/78404272

https://git-scm.com/downloads/

git for windows(32+64)
ditto_zhou：可以用，再次下载
https://download.csdn.net/download/ghy110523/10959355

Git软件　Git-2.18.0-64-bit软件.exe
官网下载太慢，感谢楼主
https://download.csdn.net/download/qq_27262727/10633734

为什么说 Git 将取代 SVN 做软件版本控制？
如果你不能理解“分布式”，那么我们看一个简单例子：假如你把开发任务从公司带回家，晚饭后突然有了灵感，要对代码进行修改，不巧家里的电脑不能连接到公司的文件库，你怎么下载要修改的文件？即使你将文件用优盘带回去了，那么修改之后，又怎样提交？SVN 对这种情况没有解决方案，而 Git 可以！因为 Git 在每个用户硬盘上都创建了完整的文件库，不需要、也不存在一个“中心服务器”，你只要能连接上任何一个团队成员的电脑，就能将代码提交到文件库去（有点像 P2P）。  顺便说一下，Git 是由“Linux之父”  Linus Torvalds 创建的。因为他发现找不到满意的方案来管理 Linux Kernel 联合开发的版本控制，就自己写了 Git。

Git 有什么优势？  从网上的用户评价来看，Git 最大的优势就是“快”！对于大型的联合开发项目，用 SVN 进行版本控制管理时速度很慢，但是用 Git 就快很多。  还有一个说法是：SVN 有的功能 Git 都有，而 Git 的某些特色 SVN 根本做不到。  这就足够打动我了。我不是开发人员，无需关心更细节的比较了。如果你有兴趣深入了解，请 Google 之。
――――――――――――――――
版权声明：本文为CSDN博主「QQ_370566617」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/begtostudy/article/details/6024788

假如你们已经在用 SVN 了，那么建议你参考一下 SVN+Git 鱼与熊掌兼得 这篇文章，可以同时使用 SVN 和 Git，这样也方便团队成员完成平稳过渡。  下载 TortoiseGit for Windows 32-bit Git版本控制系统客户端软件   原帖：http://www.joomlagate.com/article/joomla-review/why-subversion-will-be-replaced-by-git-for-version-control/

https://blog.csdn.net/begtostudy/article/details/6024788


	COM_INTERFACE_ENTRY(ITTObject) (v ok)
END_COM_MAP()


关闭return全部分ITTObject接口包括函数PutByID.
关闭构造函数
CTTOptions::CTTOptions() 
{
	return;  // wendy test
..}
关闭OnCreate函数
LRESULT CTTOptions::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	return 0;  // wendy test
...}
关闭OnSize函数
LRESULT CTTOptions::OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	// TODO : Add Code for message handler. Call DefWindowProc if necessary.

	return 0; // wendy test
...}
w2t.exe不出错显示白色界面.


[14:57:35.983]:CTTOptions::CTTOptions() b 
[14:57:36.043]:CTTOptions::MakeFutCode()  
[14:57:36.043]:CTTOptions::ReadExpiryDateListFile()  
[14:57:36.043]:CTTOptions::GetExpiryTime()  
[14:57:36.043]:CTTOptions::GetExpiryDays()  
[14:57:36.113]:CTTOptions::CTTOptions() e 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID(nID=1000,VARIANT* pVar) b 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID() e S_OK 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID(nID=3301,VARIANT* pVar) b 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID() e S_OK 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID(nID=3188,VARIANT* pVar) b 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID() e S_OK 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID(nID=3409,VARIANT* pVar) b 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID() e S_OK 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID(nID=2024,VARIANT* pVar) b 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID() e S_OK 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID(nID=4004,VARIANT* pVar) b 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID() e S_OK 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID(nID=2060,VARIANT* pVar) b 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID() e S_OK 
[14:57:36.113]:STDMETHODIMP CTTOptions::PutByID(nID=1017,VARIANT* pVar) b 
[14:57:52.583]:STDMETHODIMP CTTOptions::PutByID() e S_OK 
[14:57:52.583]:STDMETHODIMP CTTOptions::PutByID(nID=1110,VARIANT* pVar) b 
[14:57:52.583]:STDMETHODIMP CTTOptions::PutByID() e S_OK 
[14:57:52.583]:STDMETHODIMP CTTOptions::PutByID(nID=3306,VARIANT* pVar) b 
[14:57:52.583]:STDMETHODIMP CTTOptions::PutByID() e S_OK 
[14:57:52.583]:STDMETHODIMP CTTOptions::PutByID(nID=3307,VARIANT* pVar) b 
[14:57:52.583]:STDMETHODIMP CTTOptions::PutByID() e S_OK 




tooltip.cpp line 234
void CToolTipCtrl::UpdateTipText(LPCTSTR lpszText, CWnd* pWnd, UINT nIDTool)
{
	ASSERT(::IsWindow(m_hWnd));
...}


	// 协议API.
	BOOL  AdviseDataProxy(BOOL bAdvise);
	STDMETHOD( OnNewFrame)(short wDataType,IStream* pIStream,unsigned long dwID) ;
	void ReadDSFrame(IStream* pIStream);	// 解析'DS'(Tele) 协议	
	void ReadDOFrame(IStream* pIStream,unsigned long dwID);	// 解析Options 协议	
	void ReadDPFrame(IStream* pIStream);    //解析'DP'不同itemcode+date市价 协议  2017.9.28 ben
	void SendRequestFrame() ;				// 请求所有数据.
	void SendEndFrame() ;					// 请求断开与DO连接.  ??
	void SendMonthRequestFrame() ;			// query month list.

	HRESULT ReadDFFrame(IStream *pIStream);
	void SendDFChlFrame( BOOL bConnect ); 
	void SendDFRequestFrame();



	BOOL SubmitRQ(IStream* pIStream, short wDataType = 'DO'); // helper function, call ITTDataProxy::TranslateQueryFrame()


BOOL CTTOptions::SubmitRQ(IStream* pIStream, short wDataType)
{
	if(m_pDataProxy == NULL)
	{
		AtlTrace(_T("OptionsTab: Can't get DataProxy!\n"));
		return FALSE;
	}
	CComQIPtr<ITTDataProxy> pObj(m_pDataProxy);
	if(pObj == NULL)
	{
		AtlTrace(_T("OptionsTab: Can't get interface ITTDataProxy!\n"));
		return FALSE;
	}	
	
	HRESULT hr = pObj->TranslateQueryFrame(wDataType, pIStream, m_dwID);
	return (hr == S_OK);
}


BOOL CTTOptions::SendUpdateRQ(BOOL bConnect)
{
	if( bConnect )
		m_fBF = 0.0;

	FrameLen    framelen;
	FrameHead	framehead;
	FrameID		frameid;
	unsigned short	wElemType;

	framelen = sizeof(FrameHead) + sizeof(FrameID) + sizeof(short); // +sizeof(char);
	memset(&framehead, 0, sizeof(framehead));
	framehead.wFrameType = 'DO';
	frameid.cbGroupCode = m_cbGroupCode;
	memcpy(frameid.szItemCode,m_szItemCode,G_GENCODELEN);  //这是发给OptionsDO的,仍然使用Itemcode
	frameid.lTransdate = m_lTransdate;
	wElemType = bConnect ? 'UC' : 'UD';

	CComPtr<IStream> pIStream;
	CreateStreamOnHGlobal(NULL,TRUE,&pIStream);
	ULARGE_INTEGER size;
	size.QuadPart = framelen + sizeof(framelen);
	pIStream->SetSize(size);
	SeekFromBegin(pIStream, 0);

	HRESULT hr = pIStream->Write(&framelen, sizeof(framelen), NULL);
	hr = pIStream->Write(&framehead, sizeof(framehead), NULL);
	hr = pIStream->Write(&frameid, sizeof(frameid), NULL);
	hr = pIStream->Write(&wElemType, sizeof(wElemType), NULL);
	
	return SubmitRQ(pIStream);
}

void CTTOptions::SendRequestFrame()
{
	SendUpdateRQ(TRUE);
	SendHistoryRQ();
	//SendHistoryRI();
//	SendHistoryRQ();
//	SendUpdateRQ(TRUE);
	SendTeleHisRQ();
	SendTeleUpdateRQ(TRUE);
	
}

STDMETHODIMP CTTOptions::PutByID(int nID, VARIANT* pVar)
{...
	case TTPID_SystemObject:
		{...
VARIANT *pVar1;
			VARIANT var;
			var.vt = VT_UNKNOWN;
			VARIANT *pVar1;
			pVar1= &var;
			pObj->GetByID(TTPID_DataProxy,&pVar1);
			m_pDataProxy = pVar1->punkVal;
			if(m_pDataProxy == NULL)
			{
				AtlTrace(_T("OptionsTab: Can't get DataProxy from SystemObject\n"));
				CLogout("STDMETHODIMP CTTOptions::PutByID() e4 S_FALSE \r\n");
				return S_FALSE;
			}
			var.vt = VT_I4;
			pVar1= &var;
			pObj->GetByID( TTPID_ObjGlobalID,&pVar1);
			m_dwID = pVar1->lVal;
			var.vt = VT_UNKNOWN;
			pVar = &var;
			pObj->GetByID(TTPID_GroupsMng,&pVar1);
			if(pVar1->punkVal == NULL)
				{
				CLogout("STDMETHODIMP CTTOptions::PutByID() e5 S_FALSE \r\n");
				return S_FALSE;
				}
			m_pGrpMng = pVar1->punkVal;
			pObj->GetByID(TTPID_MainFrame,&pVar1);
			if(pVar1->punkVal == NULL)
				{
				CLogout("STDMETHODIMP CTTOptions::PutByID() e6 S_FALSE \r\n");
				return S_FALSE;
				}
			m_pMainFrm = pVar1->punkVal;
...}

	// ITTObject相关数据.
	IUnknown*		m_pDataProxy;
	IUnknown*		m_pSystemObj;	
	IUnknown*		m_pGrpMng;
	IUnknown*		m_pMainFrm;

void CTTOptions::OnSelectItemCode()
{...

			//andy add 2003.10.16  先断开原先的请求,包括DO和DS
			SendEndFrame();
			//andy add 2003.10.16
...}

void CwndBgn::OnSelectItemCode() 
{
	CLogout("CwndBgn::OnSelectItemCode()  \r\n");
	if( m_pOwner!=NULL )
	{
		m_pOwner->m_bSelectWin = 0;
		m_pOwner->OnSelectItemCode() ;
	}

}

Windows7修改文件默认图标
Windows7下没有提供修改文件默认图标的工具，只能通过注册表修改。

1.  进入注册表，在 HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts\下找到相应后缀的文件

2. 在第二个地址中的OpenWithProgids目录下，存在一个二进制值，通常是 后缀名_auto_file(如 rp_auto_file)
3. 在注册表中搜索 后缀名_auto_file ，在 HKEY_CLASSES_ROOT 下找到该项，它的第一个子项通常是 shell 

4. 在 HKEY_CLASSES_ROOT\后缀名_auto_file 下新建一个名为 DefaultIcon 的项。在该目录下会自动生成一个字符串。双击该字符串，在数值数据里面输入你想要的图标地址（如 D:\img\xxx.ico）
5. 注销系统后，完成修改
https://blog.csdn.net/jianzhanger/article/details/45369039

VisualStudio.dsw.10.0
C:\Program Files\Microsoft Visual Studio 10.0\VC\vcpackages\VCProject.dll,8 (x no)

%SystemRoot%\system32\SHELL32.dll

win7中，如何修改文件的图标。
经过观察发现，现在显示的图标是【exe程序 Moc.exe】那一组图标中的第一个。
我是这么更改图标的。
1.创建这个exe程序的快捷方式。
2.更改这个快捷方式的图标。
3.然后选择打开方式，选择这个修改图标的快捷方式打开。
https://bbs.csdn.net/topics/360219137?list=lz


计算机\Registered ActiveX Controls
计算机\Developer Studio Components

关于Registered ActiveX Controls问题？？？？？？
https://www.cctry.com/thread-50862-1-1.html

小弟我的VC++6.0程序文件夹里面的gallery的文件夹下面什么都没有
我的VC++6.0程序文件夹里面的gallery的文件夹下面什么都没有
由于需要添加一个Windows media player的控件。
可是打开之后发现这个文件是空的~~~
我们宿舍用的都是同一个VC++~~~他们都有，就我没有~
我是WIN7的~~宿舍也有好几台WIN7的~~
我之前恢复过系统。。。
今天装了几遍都没有。。。。跪求办法~~
http://m.myexception.cn/vc-mfc/1354513.html

解决Visual C++无法使用ActiveX 控件，Gallery目录下没有Registered ActiveX Controls问题
https://blog.csdn.net/h532600610/article/details/51823313

vc++ 6.0链接数据库 使用控件 registered activex controls 灾难性故障
正常安装后，C:\Microsoft Visual Studio\Common\MSDev98\Gallery\Registered ActiveX Controls文件夹下为空。之前程序里使用过一个ActiveX 控件无法运行，且出现：ActiveX控件“{6262D3A0-531B-11CF-...}”没有在此计算机中注册.注册控件然后再试.!
这个时候我们再检查控件列表，发现多了一个控件，那个控件就是我们要添加的控件。
https://zhidao.baidu.com/question/682145165034791612.html



D:\Program Files\Microsoft Visual Studio\Common\MSDev98\Gallery

MFC如何添加自定义控件
project->add to project->components and controls
在Registered ActiveX Controls下找到你注册的自定义控件就可以了
https://blog.csdn.net/weixin_30629977/article/details/97149377

关闭return大部分ITTObject接口函数留PutByID.

w2t.exe可以显示界面, 但不能显示有些按钮和刷新数据.

ActiveX Container中加载却出错 Microsoft ActiveX Control Test Container 已停止工作
void CHeaderCtrlOptions::OnPaint()
{...
//dc.DrawText(this->m_HChar[i],&tRect,nFormat);  // wendy test
...}
可显示
void CTTOptions::OnSelectItemCode()
{

	CLogout("CTTOptions::OnSelectItemCode()  \r\n");
	
	AFX_MANAGE_STATE(AfxGetStaticModuleState( )) 

	if(m_pGrpMng == NULL)
		return ;
	//CComQIPtr< ITTGroupsMng,&IID_ITTGroupsMng> pGrp(m_pGrpMng);  // wendy test
	//if(pGrp == NULL)
	//	return ;
...

//			pGrp-> FindItem('A',(BYTE*)szItemCode,&lID); // wendy test
			TCHAR szName[30];
//			if( m_iLangType==0 )
//				pGrp->GetItemPara(lID,ItemID_Lang1Descrip,(BYTE*)szName,30);
//			else
//			if( m_iLangType==1 )
//				pGrp->GetItemPara(lID,ItemID_Lang3Descrip,(BYTE*)szName,30);
//			else
//			if( m_iLangType==2 )
//				pGrp->GetItemPara(lID,ItemID_Lang2Descrip,(BYTE*)szName,30);
...} 
按钮可弹出对话框

BOOL CTTOptions::SendTeleUpdateRQ(BOOL bConnect)
{...
	hr = pIStream->Write(&wElemType, sizeof(wElemType), NULL);
	BOOL bSucc = SubmitRQ(pIStream, 'DS');   /////////cash
...}
按确定后出错
BOOL CTTOptions::SubmitRQ(IStream* pIStream, short wDataType)
{
	if(m_pDataProxy == NULL)
	{
		AtlTrace(_T("OptionsTab: Can't get DataProxy!\n"));
		return FALSE;
	}
	CComQIPtr<ITTDataProxy> pObj(m_pDataProxy);
..}
template <class T, const IID* piid = &__uuidof(T)>
class CComQIPtr
{
public:
	typedef T _PtrClass;
	CComQIPtr()
	{
		p=NULL;
	}
	CComQIPtr(T* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComQIPtr(const CComQIPtr<T,piid>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	CComQIPtr(IUnknown* lp)
	{
		p=NULL;
		if (lp != NULL)
			lp->QueryInterface(*piid, (void **)&p);
	}
	~CCom
...}

SystemObject Module 已停止工作

使用MIDL编译IDL文件
一、先在CMD下运行vcvarsall.bat
a.在CMD中cd到VS的vc的安装路径：cd C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC
b.接着输入vcvarsall.bat X86
二、编译你的idl
a.在CMD中cd到你的idl所在的目录：cd E:\testForwork\ComWorkPlace\OutofProc\DictPrxy
b.接着输入：MIDL Dictionary.idl
结果就会出现在你的idl目录下。
――――――――――――――――
版权声明：本文为CSDN博主「Red fog」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/BooleanWater/article/details/103317474

MIDL示例
MIDL编译器将生成XX.H XX_.C XX_P.C DLLDATA.C几个文件，其作用分别为：
XX.H       一个同C和C++兼容的，包含IDL中所描述的所有接口声明的头文件；
XX_.C     一个定义有IDL文件中所用的所有GUID的C文件
XX_P.C     一个实现IDL文件中接口的代理及残根的C文件
DLLDATA.C 一个包含代理和残根的DLL的C文件
https://blog.csdn.net/sunshine1314/article/details/1562376

MIDL_INTERFACE

本站提供特别信息:仅供参考!^_^
Visual Assist X v10.1.1301 Final 正式版
Name：SSG Team
Code：xdaRF G4bKE Ic87U J7pF8 /XGEV Iz/oP YcNmg JVjaU GqzkI M1QtN ZRg9V Q 

2020.01.16

memmove
memmove 编辑 讨论
memmove用于拷贝字节，如果目标区域和源区域有重叠的话，memmove能够保证源串在被覆盖之前将重叠区域的字节拷贝到目标区域中，但复制后源内容会被更改。但是当目标区域与源区域没有重叠则和memcpy函数功能相同。
函数简介编辑
原型：void *memmove( void* dest, const void* src, size_t count );
头文件：<string.h>
功能：由src所指内存区域复制count个字节到dest所指内存区域。
相关函数：memset、memcpy
程序示例编辑
// memmove.c
#include <stdio.h>
#include <string.h>
int main(void)
{
char s[]="Golden Global View";
memmove(s,s+7,strlen(s)+1-7);
printf("%s",s);
getchar();
return 0;
}
程序输出结果：Global View
MSDN上也有相关示例。
*注意：这里的拷贝长度strlen(s)+1-7表示把字符串结尾的'\0'也拷贝进来。
https://baike.baidu.com/item/memmove/5494877?fr=aladdin

error C2065: 'getch' : undeclared identifier
包含头文件加一个conio.h
#include <conio.h>
或者把getch
这个函数改成 getchar函数。
https://zhidao.baidu.com/question/537125299.html?fr=iks&word=error+C2065%3A+%27getch%27+%3A+undeclared+identifier&ie=gbk


: 'printf' : undeclared identifier
未声明定义，缺少printf函数的头文件
#include<stdio.h>
https://zhidao.baidu.com/question/175997549107882044.html

Open HKStock2.occ failed

2020.01.15

template <class T>
class ATL_NO_VTABLE IOleObjectImpl : public IOleObject
{
public:
...
		switch (iVerb)
		{
		case OLEIVERB_PRIMARY:
			hr = pT->DoVerbPrimary(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_SHOW:
			hr = pT->DoVerbShow(lprcPosRect, hwndParent);
			break;
...}

---->

	HRESULT DoVerbShow(LPCRECT prcPosRect, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbShow();
		if (SUCCEEDED(hr))
		{
			hr = pT->InPlaceActivate(OLEIVERB_SHOW, prcPosRect);
			if (SUCCEEDED(hr))
				hr = pT->OnPostVerbShow();
		}
		return hr;
	}
--->

inline HRESULT CComControlBase::InPlaceActivate(LONG iVerb, const RECT* /*prcPosRect*/)
{...
		if (!m_bWndLess)
		{
			if (m_hWndCD)
			{
				ShowWindow(m_hWndCD, SW_SHOW);
				if (!::IsChild(m_hWndCD, ::GetFocus()))
					::SetFocus(m_hWndCD);
			}
			else
			{
				HWND h = CreateControlWindow(hwndParent, rcPos);
				ATLASSERT(h != NULL);	// will assert if creation failed
				ATLASSERT(h == m_hWndCD);
				h;	// avoid unused warning
			}
		}
...}

--------->
template <class T, class WinBase =  CWindowImpl< T > >
class ATL_NO_VTABLE CComControl :  public CComControlBase, public WinBase
{
public:...
	}
	virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos)
	{
		T* pT = static_cast<T*>(this);
		return pT->Create(hWndParent, rcPos);
	}
..}

----->

class ATL_NO_VTABLE CWindowImpl : public CWindowImplBaseT< TBase, TWinTraits >
{
public:
	DECLARE_WND_CLASS(NULL)

	HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
			DWORD dwStyle = 0, DWORD dwExStyle = 0,
			UINT nID = 0, LPVOID lpCreateParam = NULL)
	{
		if (T::GetWndClassInfo().m_lpszOrigName == NULL)
			T::GetWndClassInfo().m_lpszOrigName = GetWndClassName();
		ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);

		dwStyle = T::GetWndStyle(dwStyle);
		dwExStyle = T::GetWndExStyle(dwExStyle);

		return CWindowImplBaseT< TBase, TWinTraits >::Create(hWndParent, rcPos, szWindowName,
			dwStyle, dwExStyle, nID, atom, lpCreateParam);
	}
};
--->

template <class TBase, class TWinTraits>
HWND CWindowImplBaseT< TBase, TWinTraits >::Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName,
		DWORD dwStyle, DWORD dwExStyle, UINT nID, ATOM atom, LPVOID lpCreateParam)
{
	ATLASSERT(m_hWnd == NULL);

	if(atom == 0)
		return NULL;

	_Module.AddCreateWndData(&m_thunk.cd, this);

	if(nID == 0 && (dwStyle & WS_CHILD))
		nID = (UINT)this;

	HWND hWnd = ::CreateWindowEx(dwExStyle, (LPCTSTR)MAKELONG(atom, 0), szWindowName,
		dwStyle, rcPos.left, rcPos.top, rcPos.right - rcPos.left,
		rcPos.bottom - rcPos.top, hWndParent, (HMENU)nID,
		_Module.GetModuleInstance(), lpCreateParam);

	ATLASSERT(m_hWnd == hWnd);

	return hWnd;
}

---->

template <class TBase, class TWinTraits>
LRESULT CALLBACK CWindowImplBaseT< TBase, TWinTraits >::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	CWindowImplBaseT< TBase, TWinTraits >* pThis = (CWindowImplBaseT< TBase, TWinTraits >*)hWnd;
	// set a ptr to this message and save the old value
	MSG msg = { pThis->m_hWnd, uMsg, wParam, lParam, 0, { 0, 0 } };
	const MSG* pOldMsg = pThis->m_pCurrentMsg;
	pThis->m_pCurrentMsg = &msg;
	// pass to the message map to process
	LRESULT lRes;
	BOOL bRet = pThis->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, 0);
...}


--->

BEGIN_MSG_MAP(Cfullctr)
	MESSAGE_HANDLER(WM_CREATE, OnCreate)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	CHAIN_MSG_MAP(CComControl<Cfullctr>)
ALT_MSG_MAP(1)
--->

	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		RECT rc;
		GetWindowRect(&rc);
		rc.right -= rc.left;
		rc.bottom -= rc.top;
		rc.top = rc.left = 0;
		m_ctlEdit.Create(m_hWnd, rc);
		m_ctlEdit.SetWindowText("测试foptions.fullctr");
		return 0;
	}
....


File could not be opened 3

ATL com组件的OnCreate不会被调用 [问题点数：40分，结帖人my_aa]
发现this->m_hWnd为NULL(我那构造函数中有m_bWindowOnly = TRUE)
https://bbs.csdn.net/topics/390152995


在ATL无窗口ACTIVEX控件中响应timer消息
https://blog.csdn.net/gxulg/article/details/311057

使用VC2008创建基于ATL的ActiveX控件,不自动调用OnCreate函数
为什么ATL控件的OnCreate进不去
atl控件的oncreate进不去?

用ATL编写窗口程序 [问题点数：0分]
https://bbs.csdn.net/topics/230864

ATL如此显示窗口及对话框
https://blog.csdn.net/AsongWam/article/details/2505155?utm_source=blogxgwz1

ATL和MFC创建ActiveX控件的区别
https://www.cnblogs.com/huhewei/p/6202804.html

如何使用ATL OBJECT WIZARD 
https://bbs.csdn.net/topics/314998

BEGIN_MSG_MAP(CLitctr)
	MESSAGE_HANDLER(WM_CREATE, OnCreate) (v ok)
ATL Object Wizard 属性->Miscellaneous->Add control base on: Edit or Button or xxxx

使用ATL来写个简单的窗口程序
https://blog.csdn.net/superleolx/article/details/4896045

使用ATL 窗口类
https://blog.csdn.net/lan354898254/article/details/7556686

VC++ ATL 学习总结
https://blog.csdn.net/bcbobo21cn/article/details/69055605

ATL窗口(1) (转)
，当你创建一个基于Windows控制的ATL控制，ATL Object Wizard产生代码如下：
BEGIN_MSG_MAP(CMyButton)
     MESSAGE_HANDLER(WM_CREATE, OnCreate)
     MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
     CHAIN_MSG_MAP(CComControl) file://看这里
    ALT_MSG_MAP(1)
 END_MSG_MAP()
https://blog.csdn.net/dragoo1/article/details/48789639


ATL窗口(2) (转)
https://blog.csdn.net/JoySwing/article/details/11592


ATL窗口添加功能的5种方法[转]
https://blog.csdn.net/weixin_34269583/article/details/94740793

ATL问题集(转载）
#9 如何做一个简单的控件容器?
http://blog.sina.com.cn/s/blog_5c68ccb801017rwz.html
https://blog.csdn.net/fengrx/article/details/4171629
https://blog.csdn.net/fengrx/article/details/4175278
https://www.cnblogs.com/zhehan54/p/4705989.html

ATL ActiveX控件的OnCreate函数不能执行
你的控件是复合控件吗？只有复合控件才会有窗口，有窗口才会有WM_CREATE
检查一下m_hWnd是否为空如果组件有窗口，则需要在构造函数里，
m_bWindowOnly = TRUE;
这样，组件的m_hWnd句柄就不是NULL了
https://www.debugease.com/vc/2225152.html


为什么ATL控件的OnCreate进不去？
当然添加了啊，我用向导生成的，我的是ATL复合控件，构造函数里已经把m_bWindowOnly置为TRUE了啊~
https://bbs.csdn.net/topics/300057406



m_bWindowOnly = TRUE; 为何在VC对话框编辑器中插入我的控件的时候还是没有窗口句柄 OnCreate 也
ActiveX控件测试容器 踪发现在VC的对话框中插入控件的时候并没有调用 CComControlBase::InPlaceActivate 
https://bbs.csdn.net/topics/90064077
我在创建的时候在ATL向导中选择了 WindowOnly 属性, 控件类的构造函数中确实也有 m_bWindowOnly = TRUE; 这一句. 在ActiveX控件测试容器中和IE中也都正常, 能够得到控件的窗口句柄, 但是在VC的对话框编辑器中取得的窗口句柄却为NULL, ATLTRACE 发现控件的 OnCreate 消息响应函数根本就没有被调用! 
对话框上的控件显示为一个白框.
之后在控件的方法中设置断点, 查看 m_bWindowOnly 确实为 TRUE , 而 m_hWnd 和 m_hWndCD 还有 *m_phWndCD 均为 NULL .
为何控件窗口没有被创建呢, ATL中具体创建控件窗口代码又是在哪里呢?

总算有人关注了:) 我还以为我的问题很火星, 没人理我呢:)
昨天又试了一下, 使用 ATL 向导选择 Full Control 生成的ActiveX控件(除了m_bWindowOnly = TRUE之外没做其他修改), 在VC的对话框编辑器中插入也不会创建控件窗口. 因为代码全部由向导生成, 因此排除是我添加的代码的问题. 那么到底是什么问题呢? 还望高手解答!

解决办法是在控件类的 OnDraw 中判断是 DesignTime 还是 Runtime:
如果是 Runtime 进行正常的界面绘制;
如果是 DesignTime 就直接使用 ATL_DRAWINFO& di 参数中的 DC 绘制出界面.
可用如下代码判断是 Runtime 还是 DesignTime
BOOL CYTNetCameraCtrl::InDesignTime()
{
ATLTRACE("InDesignTime\n");

BOOL bUserMode = TRUE;
HRESULT hr = GetAmbientUserMode(bUserMode);
if ( FAILED(hr) || bUserMode ) // run-time
{
return FALSE;
}
return TRUE; // design-time
}


atl OnCreate m_bWindowOnly 百度


OBJECT_ENTRY 映射
其中OBJECT_ENTRY映射为--->
#define OBJECT_ENTRY(clsid, class) {&clsid, class::UpdateRegistry, class::_ClassFactoryCreatorClass::CreateInstance,  －－－－组件类厂创建class::_CreatorClass::CreateInstance,   －－－－组件实例创建NULL, 0, class::GetObjectDescription, class::GetCategoryMap, class::ObjectMain },
其中的_ClassFactoryCreatorClass和_CreatorClass定义如下(都为创建类－－CComCreator)：#define DECLARE_CLASSFACTORY() DECLARE_CLASSFACTORY_EX(ATL::CComClassFactory)#define DECLARE_CLASSFACTORY_EX(cf) typedef ATL::CComCreator< ATL::CComObjectCached< cf > > _ClassFactoryCreatorClass;
#define DECLARE_AGGREGATABLE(x) public:/ typedef ATL::CComCreator2< ATL::CComCreator< ATL::CComObject< x > >, ATL::CComCreator< ATL::CComAggObject< x > > > _CreatorClass;
――――――――――――――――
版权声明：本文为CSDN博主「Tianyu-liu」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/wishfly/article/details/2069595
https://blog.csdn.net/wishfly/article/details/2069595

初学ATL，BEGIN_OBJECT_MAP 搞不定 ？？ [问题点数：100分，结帖人okmnjizc]
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
CComModule _Module;
#include <atlcom.h>
知道了，要把
CComModule   _Module;
写在
#include <atlcom.h>
的上面........... =.=
https://bbs.csdn.net/topics/370267251

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TTOptions, CTTOptions)
END_OBJECT_MAP()

MFC对话框的创建和销毁顺序
了解了理论过后，下面我们就可以用代码实现一下非模态对话框的创建和销毁过程:
建立：
//主框架中，即调用/创建非模态对话框的对话框/窗体：
CTestDlg *pDlg=new CTestDlg;
 pDlg->Create(IDD_TESTDLG,this);
 pDlg->ShowWindow(SW_SHOW);
 //非模态对话框中：
void CTestDlg::OnCancel()
 {
      DestroyWindow();
 }
 void CTestDlg::PostNcDestroy()
 {
      CDialog::PostNcDestroy();
      delete this;
 }
如果要在点击按钮的情况下，销毁非模态对话框，只需要把按钮的事件映射到OnCancel函数即可。
https://blog.csdn.net/leaf6094189/article/details/7609185

OnDestroy 和 DestroyWindow 的区别

虚拟函数DestroyWindow()和视窗消息OnDestroy()的区别在何处？ [问题点数：35分，结帖人xujialin_xjl
这两个函数可以理解成一个是主动的, 另一个是被动的.
用户主动调用DestroyWindows来关闭窗口, 而当窗口被关闭时OnDestroy函数 被 调用!
所以你上面说的现象是正常的... 
你调用DestroyWindow(),那么系统就会发一个WM_DESTROY的消息,这个消息会调用OnDestroy()函数.
DestroyWindow会自动delete ，你再删有可能出错
DestroyWindow()  ------> WM_DESTROY+ WM_NCDESTROY ------>OnDestroy()
                 发消息                          响应消息映射
https://bbs.csdn.net/topics/274198


mfc 关闭对话框的各种消息与方法
以下是对话框关闭时发送的不同消息：
   1）点击OK按钮：OnOk-WM_DESTROY
   2) 点击Cancel按钮：OnCancel－WM_DESTROY
   3) 点击×按钮：WM_CLOSE－ONCANCEL－WM_DESTROY
   4) 键盘ESC按键：OnCancel-WM_DESTROY
   5）调用EndDialog（IDCANCEL），直接到WM_DESTROY消息
这些方式都可以的，要是你的关闭没有成功，那么一定是出现内存泄漏，你需要在WM_DESTROY消息中释放资源，应为WM_DESTROY消息是所有销毁方式都要发送的。
-----------------------------
下面的据说也可以，没有试过。
PostQuitMessage(0)和exit(0)和ExitProcess()
https://blog.csdn.net/wchengshen/article/details/24535151

总结：MFC中一个对话框的关闭过程
说起来挺简单的，一个对话框关闭时要依次调用该类的DestroyWindow-OnDestroy-PostNcDestroy，根据关闭的方法不同，在这些函数之前会调用OnOK、OnCancle或者OnClose。
这里要说的是，模态对话框的消息循环要到调用了PostNcDestroy之后才真正的结束，即ContinueModal循环在这里才结束，然后类的析构函数将被调用，这个对话框才真正的被销毁了。
如果一个模态对话框还有一个模态的子对话框，那就更要注意了。如果子对话框还在显示的时候，父对话框由于某种原因关闭了(如从其他线程接收到了WM_CLOSE消息)，父对话框在执行完OnClose函数后会等到，直到子对话框销毁了，才会继续执行自己的如第一段所说的关闭过程。
 
https://blog.csdn.net/andy5zhu/article/details/17322373

MFC使用Create创建创建窗体后释放内存的方法
//结束时
        delete pTd;
        pTd = NULL;
        这样的写法就会出现的Warning: calling DestroyWindow in CDialog::~CDialog --,正确的做法如下：
        //结束时应该
        if(pTd)
        {
            pTd->DestoryWindow();
            pTd = NULL;
        }
        //在后生成的窗口类中加如下代码
//添加消息PostNcDestory 
        void CTestDlg ::PostNcDestroy()
        {
            // TODO: 在此添加专用代码和/或调用基类
            delete this;//这个一定要
            CDialog::PostNcDestroy();
        }
――――――――――――――――
版权声明：本文为CSDN博主「爷就是这个范儿」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/syytem004/article/details/43526055
这样的写法就会出现的Warning: calling DestroyWindow in CDialog::~CDialog --,正确的做法如下：

MFC非模态对话框内存释放
非模态对话框的内存释放：
第一步：在OnClose() 函数中添加DestroyWindow() ；
第二步：在PostNcDestroy() 中添加delete this。
https://blog.csdn.net/qq_32561069/article/details/71249296

MFC DestroyWindow
DestroyWindow会发送WM_NCDESTROY；

5.       WM_NCDESTROY对应的消息处理函数是OnNcDestroy；


6.       OnNcDestroy最后会调用PostNcDestroy；

7.       PostNcDestroy经常被用户重载以提供释放内存操作。
例如可以使用delete this；
通过这种方式，窗口对象对应的窗口和窗口对象本身都被释放了。
――――――――――――――――
版权声明：本文为CSDN博主「工程师WWW」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weiwangchao_/article/details/7031011
https://blog.csdn.net/weiwangchao_/article/details/7031011

为什么微软的MFC源代码中，有大量的delete this? [问题点数：40分，结帖人medeel]
https://bbs.csdn.net/topics/370002679

delete this 的使用及注意事项
https://blog.csdn.net/nie2314550441/article/details/76880711

在类中调用delete this问题
https://blog.csdn.net/kuimzzs/article/details/81517451

为什么MFC自动生成的类，没有析构函数的声明
默认的析构函数
在mfc中CDialog的析构函数
CDialog::~CDialog()
{
if (m_hWnd != NULL)
{
TRACE0( "Warning: calling DestroyWindow in CDialog::~CDialog --\n ");
TRACE0( "\tOnDestroy or PostNcDestroy in derived class will not be called.\n ");
DestroyWindow();
}
而你创建的这个对话框类是继承于CDialog。
}
https://zhidao.baidu.com/question/238238619.html


MFC对话框什么找不到析构函数？自己定义又提示错误“已定义”。。。。急
因为由于不在头文件中声明析构函数，编译器会自动生成一个析构函数；我觉得你的问题是因为你没有在头文件中声明析构函数，而直接在cpp文件定义了析构函数。由于头文件中没有声明，编译器已经帮你定义了一个了，你再次定义时，就会出错，显示函数体已经存在了。
https://zhidao.baidu.com/question/492775435.html?sort=11&rn=5&pn=0#wgt-answers

C++中类对象的创建与释放过程
在C++的学习过程中，来分享类对象的创建过程与释放过程，即类对象的构造函数与析构函数；
//********************************************
创建过程：
       分配内存（对象）-> 父类构造函数-> 成员的构造函数-> 自己的构造函数
父类构造的顺序：按照继承表从左到右依次构造。
成员构造的顺序：按照声明顺序从上至下依次构造
释放过程：
       自己的析构函数 -> 成员析构函数-> 父类析构函数-> 释放内存（对象）
析构成员的顺序：按照声明顺序从上至下依次析构
析构父类的顺序：按照继承表从左到右依次析构
//*********************************************
实现的C++代码：
――――――――――――――――
版权声明：本文为CSDN博主「芥末味鸭肠」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_43505112/article/details/99705745
https://blog.csdn.net/weixin_43505112/article/details/99705745

浅谈new/delete和malloc/free的用法与区别
三.new和malloc的区别
a.属性

　　new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持c。

b.参数

　　使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。

c.返回类型

　　new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

e. 分配失败

　　new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。
https://www.cnblogs.com/maluning/p/7944231.html



启用内存泄漏检测
https://www.cnblogs.com/itdef/p/9883497.html

简单内存泄漏检测方法 解决 Detected memory leaks!
Detected memory leaks!
Dumping objects ->
{98500} normal block at 0x05785AD0, 152 bytes long.
 Data: << N       N x 7 > 3C AC 4E 10 00 00 00 00 BC A4 4E 10 78 B6 37 00
Object dump complete.
而且每次退出都是一样的.泄漏的内存块都是98500.

解决方法:

1. 在程序开始启动的地方(足够前的地方,只要在泄漏的内存分配的前面,比如在一个大的工程中的app类的构造函数中)使用代码:

_CrtSetBreakAlloc(98500); //98500为上面内存泄漏的块号.

2. 然后debug运行,程序自动断点在"内存块98500"分配的位置:

if (_crtBreakAlloc != -1L && lRequest == _crtBreakAlloc)
    _CrtDbgBreak();
3 .我们已经找到了泄漏的那块内存分配的底层操作的地方了(好拗口!).

这个时候我们利用 "调试" C> "退出" ,快捷键为:"Shift + F11" .

跳出当前函数..然后一直往"上"跳,边跳边查看调用栈.直到看到了自己写的代码,例如我的

std::ifstream* origStream = new std::ifstream();
4 .这个时候我已经可以判断 origStream 分配了内存,但是没有合理释放.处理后再次运行就没有出现内存泄漏了.

5.最后,记得把_CrtSetBreakAlloc(98500); 这句话删除掉,不然每次都断点,岂不是烦死..

----------------------------------------------------------------------------------------------------------

写在后面:

关于内存泄漏检测,有一个Visual Leak Detector ,按照它的介绍的确很不错,可以直接具体到代码行指出内存泄漏,但是个人使用了一下,发现debug的速度太慢了,不知道是不是我个人程序的问题.......像上面的泄漏,我用CrtSetBreakAlloc这种简单的方法就足够了....
https://www.cnblogs.com/dorothychai/archive/2012/03/22/2412031.html

最快速度找到内存泄漏
有没有可能，我们让程序运行到第52次内存分配操作的时候，自动停下来，进入调试状态？所幸，crtdbg确实提供了这样的函数：即 long _CrtSetBreakAlloc(long nAllocID)。我们加上它：
https://blog.csdn.net/qq_33826977/article/details/79750294


VC检测内存泄漏（Detected memory leaks!）
Detected memory leaks!
Dumping objects ->
{98500} normal block at 0x05785AD0, 152 bytes long.
Data: << N       N x 7 > 3C AC 4E 10 00 00 00 00 BC A4 4E 10 78 B6 37 00
Object dump complete.
解决方法:
在程序开始启动的地方(足够前的地方,只要在泄漏的内存分配的前面)使用代码:
_CrtSetBreakAlloc(98500); //98500为上面内存泄漏的块号,然后在堆栈窗口即可知道哪里allocated的memory未释放。
https://www.cnblogs.com/bigfi/p/7682416.html


2020.01.14

leaks

VC++获取文件大小集锦
WIN32_FIND_DATA fileInfo;
HANDLE hFind;
DWORD fileSize;
const char *fileName = 文件的路径及名字;
hFind = FindFirstFile(fileName ,&fileInfo);
if(hFind != INVALID_HANDLE_VALUE)
fileSize = fileInfo.nFileSizeLow;
FindClose(hFind);
https://blog.csdn.net/feidegengao/article/details/8231554

MFC 两种创建状态栏方法以及在状态栏实时显示时间
一、创建状态栏的两种方法
创建状态栏有两种方法，分别使用CStatusBarCtrl和CStatusBar两个类来完成
方法一：
1.添加成员变量CStatusBarCtrl m_StatusBar;
2.在OnInitDialog()中加入：
                  m_StatusBar.Create(WS_CHILD|WS_VISIBLE|SBT_OWNERDRAW, CRect(0,0,0,0), this, 0);

                  int strPartDim[3]= {100, 200, -1}; //分割数量
                  m_StatusBar.SetParts(3, strPartDim);

                  //设置状态栏文本                  m_StatusBar.SetText("分栏一", 0, 0);                  m_StatusBar.SetText("分栏二", 1, 0);                  m_StatusBar.SetText("分栏三", 2, 0);                  //下面是在状态栏中加入图标                  m_StatusBar.SetIcon(1,                                 SetIcon(AfxGetApp()->LoadIcon(IDR_MAINFRAME),

                                FALSE));//为第二个分栏中加的图标

方法二：
1.添加成员变量CStatusBar m_wndStatusBar;
2.在OnInitDialog()中加入：
                  static UINT indicators[] =
                  {
                                ID_SEPARATOR,                        // status line indicator
                                ID_INDICATOR_CAPS,              //CAP lock indicator.
                                ID_INDICATOR_NUM,               //NUM lock indicator.
                                ID_INDICATOR_SCRL,              //SCRL lock indicator.
                  };

                  if (!m_wndStatusBar.Create(this) ||
                                !m_wndStatusBar.SetIndicators(indicators,
                                  sizeof(indicators)/sizeof(UINT)))
                  {
                                TRACE0("Failed to create status barn");
                                return -1;         // fail to create
                  }

                  UINT nID;        //控制状态栏里面的分栏
                  m_wndStatusBar.SetPaneInfo(0,nID,SBPS_STRETCH|SBPS_NOBORDERS,100);      //返回值存nID中
                  m_wndStatusBar.SetPaneText(0,"就绪");

                  m_wndStatusBar.SetPaneInfo(1,nID,SBPS_NORMAL,100);
                  m_wndStatusBar.SetPaneText(1,"大写");

                  m_wndStatusBar.SetPaneInfo(2,nID,SBPS_POPOUT,100);
                  m_wndStatusBar.SetPaneText(2,"数字");

                 //----------------让这个状态栏最终显示在对话框中-------------                  RepositionBars(AFX_IDW_CONTROLBAR_FIRST,AFX_IDW_CONTROLBAR_LAST,0);
――――――――――――――――
版权声明：本文为CSDN博主「HW140701」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/HW140701/article/details/53995464
https://blog.csdn.net/HW140701/article/details/53995464

VC中获取文件大小
#include <io.h>
int getfilesize01()
 {
     int fp;
     fp=_open(__FILE__,_O_RDONLY);
     if(fp==-1) 
         return NULL;
     return _filelength(fp);
     //return NULL;
 }
https://blog.csdn.net/qq_23992597/article/details/52162740

在基于对话框的MFC创建状态栏以及添加时间显示
https://blog.csdn.net/Cowry5/article/details/79618339

MFC在状态栏实时显示系统时间
1.定义状态栏句柄
HWND Statu;
2.窗口初始化函数中创建状态栏
statu = CreateStatusWindow(WS_CHILD|WS_VISIBLE,"音乐播放器v1.0",this->m_hWnd,IDI_ICON_LOGO);
3.时钟响应函数
void CPracticalplayerDlg::OnTimer(UINT_PTR nIDEvent)
{
 CTime t = CTime::GetCurrentTime();
 CString str;
 str.Format("%04d/%02d/%02d  %02d:%02d:%02d",t.GetYear(),t.GetMonth(),t.GetDay(),t.GetHour(),t.GetMinute(),t.GetSecond());
 ::SetWindowText(statu,str);
 CDialogEx::OnTimer(nIDEvent);
}
4.窗口初始化函数中设置时钟
SetTimer(1,1000,NULL);
――――――――――――――――
版权声明：本文为CSDN博主「九月丫头」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/wangwenjing90/article/details/8481638
https://blog.csdn.net/wangwenjing90/article/details/8481638

MFC之对话框 添加状态栏 实时显示时间
https://blog.csdn.net/i_likechard/article/details/77508571

C语言中%f表示的是什么，为什么有时小数点后保留6位，有时小数点后保留1位
printf("%f", fVal ); //这是浮点默认输出格式，小数点保留6位
printf("%.1f", fVal ); //.1是说明，小数点保留1位，对其后的数据进行四舍五入
printf("%.2f", fVal ); //.2是说明，小数点保留2位，对其后的数据进行四舍五入，你想保留几位，就用点几
printf("%10f", fVal ); //输出宽度为10个字符，右对齐，前补空格，小数点保留6位
printf("%10.2f", fVal ); //输出宽度为10个字符，右对齐，前补空格，小数点保留2位
https://zhidao.baidu.com/question/938443103429394372.html

VC/MFC 如何使列表控件（CListCtrl）可编辑
五、（注意）要显示的控件和列表控件的ID号必须相连，并且列表ID大于显示控件ID,处理方法为：在对话框中依次按下“CTRL+D”组合键，如图：按照顺序依次点击相应控件重新对控件进行排序。
（注意）要显示的控件和列表控件的ID号必须相连，并且列表ID大于显示控件ID,处理方法请参考第五步
https://jingyan.baidu.com/article/e75057f2f438f8ebc91a89a7.html

在VC中改变TAB顺序的方法
用VC来写MFC程序的时候，多数情况下，会发现TAB顺序和预期的顺序不一致，那么这时就有必要重新调整TAB顺序，
来适应我们所写的程序。
    调整TAB顺序的方法有两种：
    1.在当前的界面或对话框下按“Ctrl+D”键，就会出现各个控件的TAB序号，我们只需
要操作鼠标点击，即可调整出我们想要的顺序了。
    2.打开资源视图文件(*.rc)，找到相应的BEGIN...END 模块里边，把对CSpinButtonCtrl
所定义的属性描述剪切到所要关联控件属性描述后边，即可。
https://blog.csdn.net/weixin_34332905/article/details/85694139


VC6 注册表DevStudio

VC6 修改资源默认语言

【MFC】 多国语言设置
设置方法： 
1、准备好中文对话框 
2、在资源视图中右键中文对话框，选择“插入副本”，选择目标语言。 
3、在对话框副本中修改成对应的目标语言 
4、判断系统语言类型

LANGID lid = GetSystemDefaultLangID();1

5、根据获取到的系统语言设置对应语言的应用程序



 //多国语言支持
    LANGID lid = GetSystemDefaultLangID();
    if(LANGUAGE_EN == lid)
    {
        //英语 0x0809
        SetThreadUILanguage( MAKELCID( MAKELANGID( LANG_ENGLISH , SUBLANG_ENGLISH_US ) , SORT_DEFAULT ) );
    }
    else
    {
        //中文 0x0804
        SetThreadUILanguage( MAKELCID( MAKELANGID( LANG_CHINESE , SUBLANG_CHINESE_SIMPLIFIED ) , SORT_DEFAULT ) );
    }
12345678910111213

将上述代码放置到MFC工程中的InitInstance()函数中即可。

语言表可以参考： 
https://msdn.microsoft.com/en-us/library/windows/desktop/dd318693(v=vs.85).aspx

测试：系统设置中修改区域和语言，下载并安装语言包，重启电脑。
――――――――――――――――
版权声明：本文为CSDN博主「brunomarss」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/brunomarss/article/details/54411006
https://blog.csdn.net/brunomarss/article/details/54411006

在VC 中实现多国语言切换 - 豆丁网
http://www.docin.com/p-1297243905.html

VC的若干实用小技巧(-)
Visual C++6.0(5.0)开发工具功能非常强大，但是对于初学者来说，却有很多细节的问题需要注意。作者搜集整理了以下一些实用小技巧，希望对初学者有所帮助。 
1:使用vc开发项目时，常会遇到这种情况： 
即明明只改动了一个文件，却要把整个项目全部重新编译连接一次。刚刚连接好，一运行，又提示重新编译连接一次，非常讨厌。这是因为出现了未来文件的缘故。 
解决方法： 
找出对应文件夹下的debug目录，将未来文件全部delete, 再rebuild all一次。(未来 文件即其创建和修改时间都比系统时间靠后） 
2:有时，workspace中的classview显示混乱。其表现如下： 
(1):添加的成员变量或函数不能显示； 
(2):即使显示出来了变量或函数，双击后不能跳至正确的位置。 
解决方法： 
删除.ncb文件，再rebuild all. 
3:如何干净的删除一个类？ 
1:先从workspace中的FileView中删除对应的.h和.cpp文件。 
2.再关闭项目，从实际的文件夹中删除对应的.h和.cpp文件。 
3.灾删除.clw文件。 
打开项目，rebuild all。 
4:初学者常有这样的疑惑： 
直接望工程文件里加入一个CPP原文件再编译连接的话老是提示没有找到预编译头 
解决方法： 
#include "stdafx.h" 
5:如何向项目中加入自己定义的类? 
方法很多，介绍一个简便的： 
选择Insert/New Class菜单 
弹出对话框； 
选择Class Type为generic; 
输入类名。 
当然，也可以自己决定该类的基类 
6:如何在工作区(Workspace)导入多个项目(Project)? 
在打开一个项目(*.dsp文件)后，在利用“Project” 菜单下Insert Project into Workspace 子菜单选择另一个项目文件（*.dsp文件），可插入另一个项目。 
在ClassView 视图中，右键可以激活其中某个项目，工作区插入多个项目能方便不同项目间拷贝代码、资源等。 
7: 在ClassView 视图中类太多如何整理? 
我们可以在ClassView 视图中右键新建文件夹（New Folder），再把具有相近性质的类拖到对应的文件夹中，使整个视图看上去清晰明了。 
8：如何快速删除项目下Debug 文件夹中临时文件? 
在FileView视图中选中对应项目，右键Clean即可。 
9: 打开一个源文件较大的项目编辑操作非常慢，怎么办? 
不要打开项目文件(*.dsp文件)，直接打开要编辑的单个源文件（*.h或*.cpp）进行编辑，要快得多。 
10:如果想把整个项目拷贝到软盘，那些文件可以删掉? 
除了项目文件夹中debug文件夹可以删除外，.ncb,.clw,.opt 等文件也可以删除，这些文件Rebuilt all后可以重新生成。 
――――――――――――――――
版权声明：本文为CSDN博主「ShowMan」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/ShowMan/article/details/9158


VC6 修改资源默认语言
DevStudio

VC6开发环境、调试、语言的若干实用小技巧【转】
https://www.baidu.com/s?wd=VC6%20%E4%BF%AE%E6%94%B9%E8%B5%84%E6%BA%90%E9%BB%98%E8%AE%A4%E8%AF%AD%E8%A8%80&pn=10&oq=VC6%20%E4%BF%AE%E6%94%B9%E8%B5%84%E6%BA%90%E9%BB%98%E8%AE%A4%E8%AF%AD%E8%A8%80&ie=utf-8&rsv_idx=1&rsv_pq=a57fa0a900676731&rsv_t=2a47XSsDu8uHl5EFUgy8fi7%2FAaZEyPTRkpT2LgGZiDCafOXwqtEXQTZ0jQM

VC6.0的若干实用小技巧 
　1:使用vc开发项目时，常会遇到这种情况： 　 　　即明明只改动了一个文件，却要把整个项目全部重新编译连接一次。刚刚连接好，一运行，又提示重新编译连接一次，非常讨厌。这是因为出现了未来文件的缘故。 　 　　解决方法： 　 　　找出对应文件夹下的debug目录，将未来文件全部delete, 再rebuild all一次。(未来 文件即其创建和修改时间都比系统时间靠后） 　　 　　2:有时，workspace中的classview显示混乱。其表现如下： 　 　　(1):添加的成员变量或函数不能显示； 　 　　(2):即使显示出来了变量或函数，双击后不能跳至正确的位置。 　 　　解决方法： 　　 　　删除.ncb文件，再rebuild all. 　 　　3:如何干净的删除一个类？ 　　 　　1:先从workspace中的FileView中删除对应的.h和.cpp文件。 　 　　2.再关闭项目，从实际的文件夹中删除对应的.h和.cpp文件。 　 　　3.灾删除.clw文件。 　 　　打开项目，rebuild all。 　 　　4:初学者常有这样的疑惑： 　 　　直接望工程文件里加入一个CPP原文件再编译连接的话老是提示没有找到预编译头 　 　　解决方法： 　 　　#include "stdafx.h" 　 　　5:如何向项目中加入自己定义的类? 　 　　方法很多，介绍一个简便的： 　 　　选择Insert/New Class菜单 　 　　弹出对话框； 　 　　选择Class Type为generic; 　 　　输入类名。 　 　　当然，也可以自己决定该类的基类 　 　6:如何在工作区(Workspace)导入多个项目(Project)? 　 　　在打开一个项目(*.dsp文件)后，在利用“Project” 菜单下Insert Project into Workspace 子菜单选择另一个项目文件（*.dsp文件），可插入另一个项目。　 　　在ClassView 视图中，右键可以激活其中某个项目，工作区插入多个项目能方便不同项目间拷贝代码、资源等。 　　 　　7: 在ClassView 视图中类太多如何整理? 　 　　我们可以在ClassView 视图中右键新建文件夹（New Folder），再把具有相近性质的类拖到对应的文件夹中，使整个视图看上去清晰明了。 　　8：如何快速删除项目下Debug 文件夹中临时文件? 　 　　在FileView视图中选中对应项目，右键Clean即可。 　 　　9: 打开一个源文件较大的项目编辑操作非常慢，怎么办? 　 　　不要打开项目文件(*.dsp文件)，直接打开要编辑的单个源文件（*.h或*.cpp）进行编辑，要快得多。 　 　　10:如果想把整个项目拷贝到软盘，那些文件可以删掉? 　 　　除了项目文件夹中debug文件夹可以删除外，.ncb,.clw,.opt 等文件也可以删除，这些文件Rebuilt all后可以重新生成。 　　 　　11：怎样快速生成一个与现有项目除了项目名外完全相同的新项目? 　 　　利用File菜单下生成新项目中的Custom AppWizard ，选择 An existing Project ,然后选择现有项目的项目文件名（*.dsp）Finish,编译后就生成一个可以生成与现有项目相同但可以重新取名的项目的AppWizard。你可以象用MFC AppWizard一样用它。如果不想用了，可以在VC 安装目录下Common/MSDev98/Template目录中删除该Wizard中.awx和 .pdb文件。 　　 　　12:如何在源文件中定位光标到对称的{ }和 #if, #endif ? 　　 　　前者使用Ctrl和 “} ”键 ，后者使用Ctrl和“K”键。
            　13：如何在VC中设置头文件和库文件？ 　　 　　除了VC缺省头文件和库文件外，如果经常要用到第三方的头文件和库文件可以在Tools Options 的Directories中设置。如果只是本项目要用到，可以在Project Setting->Link Object/library Modules中设置库文件。 　 　　14:如果让控制台应用程序支持MFC类库？ 　 　　可以在控制台应用程序中include 来引入MFC库，但是控制台应用程序缺省是单线程的，MFC是多线程的，为解决该矛盾，在Project Setting->C/C++ 选项，选择Code Generation,在Use Run-Time Library 下拉框中选择Debug Multithread。 　 　　15:如何为一个MFC应用程序添加ODBC功能？ 　 　　（1）在文件Stdafx.h文件末尾添加下面一行： 　　 　　#include // MFC ODBC database classes 　　 　　（2）在文本模式下编辑RC文件（利用File->Open As text 方式） 　 　　在下面的程序行（共有两处） 　　 　　#include "l.chs/afxprint.rc" // printing/print preview resources 　 　　添加下一行： 　 　　#include "l.chs/afxdb.rc" // Database resources 　　 　　16：数据库表修改后，如何快速更新一个绑定到表的CrecordSet记录集？ 　 　　利用ClassWizard 中 Member Variables标签下选中记录集类后，利用UpdateColoumns和Bind All。 　 　　17：如何汉化只有可执行代码的.exe 文件？ 　 　　在NT 下利用VC Open File 以Resources方式打开*.exe 文件，直接修改资源文件，然后保存即可。 　　 　　以上只是初学VC者常遇到的一些小问题，希望和大家共同学习。
――――――――――――――――
版权声明：本文为CSDN博主「Micro_lee」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Micro_lee/article/details/837620


VC++ 修改资源页面语言
选中 资源文件，在“属性”页面中更改 “language”选项：
资源视图中：
属性 页面中：
https://www.cnblogs.com/pangkang/p/5852690.html

VC6 你的资源使用的语言是默认

列表编辑框右键不弹出复制菜单原因调试.(v ok)
VC/MFC 如何使列表控件（CListCtrl）可编辑
五、（注意）要显示的控件和列表控件的ID号必须相连，并且列表ID大于显示控件ID,处理方法为：在对话框中依次按下“CTRL+D”组合键，如图：按照顺序依次点击相应控件重新对控件进行排序。
（注意）要显示的控件和列表控件的ID号必须相连，并且列表ID大于显示控件ID,处理方法请参考第五步
https://jingyan.baidu.com/article/e75057f2f438f8ebc91a89a7.html

2020.01.13

3963之前都没有详细数据.


VC控件与变量绑定,赋值，获取方式总结
一. 不绑定变量的赋值和获取方法一
GetDlgItem(IDC_EDIT1)->GetWindowText(变量)；
 如果是数组->GetWindowText(数组名，长度)
GetDlgItem(IDC_EDIT1)->SetWindowText(变量)；
二. 不绑定变量的赋值和获取方法二
CString str;
SetDlgItemText(IDC_EDIT1,"1");
GetDlgItemText(IDC_EDIT1,str);
 
三. 绑定value型变量（一共4处）获取，赋值
 
<1处>***Dlg.h : 头文件
class C***Dlg : public CDialog
{
// 构造
public:
 C***Dlg(CWnd* pParent = NULL); // 标准构造函数
// 对话框数据
 enum { IDD = IDD_***_DIALOG };
 protected:
 virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持
// 实现
protected:
 HICON m_hIcon;
 // 生成的消息映射函数
 virtual BOOL OnInitDialog();
 afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
 afx_msg void OnPaint();
 afx_msg HCURSOR OnQueryDragIcon();
 DECLARE_MESSAGE_MAP()
public:
 afx_msg void OnBnClickedOk();
 CString edit1;    //定义了该变量
};

<2处> ***Dlg.cpp : 实现文件
C***Dlg::C***Dlg(CWnd* pParent )
 : CDialog(C***Dlg::IDD, pParent)
 , edit1(_T(""))
{
 m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}
参数列表跟了m_edit1

<3处> ***Dlg.cpp : 实现文件
void C***Dlg::DoDataExchange(CDataExchange* pDX)
{
 CDialog::DoDataExchange(pDX);
 DDX_Text(pDX, IDC_EDIT1, m_edit1);
 }
DDX_Text(pDX, IDC_EDIT1, m_edit1);  变量与控件关联
 
<4处>//应用之处
UpdateData(TRUE) ；
edit1="你要赋值的";
 UpdateData(FALSE) ；

通过调用 UpdateData(TRUE)  UpdateData(FALSE) 将控件数据取到变量或将变量数据显到控件
如果 变量赋值语句写在对话框构造函数里，则UpdateData(FALSE)可省略，会被自动调用

三. 绑的是control型变量

代码与上方一样,看m_edit2
但只有两处涉及
CEdit m_edit2;
DDX_Control(pDX, IDC_EDIT2, m_edit2);
程序里只需要   m_edit2.GetWindowText(变量);
               m_edit2.SetWindowText(变量);就可以用了
除了赋值,还能干很多事情.
――――――――――――――――
版权声明：本文为CSDN博主「qinxiaoli1204」的原创文章，遵循CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qinxiaoli1204/article/details/6901462

https://blog.csdn.net/qinxiaoli1204/article/details/6901462

MFC EnableMenuItem_使能菜单
MSDN是最佳的查找解决办法的工具,但是他不是万能的
CMenu* mmenu =GetMenu();
CMenu* submenu =mmenu->GetSubMenu(0);
submenu->EnableMenuItem(ID_FILE_NEW,MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
使menu菜单不可选,变灰,........
MSDN的代码例子都给出来了,可是使用却无法成效.句柄都获得,返回0,也没出错.
https://blog.csdn.net/autumn20080101/article/details/8802326

//struct _Frame_e  // get from _tagTTDataFrame
//{
//	int nLength;
//	time_t lTime;
//	BYTE btGroupCode;
//	char arItemCode[8];
//	BYTE btTransCode;
//	int nTransDataLength;
//	void * pTransData;

//	DWORD	dwVal;
//	WORD	BrokerNo;
//	WORD	TradeTime;
//	DWORD   TradeTime2; 
//	WORD	Key;
//	float	Price;
//	unsigned long Quantity;
//	BYTE	TyadeType;
//	DWORD	lTemp;
//	BYTE	byTmp;
//};



vc右键菜单
CMenu menu ,* pSubMenu;//定义下面要用到的cmenu对象
?menu.LoadMenu(IDR_POPMENU);//装载自定义的右键菜单

?pSubMenu = menu.GetSubMenu(0);//获取第一个弹出菜单，所以第一个菜单必须有子菜单

?CPoint oPoint;//定义一个用于确定光标位置的位置
?GetCursorPos( &oPoint);//获取当前光标的位置，以便使得菜单可以跟随光标

?pSubMenu->TrackPopupMenu (TPM_LEFTALIGN, oPoint.x, oPoint.y, this); //在指定位置显示弹出菜单
――――――――――――――――
版权声明：本文为CSDN博主「sevene2015」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/aGan2007/article/details/1693599
https://blog.csdn.net/aGan2007/article/details/1693599

VC 添加右键菜单
void CGVideoDlg::OnContextMenu(CWnd* /*pWnd*/, CPoint point)
{
	// TODO: 在此处添加消息处理程序代码
	CRect rect;
	GetDlgItem(IDC_PLAYER)->GetWindowRect(&rect);
	if (rect.PtInRect(point))
	{
		CMenu menu;
		VERIFY(menu.LoadMenuW(IDR_MENU1));
 
		CMenu *pPopup = menu.GetSubMenu(0);
		ASSERT(pPopup != NULL);
		pPopup->TrackPopupMenu(TPM_LEFTALIGN|TPM_LEFTBUTTON, point.x, point.y, this);
	}
}
https://blog.csdn.net/ljz9425/article/details/6877935

VC 添加对话框右键菜单方法
给对话框添加右键菜单有好多方法，下面简单介绍两种。
一、响应WM_RBUTTONDOWN消息
在响应函数中添加以下代码
//右键菜单
CMenu menu;
menu.LoadMenu(IDR_MENU);
ClientToScreen(&point);
menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN|TPM_LEFTBUTTON,point.x,point.y,this);
//end
二、响应WM_CONTEXTMENU消息
在响应函数中添加以下代码
//右键菜单
CMenu menu;
menu.LoadMenu(IDR_MENU);
menu.GetSubMenu(0)->TrackPopupMenu(TPM_LEFTALIGN|TPM_LEFTBUTTON,point.x,point.y,pWnd);
//end
https://blog.csdn.net/u010258235/article/details/9945707


VC 创建弹出式菜单
void CMy82Dlg::OnRButtonUp(UINT nFlags, CPoint point)
{
	// TODO: 在此添加消息处理程序代码和/或调用默认值
	CMenu *pMenu = m_Menu.GetSubMenu(0);			//获得菜单句柄
	CRect rect;
	ClientToScreen(&point);							//将客户坐标转换为屏幕坐标
	rect.top = point.x;								//将鼠标当前横坐标作为弹出菜单的左上角坐标
	rect.left = point.y;							//将鼠标当前纵坐标作为弹出菜单的左上角坐标
	pMenu->TrackPopupMenu(TPM_LEFTALIGN|TPM_RIGHTBUTTON|TPM_VERTICAL,rect.top,rect.left,this,&rect);		//显示弹出菜单
	CDialogEx::OnRButtonUp(nFlags, point);
}
https://blog.csdn.net/homechao/article/details/8571910


MFC点击按钮弹出菜单
CMenu menu,*pMenu;
menu.LoadMenu(IDR_MENU_MANAGE);
CRect pt;
GetDlgItem(IDC_BUTTON)->GetWindowRect(&pt);
pMenu = menu.GetSubMenu(0);
pMenu->TrackPopupMenu(TPM_LEFTALIGN,ppt.left,ppt.bottom,this);  
https://blog.csdn.net/rundll64/article/details/24860865

void CShowData::OnRclickListData(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// TODO: Add your control notification handler code here
	
	NM_LISTVIEW*   pNMListView   =   (NM_LISTVIEW*)pNMHDR;  
	CRect CEret;
	CRect offset;
	if(m_list_data.GetSubItemRect(pNMListView->iItem, pNMListView->iSubItem, LVIR_LABEL, CEret))//取得指定单元格大小
	{
		m_list_data.GetWindowRect(&offset);   
		ScreenToClient(&offset);   
	}
	CPoint point;
	point.x = offset.TopLeft().x + CEret.TopLeft().x + 2;
	point.y = offset.TopLeft().y + CEret.TopLeft().y + 2;

	ClientToScreen(&point);

	CMenu menu;//菜单
	CMenu* pPopupMenu;//菜单指针
	menu.LoadMenu(IDR_MENU1);//加载ID为IDR_MENU1的菜单
	pPopupMenu = menu.GetSubMenu(0);   //获取弹出菜单的第一层子菜单的类指针
	pPopupMenu->TrackPopupMenu(TPM_BOTTOMALIGN,point.x,point.y,this,NULL); //point.x,point.y TPM_BOTTOMALIGN  TPM_LEFTALIGN

	*pResult = 0;
}



VC++实现弹出菜单(转)
void CPopupMenuDlg::OnLButtonDown(UINT nFlags, CPoint point)
{
 // TODO: 在此添加消息处理程序代码和/或调用默认值
 CMenu menu;//菜单
 CMenu* pPopupMenu;//菜单指针
 CBitmap m_bitmap1;//位图
 
 menu.LoadMenu(IDR_MENU1);//加载ID为IDR_MENU1的菜单
 m_bitmap1.LoadBitmap(IDB_BITMAP1);//加载ID为IDB_BITMAP1的位图

 pPopupMenu = menu.GetSubMenu(0);   //获取弹出菜单的第一层子菜单的类指针

//为菜单的第一和第三项设置图标
 pPopupMenu->SetMenuItemBitmaps(0,MF_BYPOSITION,&m_bitmap1,&m_bitmap1); 
 pPopupMenu->SetMenuItemBitmaps(2,MF_BYPOSITION,&m_bitmap1,&m_bitmap1);

 ClientToScreen(&point);//将鼠标单击处的坐标转换为屏幕坐标

//弹出菜单函数，第一个参数表示快捷菜单的下边界与由参数y指定的坐标对齐 

//第二和第三个为x、y坐标，第四个表示拥有此菜单的窗口句柄，

//第五个默认为NULL,表示当用户在菜单以外的区域按鼠标键时，菜单会消失

pPopupMenu->TrackPopupMenu(TPM_BOTTOMALIGN,point.x,point.y,this,NULL);

 CDialog::OnLButtonDown(nFlags, point);
}
https://blog.csdn.net/adu285041555/article/details/8608543

vc6 右键菜单

vc6 对话框右击弹出菜单

FONT 8, "MS Sans Serif", 0, 0, 0x1

FONT 10, "System"

1 invalid_records=3848, records=32424...AHMFC    , tradeticker-- TickTime:17041 92802, key: 9, price:28271.0000, share:1, total:4119, BrokerNo:0
1 invalid_records=3848, records=32425...AHMF20   , tradeticker-- TickTime:17041 92802, key: 7, price:28271.0000, share:1, total:4117, BrokerNo:0
The thread 0x1D50 has exited with code 0 (0x0).

32737

1 invalid_records=3848, records=31862...ACUF20   , tradeticker-- TickTime:17023 92726, key: 0, price:6.9673, share:3, total:20, BrokerNo:0
1 invalid_records=3848, records=31863...ACUF20   , tradeticker-- TickTime:17023 92726, key: 1, price:6.9673, share:1, total:21, BrokerNo:0


1 invalid_records=3848, records=32445...AHIF20   , tradeticker-- TickTime:17042 92804, key: 3, price:28271.0000, share:6, total:6505, BrokerNo:0
1 invalid_records=3848, records=32446...AHMFC    , tradeticker-- TickTime:17042 92804, key: 0, price:28270.0000, share:1, total:4120, BrokerNo:0
1 invalid_records=3848, records=32447...AHMFC    , tradeticker-- TickTime:17042 92804, key: 1, price:28270.0000, share:1, total:4121, BrokerNo:0

frame_e_count = 28889

32737

1 invalid_records=3848, records=32708...AHIF20   , tradeticker-- TickTime:17046 92812, key: 12, price:28268.0000, share:1, total:6570, BrokerNo:0
1 invalid_records=3848, records=32709...AHIF20   , tradeticker-- TickTime:17046 92812, key: 13, price:28268.0000, share:3, total:6571, BrokerNo:0
The thread 0x7E0 has exited with code 0 (0x0).

32737


1 invalid_records=3848, records=31682...AHIF20   , tradeticker-- TickTime:17018 92716, key: 5, price:28280.0000, share:1, total:6314, BrokerNo:0
1 invalid_records=3848, records=31683...AHMFC    , tradeticker-- TickTime:17018 92716, key: 2, price:28281.0000, share:1, total:4032, BrokerNo:0
The thread 0x179C has exited with code 0 (0x0). 35531

32737


1 valid_records=0, records=31749...AHIFC    , tradeticker-- TickTime:17020 92720, key: 4, price:28286.0000, share:1, total:6328, BrokerNo:0
1 valid_records=0, records=31750...AHIFC    , tradeticker-- TickTime:17020 92720, key: 5, price:28286.0000, share:1, total:6329, BrokerNo:0
1 valid_records=0, records=31751...AHIFC    , tradeticker-- TickTime:17020 92720, key: 6, price:28286.0000, share:1, total:6330, BrokerNo:0
The thread 0x628 has exited with code 0 (0x0).


1 valid_records=0, records=31820...AHEF20   , tradeticker-- TickTime:17021 92722, key: 1, price:11224.0000, share:1, total:781, BrokerNo:0
1 valid_records=0, records=31821...AHIFC    , tradeticker-- TickTime:17022 92724, key: 0, price:28285.0000, share:1, total:6339, BrokerNo:0
1 valid_records=0, records=31822...AHIF20   , tradeticker-- TickTime:17022 92724, key: 0, price:28285.0000, share:1, total:6339, BrokerNo:0
1 valid_records=0, records=31823...AHIFC    , tradeticker-- TickTime:17022 92724, key: 1, price:28286.0000, share:1, total:6340, BrokerNo:0
The thread 0x1AD4 has exited with code 0 (0x0).



valid	英[?v?l?d]
美[?v?l?d]
adj.	(法律上) 有效的; (正式) 认可的; 符合逻辑的; 合理的; 有根据的; 确凿的; 有效的; 系统认可的;
[例句]They put forward many valid reasons for not exporting
他们提出了很多不出口的正当理由。

available	英[??ve?l?bl]
美[??ve?l?bl]
adj.	可获得的; 可购得的; 可找到的; 有空的;
[例句]Since 1978, the amount of money available to buy books has fallen by 17%
自1978年以来，可用于采购图书的经费已经减少了17%。

invalid
英[?n?v?l?d , ??nv?l?d]
美[?n?v?l?d , ??nv?l?d]
adj.	(法律上或官方) 不承认的; 无效的; 无充分事实的; 站不住脚的; 不能识别的;
n.	病弱者; 久病衰弱者;
v.	(因伤病) 令…退役;
[例句]I hate being treated as an invalid.
我讨厌被人当作伤病号对待。
[其他]	第三人称单数：invalids 复数：invalids 现在分词：invaliding 过去式：invalided 过去分词：invalided


struct BargRecord
{
public:
	// Stream API.
	BOOL LoadFile( FILE* pFile ) ;
	BOOL SaveFile( FILE* pFile ) ;

	BOOL operator == ( const BargRecord& record ) const ;

public:
	unsigned short m_iBrokerNo ;
	unsigned short m_iTickerTime ;
	unsigned short m_iTransactionKey ;
	float	m_fPrice ;
	long	m_lQuantify ;
	char	m_cTradeType ;
	char	m_cReserve ;

};

Process_t

Process_e

HandleFrame_e

分析并处理e数据

BrokerNo

HandleFrame_t

列表编辑框右键不弹出复制菜单原因调试.
VC/MFC 如何使列表控件（CListCtrl）可编辑
五、（注意）要显示的控件和列表控件的ID号必须相连，并且列表ID大于显示控件ID,处理方法为：在对话框中依次按下“CTRL+D”组合键，如图：按照顺序依次点击相应控件重新对控件进行排序。
（注意）要显示的控件和列表控件的ID号必须相连，并且列表ID大于显示控件ID,处理方法请参考第五步
https://jingyan.baidu.com/article/e75057f2f438f8ebc91a89a7.html

2020.01.10

datacount = 299 2709
datacount = 453 0574 
datacount = 1148 7481
190617X.MDS 339,576 KB

datacount = 271 7545  
200102.MDS 88,725 KB


在VC6中实现多语言支持
随着计算机在各种行业的普及，以及我国软件行业的发展，国产软件在不断的走出国门，所以各种软件的多语言支持也被越来越多的程序员所关注。对于一个软件程序为了支持不同语言，而创建不同的源程序显然不是一个很好的方法。本文主要介绍如何在VC6环境下通过创建支持多语言的资源文件来实现多语言支持。

首先创建一个支持简体中文的工程项目Test，对该工程中的所有资源项使用 Insert Copy命令创建支持英文的资源项；

打开该工程的.rc文件，将该文件中的3 TEXTINCLUDE DISCARDABLE部分改写为：

3 TEXTINCLUDE DISCARDABLE

BEGIN

??? "#define _AFX_NO_SPLITTER_RESOURCES/r/n"

??? "#define _AFX_NO_OLE_RESOURCES/r/n"

??? "#define _AFX_NO_TRACKER_RESOURCES/r/n"

??? "#define _AFX_NO_PROPERTY_RESOURCES/r/n"

??? "/r/n"

??? "#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)/r/n"

??? "#ifdef _WIN32/r/n"

??? "LANGUAGE 4, 2/r/n"

??? "#pragma code_page(936)/r/n"

??? "#endif //_WIN32/r/n"

??? "#include ""res//Test.rc2""? // non-Microsoft Visual C++ edited resources/r/n"

??? "#include ""l.chs//afxres.rc""????????? // Standard components/r/n"

??? "#endif/r/n"

??? "#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)/r/n"

??? "#ifdef _WIN32/r/n"

??? "LANGUAGE 9, 1/r/n"

??? "#pragma code_page(1252)/r/n"

??? "#endif //_WIN32/r/n"

??? "#include ""res// Test .rc2""? // non-Microsoft Visual C++ edited resources/r/n"

??? "#include ""afxres.rc""???????? // Standard components/r/n"

??? "#endif/r/n"

??? "/0"

END

将该文件末尾的Generated from the TEXTINCLUDE 3 resource.部分改写为：

#define _AFX_NO_SPLITTER_RESOURCES

#define _AFX_NO_OLE_RESOURCES

#define _AFX_NO_TRACKER_RESOURCES

#define _AFX_NO_PROPERTY_RESOURCES


?

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)

#ifdef _WIN32

LANGUAGE 4, 2

#pragma code_page(936)

#endif //_WIN32

#include "res/PhTools.rc2"? // non-Microsoft Visual C++ edited resources

#include "l.chs/afxres.rc"????????? // Standard components

#endif

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)

#ifdef _WIN32

LANGUAGE 9, 1

#pragma code_page(1252)

#endif //_WIN32

#include "res/PhTools.rc2"? // non-Microsoft Visual C++ edited resources

#include "afxres.rc"???????? // Standard components

#endif

这样该工程项目的资源就可以支持中文和英文了。从Project菜单选择Setting…选项，打开Project Settings对话框，选择Resources 选项卡，在“Preprocessor definitions”追加“, AFX_TARG_ENU,AFX_RESOURCE_DLL”，对工程进行编译就可生成支持英文的程序，如果不加入“, AFX_TARG_ENU,AFX_RESOURCE_DLL”，对工程进行编译可生成支持中文的程序。

点赞
――――――――――――――――
版权声明：本文为CSDN博主「zzgff」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zzgff/article/details/31588

https://blog.csdn.net/zzgff/article/details/31588

转载：VC在一个工程中实现多语言版本
前段时间笔者因为做一个程序，客户要求要有中英文版本，开始以为要做二个工程，只是资源文件不同，但是发现这样一个工程更新另外一个也要更新，实在是很麻烦 ，后来经过网上查找资料与自己亲身实验，发现其实只要在一个工程中就可以实现。但是这个工程中要有两个资源文件，当编译不同版本时，程序可以自动链接不同资源文件 。下面把具体的方法写出来。供大家参考一下。

第一步、创建中英文版本资源文件

我们先创建第一个中文版本工程，假设工程名称为 Example，在向导第一步的“What language would you like you resource in” 选择中文 (如下图)，其它使用缺省值。



然后在工程中把 Example.rc 删除，这里虽然删除了文件，但实际上在工程文件目录文件还是存在的。进入工程目录下把资源文件名改成Example_Ch.rc，再在 VC 编译器中加入 Example_Ch.rc 文件 ，关闭工程。

然后再创建一个同名的英文版本工程。也就是在选择资源语言时选择英语(可以保存在不同的目录下)



创建完后，把英文版本目录下的 Example.rc 文件拷贝到中文工程的目录下，其实我们就只是要这个资源文件。并把名称改为 Example_En.rc。

第二步、在工程中设置版本信息

打开中文件工程，把英文资源文件添加进工程，在添加时会有提示出现，不要理会，按确认就行。

选择菜单 Build->Configurations，增加一个工程配置，在Configuration中输入 Debug English 在 Copy Setting from 中选择 Debug 就可以(见下图)，使用相同的方法，再增加一个 Debug Chinese 配置，并把原来的 Debug 删除。



第三步、设置工程信息

选择菜单 Project->Settings，在左边的 Setting For 中选择 Debug Chinese 在 Generatl 属性页的 Intermediate files 中输入 Debug Chinese，在 Output files 中输入 Chinese。在 Resource 属性页的 Resource file name 中输入 Debug Chinese/Example_Ch.res，(见下图)其它缺省就行。

用同样的方法在来设置英文版本信息。在左边的 Setting For 中选择 Debug Enghlis 在 Generatl 属性页的 Intermediate files 中输入 Debug Enghlis，在 Output files 中输入 Enghlis。在 Resource 属性页的 Resource file name中输入 Debug English/Example_En.res，其它缺省就行。

本程序在 WIN2000+VC6。0环境下通过。



第四步、修改 DSP 文件，用记事本打开工程下的 Example。dsp 文件

找到如下行:

01.
SOURCE=.\Example_ch.rc
02.
 
03.
# End Source File
04.
# Begin Source File
05.
 
06.
SOURCE=.\Example_en.rc
07.
# PROP Exclude_From_Build 1
08.
 
09.
# End Source File
10.
# Begin Source File
在SOURCE=.\Example_ch.rc行后面加入下面代码

01.
SOURCE=.\Example_ch.rc
02.
 
03.
!IF  "$(CFG)" == "Example - Win32 Debug English"
04.
 
05.
# PROP Exclude_From_Build 1
06.
 
07.
!ELSEIF  "$(CFG)" == "Example - Win32 Debug Chinese"
08.
 
09.
!ENDIF
在SOURCE=.\Example_en.rc行后面加入下面代码：

1.
!IF  "$(CFG)" == "Example - Win32 Debug English"
2.
 
3.
!ELSEIF  "$(CFG)" == "Example - Win32 Debug Chinese"
第五步、现在打开工程，按照不同的要求编译不同版本就行了，比如这个时候我们要英文版本

在编译时选择 Builder->Set Active configuration 中选择 Win32 Debug English 即可，如果要中文版本 ， 在编译时选择 Builder->Set Active configuration 中选择 Win32 Debug Chinese 即可。

结论

如果以后要添加资源，只要在 Resourch。h 文件中定义资源号，然后在中英文资源文件中添加相应的资源串就行，当然这个时候不能直接在工作区的 Resourc 中添加 ，而要用记事本等工具打开资源文件再添加哟。

本程序在Win2000，VC++6.0英文版本下编译通过。

作者信息：

朱勤武

联络电话：057783122865

电子信箱：qingwuzhu@163。net

通讯地址：广东省深圳市福田区上梅新村 159 栋 703

邮编：518049
https://blog.csdn.net/chunyexiyu/article/details/22381063


vc如何产生有效的随机数
int no;
srand((unsigned)time(NULL));
no=rand()%(n)；

例:
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
intmain(void)
{
int i;
time_t t;
srand((unsigned) time(&t));
printf("Ten random numbers from 0 to 99\n\n");
for (i=0; i<10; i++)
printf("%d\n", rand()%100);
return 0;
}
这时运行程序，会发现每次产生的随机数都不一样。这是因为这里采用了时间作为种子,而时间在每时每刻都不相同,所以就产生了"随机"的随机数了。
所以，要想产生不同的随机数，在使用rand之前需要先调用srand。
――――――――――――――――
版权声明：本文为CSDN博主「yueyaquanBoy」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/yueyaquanBoy/article/details/22848281

https://blog.csdn.net/yueyaquanBoy/article/details/22848281

地址: 福田区深南中路1025号新城大厦1楼外文书店 地图 公交 电

选中编辑框后右键没弹复制等菜单.(x no) (v ok)
VC/MFC 如何使列表控件（CListCtrl）可编辑
五、（注意）要显示的控件和列表控件的ID号必须相连，并且列表ID大于显示控件ID,处理方法为：在对话框中依次按下“CTRL+D”组合键，如图：按照顺序依次点击相应控件重新对控件进行排序。
（注意）要显示的控件和列表控件的ID号必须相连，并且列表ID大于显示控件ID,处理方法请参考第五步
https://jingyan.baidu.com/article/e75057f2f438f8ebc91a89a7.html

CString 与数字之间的转换
将字符转换为整数，可以使用atoi、_atoi64或atol。
https://blog.csdn.net/u010025211/article/details/25917957

CString 与 int的互相转换
CString to int:
CString a = "123";
int b;
b = _ttoi(a);
……
int to CString:
b = 123;
a.Format( "%d", b );
https://blog.csdn.net/smallshell7220/article/details/25025293

0x737280001

1578521700

1578530700
1578521700
int CShowData::op_item(_tagTTDataFrame *pStFrame)
{
	int strcount = pME_WD->m_item.GetLength();
	if (strcount == 0)
		return 1;
	else
	{
		for(int i = 0; i< 8-strcount; i++)
		{
			pME_WD->m_item = pME_WD->m_item + ' ';
		}
		if (memcmp(&(pStFrame->arItemCode),pME_WD->m_item,sizeof(char)*8)==0)
			return 1;
		else
			return 0;
	}
}


VC CString 字符串处理函数的应用.doc
https://download.csdn.net/download/zhengyanfeng/3195324

实现MFC CListCtrl控件的可编辑功能(v ok)
https://download.csdn.net/download/shen8686/1472794

VC/MFC 如何使列表控件（CListCtrl）可编辑
https://jingyan.baidu.com/article/e75057f2f438f8ebc91a89a7.html

CListCtrl控件详解
https://blog.csdn.net/milanleon/article/details/29195657

表格控件GridCtrl
https://download.csdn.net/download/yzhuang/3331073

【MFC】CListCtrl列表控件右键复制内容到粘贴板
在列表控件属性中，增加对NM_RCLICK消息处理。
https://blog.csdn.net/sunriver2000/article/details/100134074

listctrl中的cell如何支持被复制
听说grid控件，自带可被复制功能，同时数据又不会被修改，后面可以学习一下该控件的使用。
https://blog.csdn.net/weixin_30399797/article/details/95668148

六种查找算法效率比较
接着上次的排序算法讨论，这次谈的是六种查找算法，分别是：顺序查找、折半查找、二叉树查找、索引查找、开地址哈希查找方法、拉链法哈希查找方法。
https://blog.csdn.net/fangyonghao/article/details/37875373

内存比较函数 - CompareMem（文件、数组等比较）
https://blog.csdn.net/haiou327/article/details/6647162

数据比较函数（内存比较）
https://blog.csdn.net/dongtuoc/article/details/79099485

字符串和内存数据比较函数
https://blog.csdn.net/zhghost/article/details/5286310

关于字符串比较的一点讨论---strcmp与memcmp的效率及实现原理
至此，也明白了为什么这两个函数会有效率的差别，strcmp比较的字符串，而memcmp比较的是内存块，strcmp需要时刻检查是否遇到了字符串结束的 /0 字符，而memcmp则完全不用担心这个问题。另一个区别是
strcmp在比较四字节是逐字节比较，而memcmp是用了字符串比较指令，感觉用字符串比较指令比用逐字节比较好，不知道strcmp为什么比较四字节时不用。感觉memcmp倒是可以用来实现strncmp函数的功能。
遗留的问题有内存字节对齐的问题，以及两处mov edi,edi和一处nop指令的问题。交给以后吧。
――――――――――――――――
版权声明：本文为CSDN博主「jcwKyl」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/jcwKyl/article/details/2217428

strcmp和memcmp两个字符串比较函数
strcmp函数： 
函数原型：int strcmp(const char * s2,const char * s2)；
功能：比较字符串s1和字符串s2的大小。
返回值： 
s1大于s2，返回值大于零 
s1等于s2，返回值等于零 
s1小于s2，返回值小于零
特点：两个字符串之间是逐个按照它们的ASIIC大小来比较的，一旦发现其中一个大于或小于另一个时，比较结束，返回一个值，不然就一直比较到’\0’为止。 
memcmp函数: 
函数原型： 
int memcmp(const void *buf1, const void *buf2, unsigned int count)；
功能：比较内存区域buf1和buf2的前count个字节。
返回值： 
s1大于s2，返回值大于零 
s1等于s2，返回值等于零 
s1小于s2，返回值小于零
特点：memcmp函数也是按ASICC码逐个比较，在strcmp的基础上多加了个功能，他能比较字符串中前count字节的大小。如果count == strlen(s1)，那就是比较字符串中全部字符。
https://blog.csdn.net/Tianzez/article/details/78151454

00:26.97 datacount=271,7545 datainterval=271 ListIndex=32737 ListIndex_bak=0
if (mStFrame.btTransCode == 'e')

00:24.19 datacount=271,7545 datainterval=271 ListIndex=32737 ListIndex_bak=0
		// FindIndex(GetIndex) && ListIndex < ListIndex_bak+100  ps = mCListDataFrame.FindIndex(GetIndex)
		for( ps = mCListDataFrame.GetHeadPosition(); (ps) ; mCListDataFrame.GetNext(ps))  //mCListDataFrame.GetNext(ps)
		{
			//pME_WD->m_TransCode.GetBuffer(2)
			mStFrame = mCListDataFrame.GetAt(ps);
			if (mStFrame.btTransCode == 'e')
			{
				itoa(ListIndex+1,string,10);
				m_list_data.InsertItem(ListIndex,string,0);
				ListIndex++;
			}

//
//			memcpy(GroupCodeString,&mStFrame.btGroupCode,1);
//			m_list_data.SetItemText(ListIndex,1, GroupCodeString);



00:32.13 datacount=271,7545 datainterval=271 ListIndex=1003 ListIndex_bak=1000
SetTimer( 1, 10, NULL ) ;

00:30.48 datacount=271,7545 datainterval=271 ListIndex=3
//			mStFrame = mCListDataFrame.GetAt(ps);
//			itoa(ListIndex+1,string,10);
//			m_list_data.InsertItem(ListIndex,string,0);

// && ListIndex < ListIndex_bak+100
00:35.10 datacount=271,7545 datainterval=271 ListIndex=1003
//			mStFrame = mCListDataFrame.GetAt(ps);
//			itoa(ListIndex+1,string,10);
//			m_list_data.InsertItem(ListIndex,string,0);

c语言中的'\0'的数值是多少 
c语言中“\0”是空字符串。 是字符常量，NULL 字符，ASCII码数值0，用作字符串结尾符。
https://zhidao.baidu.com/question/555056392654487652.html

c语言memset初始化结构体问题
https://zhidao.baidu.com/question/601474806.html?qbl=relate_question_1&word=memset%20%C8%E7%B9%FB%BD%E1%B9%B9%CC%E5%D6%D0%D3%D0%CA%FD%D7%E9%B5%C4%BB%B0%BB%B9%CA%C7%D0%E8%D2%AA%B6%D4%CA%FD%D7%E9%B5%A5%B6%C0%BD%F8%D0%D0%B3%F5%CA%BC%BB%AF%B4%A6%C0%ED%B5%C4

strlen和sizeof有什么区别?
1、sizeof是算符，strlen是函数。 数组做sizeof的参数不退化，传递给strlen就退化为指针了。strlen所作的仅仅是一个计数器的工作，它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，直到碰到第一个字符串结束符'\0'为止，然后返回计数器值(长度不包含'\0')。
2、sizeof操作符的结果类型是size_t，它在头文件中typedef为unsigned int类型。该类型保证能容纳实现所建立的最大对象的字节大小。
https://zhidao.baidu.com/question/12033577.html

memset
另外memset()是一个库函数函数,需要加头文件#include<string.h>
memset是计算机中C/C++语言初始化函数。作用是将某一块内存中的内容全部设置为指定的值， 这个函数通常为新申请的内存做初始化工作。
void *memset(void *s, int ch, size_t n);
函数解释：将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。
memset：作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法 [1]  。
memset()函数原型是extern void *memset(void *buffer, int c, int count) buffer：为指针或是数组,c：是赋给buffer的值,count：是buffer的长度
常见错误
第一：memset函数按字节对内存块进行初始化，所以不能用它将int数组初始化为0和-1之外的其他值（除非该值高字节和低字节相同）。
第二：memset(void *s, int ch,size_t n);中ch实际范围应该在0~~255，因为该函数只能取ch的后八位赋值给你所输入的范围的每个字节
第三： 搞反了 ch 和 n 的位置.一定要记住如果要把一个char a[20]清零，一定是 memset(a,0,20*sizeof(char));而不是 memset(a,20*sizeof(char),0);
第四： 过度使用memset.
char buffer[4];
memset(buffer,0,sizeof(char)*4);
strcpy(buffer,"123");
//"123"中最后隐藏的'\0'占一位，总长4位。
这里的memset是多余的. 因为这块内存马上就被全部覆盖，清零没有意义.
第五：
int some_func(struct something *a)
{memset(a,0,sizeof(a));}
其实这个错误严格来讲不能算用错memset，但是它经常在使用memset的场合出现。这里错误的原因是VC函数传参过程中的指针降级，导致sizeof(a)，返回的是一个something*指针类型大小的的字节数，如果是32位，就是4字节。

int main()
{
    char *s="GoldenGlobalView";
    clrscr();
    memset(s,'G',6);                //这里没有问题，可以编译运行
                    //单步运行到这里会提示内存访问冲突
                     //肯定会访问冲突，s指向的是不可写空间。
    printf("%s",s);
    getchar();
    return 0;
}
一般情况下，清空stTest的方法：
stTest.csName[0]={'\0'}; // question
另外：
如果结构体中有数组的话还是需要对数组单独进行初始化处理的。 // question
https://baike.baidu.com/item/memset/4747579?fr=aladdin

初始化字符串 char[]

2020.01.09

Findwindow

这个关键是要一个主窗口句柄嘛，使用AfxGetMainWnd()这个函数就可以了。
CMyMainDlg *pMMD = (CMyMainDlg*)AfxGetMainWnd();
然后就是
pMMD.ShowWindow(SW_SHOW);

如何判断Dialog窗口

C++多线程――线程同步
#include <Windows.h>
#include <iostream>
using namespace std;

typedef struct  _STRUCT_DATA_
{
	int id; //用于标识出票id
	int tickets;
}_DATA, *_pDATA;

HANDLE g_hEvent;
DWORD WINAPI Fun1(LPVOID lpParam);
DWORD WINAPI Fun2(LPVOID lpParam);

void main()
{
	HANDLE hThread1;
	HANDLE hThread2;

	_DATA stru_data;
	stru_data.id = 0;
	stru_data.tickets = 20;

	g_hEvent = CreateEvent(NULL, FALSE, FALSE, L"Ticket");
	if (g_hEvent) { 
		if (ERROR_ALREADY_EXISTS == GetLastError()) { 
			cout << "the instance is exist!" << endl;			
			return; 
		} 
	}
	
	hThread1 = CreateThread(NULL, 0, Fun1, &stru_data, 0, NULL);
	hThread2 = CreateThread(NULL, 0, Fun2, &stru_data, 0, NULL);

	CloseHandle(hThread1);
	CloseHandle(hThread2);

	SetEvent(g_hEvent);
	Sleep(4000);
	CloseHandle(g_hEvent);
}

DWORD WINAPI Fun1(LPVOID lpParam)
{
	_pDATA data = (_pDATA)lpParam;
	while (TRUE)
	{
		WaitForSingleObject(g_hEvent, INFINITE);
		if (data->tickets > 0)
		{
			Sleep(1);
			cout << "fun1: " << data->id++ ;
			cout << "thread 1:sell ticket: " << data->tickets-- << endl;
			SetEvent(g_hEvent);
		}
		else {
			SetEvent(g_hEvent);
			break;
		}
	}
	return 0;
}

DWORD WINAPI Fun2(LPVOID lpParam)
{
	_pDATA data = (_pDATA)lpParam;
	while (TRUE)
	{
		WaitForSingleObject(g_hEvent, INFINITE);
		if (data->tickets > 0)
		{
			Sleep(1);
			cout << "fun2: " << data->id++ ;
			cout << "thread 2:sell  ticket: " << data->tickets-- << endl;
			SetEvent(g_hEvent);
		}
		else {
			SetEvent(g_hEvent);
			break;
		}
	}
	return 0;
}



https://blog.csdn.net/qq_41498261/article/details/83624326

想问一下POSITION这个变量到底是什么类型，我想将他记录到数据库中，可是… [问题点数：20分，结帖
POSITION变量应该是C++里容器类的迭代器的一个封装吧，如果你想用int来代的话，一般有个FindIndex(int)可以返回第int个元素对应的POSITION变量，如果没有该元素的话，返回NULL
https://bbs.csdn.net/topics/40081562

DataCount = 271 7547


00:08.16秒 counts=1906240
//mCListDataFrame.AddHead(*pStFrame);
mCListDataFrame.AddHead(*pStFrame);
200102.MDS 88,752K

01:28.45秒 counts=19650000
//mCListDataFrame.AddHead(*pStFrame);
mCListDataFrame.AddTail(*pStFrame);
			counts ++;
			if (counts % 10000 == 0)
			{
				TRACE("CUnpacker_TTFrame::InputData counts=%d \n",counts);
			}
181214.MDS 1,118,643K

TRACE("CUnpacker_TTFrame::InputData counts=%d \n",counts);
// 添加打印会变慢很多

CList使用说明
// #include "stdafx.h"
// #include "test.h"
#include <afxtempl.h>
#include <iostream>
using namespace std;
class Point
{
public:
    Point()
    {
        m_x = 0;
        m_y = 0;
    }
    Point(int x, int y)
    {
        m_x = x;
        m_y = y;
    }
	bool operator==(const Point& src) const
    {
        return ( (m_x == src.m_x) && (m_y == src.m_y) );
    }
public:
    int m_x;
    int m_y;
};
typedef CList<Point, Point&>  CPntLst;
int main()
{
    CPntLst     lst;
    Point       point, elem1, elem2;
    elem1.m_x = 52;
    elem1.m_y = 102;
    elem2.m_x = 14;
    elem2.m_y = 1621;
	
    // add a element from tail, certainly, also can from head
    lst.AddTail(elem1);
    lst.AddTail(elem2);
    // print the point count
    cout<< "count: "<<lst.GetCount()<<endl;
    // traverse the whole list
    cout << "First time:\n";
    size_t index = 0;
    POSITION ps;
	
    for( ps = lst.GetHeadPosition();ps;lst.GetNext(ps) )
    {
		// extract the point according the current position
		point = lst.GetAt(ps);
		printf("index: %d, m_x = %d, m_y = %d\n", index++, point.m_x, point.m_y);
    }
    // search the point which is equal to elem1
    ps = lst.Find(elem1);
    point = lst.GetAt(ps);
    printf("elem1: m_x = %d, m_y = %d\n", point.m_x, point.m_y);
    Point elem3(123, 123123);
    // insert elem3 into the list after elem1
    lst.InsertAfter(ps, elem3);
    cout << "Second time:\n";
    for( ps = lst.GetHeadPosition();ps;lst.GetNext(ps) )
    {
		// extract the point according the current position
		point = lst.GetAt(ps);
		printf("index: %d, m_x = %d, m_y = %d\n", index++, point.m_x, point.m_y);
    }
    // remove elem1
    ps = lst.Find(elem1);
    lst.RemoveAt(ps);
    cout << "Third time:\n";
    for( ps = lst.GetHeadPosition();ps;lst.GetNext(ps) )
    {
		// extract the point according the current position
		point = lst.GetAt(ps);
		printf("index: %d, m_x = %d, m_y = %d\n", index++, point.m_x, point.m_y);
    }
    // remove all the rest
    lst.RemoveAll();
    cout << "Fourth time:\n";
    for( ps = lst.GetHeadPosition();ps;lst.GetNext(ps) )
    {
		// extract the point according the current position
		point = lst.GetAt(ps);
		printf("index: %d, m_x = %d, m_y = %d\n", index++, point.m_x, point.m_y);
    }
    return 0;
}
https://blog.csdn.net/liups/article/details/42567035


CList如何使用，用法举例
int main()
{

??? CPntLst???? lst;

??? Point?????? point, elem1, elem2;

??? elem1.m_x = 52;

??? elem1.m_y = 102;

??? elem2.m_x = 14;

??? elem2.m_y = 1621;

??? // add a element from tail, certainly, also can from head

??? lst.AddTail(elem1);

??? lst.AddTail(elem2);

// print the point count

cout<<"count: "<<lst.GetCount()<<endl;

// traverse the whole list

size_t index = 0;

for( POSITION ps = lst.GetHeadPosition();

???? ps;

??? lst.GetNext(ps) )

{??????

??? // extract the point according the current position

??? point = lst.GetAt(ps);

??? printf("index: %d, m_x = %d, m_y = %d\n", index++, point.m_x, point.m_y);

}

// search the point which is equal to elem1

ps = lst.Find(elem1);

point = lst.GetAt(ps);

printf("elem1: m_x = %d, m_y = %d\n", point.m_x, point.m_y);

Point elem3(123, 123123);

// insert elem3 into the list after elem1

lst.InsertAfter(ps, elem3);

// remove elem1

lst.RemoveAt(ps);

// remove all the rest

lst.RemoveAll();

return 0;

}
――――――――――――――――
版权声明：本文为CSDN博主「月光秦王」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/yueguangbuxiu/article/details/7310466
https://blog.csdn.net/yueguangbuxiu/article/details/7310466


MFC中CList类使用注意
https://blog.csdn.net/ellor/article/details/1714736

CList的用法理解
6、链表的遍历
方式1：
POSITION pos = myList.GetHeadPostion();
while(pos != NULL)
{
CString? str = myList.GetNext(pos); //GetNext(pos),先返回pos位置的元素的值，再把pos指向当前位置的下一个。
}

方式2：
for(int i = 0 ; i < myList.GetCount(); i++)
{
CString str = myList.GetAt(myList.FindIndex(i));
}

总结：方式2，明显比方式1慢.方式1只需要执行N此就可以了，方式2，需要执行1+2+。。。+N = （1 + N）*N/2次

由于时间关系，写的也不是非常完整，需要这方面知识的，请多看MSDN帮助信息，祝你顺利~
最后还是请教一下大家，怎么把CList声明为const类型？欢迎留言~
――――――――――――――――
版权声明：本文为CSDN博主「曾经一片」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zengweicdut/article/details/8699402
https://blog.csdn.net/zengweicdut/article/details/8699402


00:08.16秒 counts=1906240
//mCListDataFrame.AddHead(*pStFrame);
mCListDataFrame.AddHead(*pStFrame);
200102.MDS 88,752K

00:07.57秒 counts=1906240
mCArrayItemDataFrame.Add(*pStFrame);
//mCListDataFrame.AddHead(*pStFrame);
200102.MDS 88,752K

01:25.02秒 counts=19592190
//mCListDataFrame.AddHead(*pStFrame);
mCListDataFrame.AddTail(*pStFrame);
181214.MDS 1,118,643K
------------
00:08.32秒 counts=1906240
//mCListDataFrame.AddHead(*pStFrame);
mCListDataFrame.AddTail(*pStFrame);
200102.MDS 88,752K

> 05:30秒 counts=1082351
//mCArrayItemDataFrame.Add(*pStFrame);
mCArrayItemDataFrame.Add(*pStFrame);
00:08.44秒
//mCListDataFrame.AddHead(*pStFrame);
mCListDataFrame.AddTail(*pStFrame);

00:07.75秒
mCArrayItemDataFrame.Add(*pStFrame);
//mCListDataFrame.AddHead(*pStFrame);
00:07.36秒
mCListDataFrame.AddHead(*pStFrame);
//mCListDataFrame.AddHead(*pStFrame);

00:07.52秒
//mCListDataFrame.AddHead(*pStFrame);
//mCListDataFrame.AddHead(*pStFrame);
00:01.59
//m_pUnpacker->InputData( (BYTE*)pPkgBuf, pkgSize ) ; 
200102.MDS 88,752K

------------------
02:10.97秒
mCArrayItemDataFrame.Add(*pStFrame);
//mCListDataFrame.AddHead(*pStFrame);
01:25.55秒
mCListDataFrame.AddHead(*pStFrame);
//mCListDataFrame.AddHead(*pStFrame);
01:24.96秒
//mCListDataFrame.AddHead(*pStFrame);
//mCListDataFrame.AddHead(*pStFrame);

00:09.19
//m_pUnpacker->InputData( (BYTE*)pPkgBuf, pkgSize ) ; 
181214.MDS 1,118,643K

00:07.52秒
//mCListDataFrame.AddHead(*pStFrame);
//mCListDataFrame.AddHead(*pStFrame);
00:01.59
//m_pUnpacker->InputData( (BYTE*)pPkgBuf, pkgSize ) ; 
200102.MDS 88,752K

2020.01.08 
---------------------------------------------------------------
C++：char、int占多少字节
x86

sizeof(char) ?1
sizeof(char*) ?4
sizeof(int) ?4
sizeof(int*) ?4
sizeof(double) ?8
sizeof(double*) ?4
sizeof(float) ?4
sizeof(float*) ?4
sizeof(string) ?28
sizeof(string*) ?4

x64

sizeof(char) ?1
sizeof(char*) ?8
sizeof(int) ?4
sizeof(int*) ?8
sizeof(double) ?8
sizeof(double*) ?8
sizeof(float) ?4
sizeof(float*) ?8
sizeof(string) ?40
sizeof(string*) ?8

指针只与系统有关，与类型无关
https://blog.csdn.net/ueh286/article/details/98210588

c++ int转char*
第一种方法：

int i=0;  
char itc[10];  
sprintf(itc,"%d.bmp",i);  


第二种方法：

int i=5;

char err_str[10];

_itoa(i, err_str, 10); //
https://blog.csdn.net/jacke121/article/details/80235064


在VC中,CSTRING类的用法形式多样,丰富多彩.但有时与传统数据类型之间的转换成为了很多人的难题.
下面我来简单介绍它们之间的关系.
1 如何实现cstring与char*之间的转换:

  CString   m_cstr="abc";   
  char*   m_char="def";   

  char*   lp=m_cstr.GetBuffer(m_cstr.GetLength());          
  m_cstr.ReleaseBuffer();   
    
     //相反的char* 转换成cstring
  m_cstr.Format("%s",lp);    // lp为数组指针


第二种：强制类型转换为   LPCTSTR   
  LPTSTR   p   =   m_cstr.GetBuffer(   10   );   
  strcpy(   Count,   p   );      
  m_cstr.ReleaseBuffer(   );   
  

2 .cstring 与BYTE之间的转换

BYET 为无符号字符型.原理与CHAR类似

CString m_cstr;
BYTE m_byte[100];
m_byte=(BYTE*)m_cstr.GetBuffer(m_cstr.GetLength());  //cstring转BYTE

同理:
m_cstr.format("%s",m_byte);   //BYTE字符串输出 

3 BYTE与CHAR类型之间的转换

strcpy,memcpy 函数皆可以强制转换

strcpy(m_char,(char*)m_byte);

strlen=(char*)m_byet;

memcpy(m_char,m_byte,strlen);

分类: visual c++
https://www.cnblogs.com/zhwl/archive/2012/11/27/2790601.html


CString转换 char[100] 
     
    char a[100]; 
    CString str("aaaaaa"); 
    strncpy(a,(LPCTSTR)str,sizeof(a));
https://www.xuebuyuan.com/3263371.html

Unhandled exception in MsEdit_Wendy.exe 0xCoooooo5:Access Violation. (x no)

C++字符数组初始化为空
char str[1024] = {0};

mfc中如何让listctrl生成行序号 [问题点数：40分，结帖人bshedu]
void CUserManger::List(CString sql)  //将SQL语句查询的结果显示在列表框中
{
	m_useradmin.DeleteAllItems(); 
	
	int nItem=0;
	char string[25];
	try
	{
		m_pRecordset.CreateInstance("ADODB.Recordset");
		m_pRecordset->Open((_variant_t)sql,_variant_t((IDispatch*)theApp.m_pConnection,true),adOpenStatic,adLockOptimistic,adCmdText);
		if(!m_pRecordset->adoEOF) //如果记录不为空
		{	
			while(!m_pRecordset->adoEOF)
			{	
				itoa(nItem,string,10);
				m_useradmin.InsertItem(nItem,string,0);
				m_useradmin.SetItemText(nItem,1,(LPCTSTR)(_bstr_t)m_pRecordset->GetCollect("AdminName"));
				m_useradmin.SetItemText(nItem,2,(LPCTSTR)(_bstr_t)m_pRecordset->GetCollect("权限"));
				m_useradmin.SetItemText(nItem,3,(LPCTSTR)(_bstr_t)m_pRecordset->GetCollect("创建时间"));
				nItem++;
				m_pRecordset->MoveNext();
			}
		}
		
		m_pRecordset->Close();
	}
	catch (_com_error e)
	{						
		CATCH_ERROR;
		return;
	}
	
}

	EnterCriticalSection(&m_cs);
	for( i=0; i<m_TTOptions->m_nDataTotal; i++ )
		m_arrItem.Add(m_TTOptions->m_pDataBuf[i]);
	LeaveCriticalSection( &m_cs );
https://bbs.csdn.net/topics/370128996


Strategy.h (options 1.0.0.57):	CArrayItem  m_arrItem;
TTOptions.h (options 1.0.0.57):typedef CArray<ItemOptions, ItemOptions&> CArrayItem;

---- : public CObject Matches (3 in 1 files) ----
Afxtempl.h (c:\users\wendy\desktop):class CArray : public CObject
Afxtempl.h (c:\users\wendy\desktop):class CList : public CObject
Afxtempl.h (c:\users\wendy\desktop):class CMap : public CObject
---- : public BASE_CLASS Matches (3 in 1 files) ----
Afxtempl.h (c:\users\wendy\desktop):class CTypedPtrArray : public BASE_CLASS
Afxtempl.h (c:\users\wendy\desktop):class _CTypedPtrList : public BASE_CLASS
Afxtempl.h (c:\users\wendy\desktop):class CTypedPtrMap : public BASE_CLASS


MFC中控件之CListCtrl的使用总结
m_ListCtrl.InsertColumn(0, _T("第0列"), LVCFMT_LEFT, 100);
m_ListCtrl.InsertColumn(1, _T("第1列"), LVCFMT_LEFT, 100);
m_ListCtrl.InsertColumn(2, _T("第2列"), LVCFMT_LEFT, 100);
m_ListCtrl.InsertItem(0, _T("第0行"), 3);//首行添加
m_ListCtrl.InsertItem(1, _T("第1行"), 4);//首行添加
m_ListCtrl.InsertItem(2, _T("第2行"), 5);//首行添加

6.添加几条数据向列表控件中：
for(int i = 0; i < 10; i++)
{
m_ListCtrl.InsertItem(i,"");
m_ListCtrl.SetItemText(i,0, "第一列");
m_ListCtrl.SetItemText(i,1, "第二列");
m_ListCtrl.SetItemText(i,2, "第三列");
}

10.获得列表的列数及行数：
    //得到列表的列数
    int nHeadNum = m_list.GetHeaderCtrl()->GetItemCount();
    //得到列表的行数
    m_list.GetItemCount();
https://blog.csdn.net/lovescjinbao/article/details/17691597

BOOL CShowData::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

	m_list_data.InsertColumn(0,"btGroupCode", LVCFMT_LEFT, 100);
	m_list_data.InsertColumn(1,"nLength", LVCFMT_LEFT, 70);
	m_list_data.InsertColumn(2,"lTime", LVCFMT_LEFT, 50);
	m_list_data.InsertColumn(3,"arItemCode", LVCFMT_LEFT, 90);
	m_list_data.InsertColumn(4,"btTransCode", LVCFMT_LEFT, 100);
	m_list_data.InsertColumn(5,"nTransDataLength", LVCFMT_LEFT, 150);
	m_list_data.InsertColumn(6,"pTransData", LVCFMT_LEFT, 90);
...}

#ifdef _DEBUG
void CWnd::AssertValid() const
{
	if (m_hWnd == NULL)
		return;     // null (unattached) windows are valid
...

		CObject* p;
		ASSERT((p = pMap->LookupPermanent(m_hWnd)) != NULL ||
			(p = pMap->LookupTemporary(m_hWnd)) != NULL);
		ASSERT((CWnd*)p == this);   // must be us
// Note: if either of the above asserts fire and you are
		// writing a multithreaded application, it is likely that
		// you have passed a C++ object from one thread to another
		// and have used that object in a way that was not intended.
		// (only simple inline wrapper functions should be used)
		//
		// In general, CWnd objects should be passed by HWND from
		// one thread to another.  The receiving thread can wrap
		// the HWND with a CWnd object by using CWnd::FromHandle.
		//
		// It is dangerous to pass C++ objects from one thread to
		// another, unless the objects are designed to be used in
		// such a manner.
..}
https://bbs.csdn.net/topics/50194470

复制粘贴乱码
电脑上为什么复制以后粘贴出来的都是乱码?
电脑上为什么复制以后粘贴出来的都是乱码：
在Windows 2000和Windows XP系统中，经常会在执行“复制”、“粘贴”操作时，粘贴到文本文件里的文字都是乱码，这实际是系统设置问题。解决该问题的方法操作如下几种：
1．在复制文字前用打开任意一种中文输入法，再执行“复制”→“粘贴”操作，这样就不会出现乱码问题了。
2．不使用操作系统自带的“文本编辑器”，如记事本。而是安装专门的EmEditor或UltraEdit文本编辑器，在里面选择“按ANSI方式粘贴”功能也可以。
3．最好解决方法是在系统中是把默认文字输入法设为中文状态下的英文输入法。如在“文字服务和输入语言”设置对话框中，通常会有英语和简体中文两种语言，英语下面有“英语（美国）”一类的项目，中文下面则有“简体中文输入法（美国）”、“微软拼音输入法”一类的项目。实际上，这个“简体中文输入法（美国）” 就是在中文状态下输入英文的，但是它与英语下面的“英语（美国）”又不同，后者是在英文状态下输入英文。只要你把要这个“简体中文输入法（美国）”设为默认输入法，以后右下角输入法上面总是显示“Ch”，而不是“En”，就不会出现粘贴乱码的情况了。如果你的电脑中找不到这一项，说明你没有安装，可通过系统安装盘进行安装。
https://zhidao.baidu.com/question/69533597.html

counts = 1906240

int counts = 0;
BOOL CUnpacker_TTFrame::InputData( BYTE* pBuf, int bufSize ) 
{...
		{//找到一帧
			//ATLTRACE("Find a frame .\n");
			unsigned char * buf=buff+sizeof(_tagTTDataFrame)+1; //for crc16
			counts ++;
...}

2020.01.07

(转)VC6调试技巧总结b
https://www.it610.com/article/5149622.htm

关于成员变量发生改变时的断点问题

Master::m_pDataSrc_TTFrameFile

CDataSrc_TTFrameFile::m_pProc

CUnpacker_TTFrame::pStFrame

vc++6.0断点调试
https://blog.csdn.net/zxq1138634642/article/details/8108983

一个在VC6中设置数据断点的问题，困扰我好久了 [问题点数：40分，结帖人Snailqiu]

vc++是否可设这样的断点，当变量值变化时中断？

vs中如何跟踪某个变量，一旦其值变化，立刻break

不能添加文件到目录(x no)

m_RecDataCount = 90853904 (10240)

Compiling...
MsEdit_WendyDlg.cpp
D:\Program Files\Microsoft Visual Studio\MyProjects\MsEdit_Wendy\MsEdit_WendyDlg.cpp(17) : error C2146: syntax error : missing ';' before identifier 'g_Master'
D:\Program Files\Microsoft Visual Studio\MyProjects\MsEdit_Wendy\MsEdit_WendyDlg.cpp(17) : error C2501: 'Master' : missing storage-class or type specifiers
D:\Program Files\Microsoft Visual Studio\MyProjects\MsEdit_Wendy\MsEdit_WendyDlg.cpp(17) : fatal error C1004: unexpected end of file found
Generating Code...
Compiling...
Master.cpp
Generating Code...
执行 cl.exe 时出错.
Creating browse info file...
BSCMAKE: error BK1506 : cannot open file '.\Debug\MsEdit_WendyDlg.sbr': No such file or directory
执行 bscmake.exe 时出错.
MsEdit_Wendy.exe - 1 error(s), 0 warning(s)(v ok)
#include "Master.h"


为CListBox加上智能水平滚动条
https://blog.csdn.net/i_like_cpp/article/details/196513


 C++  > MFC自动水平滚动条CListBox
https://download.csdn.net/download/ayang1986/9586701

为CListBox垂直滚动条，自动滚动，文字显示不全问题！
https://blog.csdn.net/u012307430/article/details/51556941

//#define IDD_MSEDIT_WENDY_DIALOG         102
#define IDD_READMDS                     102
enum { IDD = IDD_READMDS };  // IDD_MSEDIT_WENDY_DIALOG
更改对话框资源ID名称后，不能双击按钮添加响应函数(v ok)

2020.01.06 

struct _tagTTDataFrame{
	int nLength;
	time_t lTime;
	BYTE btGroupCode;
	char arItemCode[8];
	BYTE btTransCode;
	int nTransDataLength;
	void * pTransData;
};

2020-01-03 13:45:11(102004014), ==========================Start==========================
2020-01-03 13:45:13(102005777), Groupmng.dll load fail!
2020-01-03 13:45:22(102014825), Item:002      TransCode:E  Delay:10  Time:0-0
2020-01-03 13:45:23(102015824), open E:\200102\200102.MDS OK
2020-01-03 13:45:28(102020597), finish read E:\200102\200102.MDS
2020-01-03 13:45:28(102020597), finish ttframe files
2020-01-03 13:45:28(102020597), Frame-'E' total='0'
2020-01-03 13:45:28(102020597), EndThread DataSrc_TTFrameFile.
2020-01-03 13:45:28(102020691), ProcTTFrame-InputData finished.
2020-01-03 13:45:28(102020691), EndThread ProcTTFrame.
2020-01-03 13:45:28(102020691), ===========================End===========================


请问.des文件怎么打开
.des文件出现表示已经加密了。如果你自己没有设定密码，那么就是它自动生成密钥了。
DES是安全性比较高的一种算法,目前只有一种方法可以破解该算法,那就是穷举法。
你要先知道如果des使用的是多少位的密钥，如果是56位的密钥，则可能的密钥数量是2的56次方个。然后下载强行破解软件，因为攻击des的主要形式被称为蛮力的或彻底密钥搜索，即重复尝试各种密钥直到有一个符合为止。就我所知，应该都是收费的并且很难搞懂的黑客软件。
我觉得希望不大……真的。
https://zhidao.baidu.com/question/118378997.html

如何打开后缀为.DES格式文件？
我的图片用加密精灵加密解密过后，JPG格式后缀加了一个.des请问如何才能恢复我原来的JPG格式
PHOTOSHOP打不开的！
各种方法都试过了！都没用！
该问题我已经解决了！主要是加密软件未注册，我花了38元购买了软件重新定义为安全加密后，重新解密就可以了！所以这些不知名的加密软件不了解还是最好不要用！
这个要解密了才能打开的。你用加密精灵解开就行了。
https://zhidao.baidu.com/question/121075317.html

VC6.0 不能断点调试的解决方法 VC6.0没有debug模式
调试旧程序，VC6.0环境
1.VC6.0没有debug模式
Build->Configurations->Add
2.VC6.0不能断点调试  转载地址：http://blog.csdn.net/bin_zh123/article/details/5733459
现象是用 debug中的 step info或者run to cursor合着设置断点会出现One or morebreakpoints cannot be set and have been disabled.   Execution will stopat the beginning of the program.解决方法，
1.在project->setting->c/c++-general->debug info->program databse for edit and continue ;
2.edit->breakpoints->removeall;
3.build->set active project configuration->*.exe win32 debug.
经过以上三步，ok!
另一篇:
一、两种调试方式：
1、Debug模式：
2、Release模式: (v ok)
单击菜单[Project]->[Settings…],出现"Project Settings"对话框，选择“Release”状态；
将C/C++标签中的Category选择General,Optimizations选Disable (Debug),Debug info选Program Database；
在Link标签中选中Generate debug info复选框。
注：Release模式稍好点，因为某些情况程序只能在Release下运行，如“显示对话框的DLL”在Debug下显示出窗口后 就死在那里。
二、调试中可能的错误：“不能调试”、“断点错误”。
1、“不能调试”：
“One or more breakpoints cannot be set and have been disabled. Execution will stop at the beginning of the program.”
2、“断点错误”：
"One or more breakpoints are not positioned on valid lines.These breakpoints have been moved to the next valid line."
注意：“不能调试”跟“断点错误”不是一回事，“断点错误”会禁用某些错误断点，但“不能调试”则会禁用所有断点。
三、解决方法
1、对于“断点错误”，VC会自动帮我们定位到一行，我们不用理会！
2、对于“不能调试”，解决步骤如下：
1)、重起电脑
2)、把工程拷贝到新目录，删除ncb, .opt,.plg文件。 注意是拷贝，不是剪切。
3)、再菜单栏(menu)：Build->Rebuild All。
https://blog.csdn.net/hjk216/article/details/53422540


MsEdit.dsp
SOURCE=.\BrokersTrace.cpp
# End Source File
# Begin Source File


vc6.0不能在工程里面添加文件
win7的系统，装了vc6.0。不能在工程中添加文件，已经按照了FileTool控件了，添加文件的时候会提示unable to add file to the active project。
本人菜鸟，希望大神帮帮忙啊帮帮忙，感激不尽！
用记事本打开.dsp文件，看看里面是否已有要添加的文件，将其删除重新添加就OK了。我的就是这样给解决了。
https://zhidao.baidu.com/question/1605878237145018307.html

Unpacker_TTFrame.cpp
e:\msedit\msedit\datadef.h(1056) : warning C4183: 'Init': member function definition looks like a ctor, but name does not match enclosing class
e:\msedit\msedit\datadef.h(1088) : warning C4183: 'Init': member function definition looks like a ctor, but name does not match enclosing class
e:\msedit\msedit\mylistener.h(167) : error C2143: syntax error : missing ';' before '*'
e:\msedit\msedit\mylistener.h(167) : error C2501: 'DbEnv' : missing storage-class or type specifiers
e:\msedit\msedit\mylistener.h(167) : error C2501: 'm_pdbEnv' : missing storage-class or type specifiers
e:\msedit\msedit\mylistener.h(168) : error C2143: syntax error : missing ';' before '*'
e:\msedit\msedit\mylistener.h(168) : error C2501: 'Db' : missing storage-class or type specifiers
e:\msedit\msedit\mylistener.h(168) : error C2501: 'm_pdb' : missing storage-class or type specifiers
e:\msedit\msedit\filesync.h(16) : fatal error C1083: Cannot open include file: 'C:\\db-4.8.30\\build_windows\\db_cxx.h': No such file or directory
Generating Code...



MFC编译错误之cannot open file '.\Debug\xxxDlg.sbr': No such file or directory


原创linwx2010 发布于2015-06-30 09:57:53 阅读数 3133  收藏
展开

最近做个MFC小程序，今天在添加了一个自定义函数后出现了一个编译错误：

Creating browse info file...
BSCMAKE:error BK1506 : cannot open file '.\Debug\COMTOOLDlg.sbr':No such file or directory
Error executing bscmake.exe.



删除Debug文件夹，重新编译项目不能解决问题。
上网搜索解决办法：


1、删除 .ncb .opt文件，删除删除Debug文件夹，重新打开项目，Rebuild All，问题解决。




2、取消Build Browser Info file

方法：Project-->Settings-->Browser Info-->取消Build Browser Info file
――――――――――――――――
版权声明：本文为CSDN博主「linwx2010」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/linwx2010/article/details/46691879
https://blog.csdn.net/linwx2010/article/details/46691879


source insight 和 vc6 工作代码区显示的中文复制到记事本或UltraEdit中显示乱码(x no)
https://zhidao.baidu.com/question/69533597.html (v ok)

		case 'e':   //andy add 2014.01.28 'e'′úì?'t'
			HandleFrame_e(buff,Len);
			break;

每天"新英细姐"
分主次急缓
2020.01.03

Astyle编程语言格式化工具的中文说明
http://blog.chinaunix.net/uid-20662363-id-1904145.html

代码风格格式化--Astyle
https://winddoing.github.io/post/62371.html

如何在source insight中使用astyle的代码整理功能
https://zhidao.baidu.com/question/2142157796077477988.html?qbl=relate_question_2&word=sourceinsight%20Astyle%20%B8%F1%CA%BD%BB%AF%BE%D6%B2%BF%B4%FA%C2%EB

source insight代码格式化（Astyle）(v ok)
https://blog.csdn.net/wzk456/article/details/24302975

vc++ 6.0 怎么格式化代码？(v ok)
你是想让代码自动排版吧
选中代码或者全选代码，按"Alt+F8"就可以了
https://zhidao.baidu.com/question/452298511.html

Source Insight 批量注释 多行注释宏
https://blog.csdn.net/darennet/article/details/8495551 (v ok)

source insight中注释_取注快捷键设置方法
source insight中注释_取注快捷键设置方法：（使用//注释）
??? 1、打开Source Insight4.0，点击Project->Open Project->打开base项目->打开Base下的utils.em文件；相对路径如下：
./Source Insight 4.0/Projects/Base/utils.em
??? 2、在文件utils.em末尾添加下面代码,然后在source insight中点击Options->Key Assignments（键值分配）为Macro:MultiLineComment分配快捷键，比如Alt+/；或者点击Options->Menu Assignments（菜单分配）为Macro:MultiLineComment分配菜单按钮
――――――――――――――――
版权声明：本文为CSDN博主「WenKang_00」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_31701279/article/details/78511614
https://blog.csdn.net/qq_31701279/article/details/78511614 (v ok)

win7系统中pdf文件怎么打开(v ok)
方法二、
直接将pdf格式文件拖到浏览器图标上面，放开鼠标你就会惊奇的发现PDF文件打开了!
福昕pdf阅读器
https://www.win7qjb.com/jiaocheng/42279.html

获取系统运行进程信息――PSAPI介绍使用 .(v ok)

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <psapi.h>
 
#pragma comment (lib, "Psapi.lib")
// To ensure correct resolution of symbols, add Psapi.lib to TARGETLIBS
// and compile with -DPSAPI_VERSION=1
 
int PrintModules( DWORD processID )
{
	HMODULE hMods[1024];
	HANDLE hProcess;
	DWORD cbNeeded;
	unsigned int i;
 
	// Print the process identifier.
 
	printf( "\nProcess ID: %u\n", processID );
 
	// Get a handle to the process.
 
	hProcess = OpenProcess( PROCESS_QUERY_INFORMATION |
		PROCESS_VM_READ,
		FALSE, processID );
	if (NULL == hProcess)
		return 1;
 
	// Get a list of all the modules in this process.
 
	if( EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded))
	{
		for ( i = 0; i < (cbNeeded / sizeof(HMODULE)); i++ )
		{
			TCHAR szModName[MAX_PATH];
 
			// Get the full path to the module's file.
 
			if ( GetModuleFileNameEx( hProcess, hMods[i], szModName,
				sizeof(szModName) / sizeof(TCHAR)))
			{
				// Print the module name and handle value.
 
				_tprintf( TEXT("\t%s (0x%08X)\n"), szModName, hMods[i] );
			}
		}
	}
 
	// Release the handle to the process.
 
	CloseHandle( hProcess );
 
	return 0;
}
 
int main( void )
{
 
	DWORD aProcesses[1024]; 
	DWORD cbNeeded; 
	DWORD cProcesses;
	unsigned int i;
 
	// Get the list of process identifiers.
 
	if ( !EnumProcesses( aProcesses, sizeof(aProcesses), &cbNeeded ) )
		return 1;
 
	// Calculate how many process identifiers were returned.
 
	cProcesses = cbNeeded / sizeof(DWORD);
 
	// Print the names of the modules for each process.
 
	for ( i = 0; i < cProcesses; i++ )
	{
		PrintModules( aProcesses[i] );
	}
 
	return 0;
}


https://blog.csdn.net/fanpeii/article/details/8107527

GetProcessImageFileName GetProcessImageFileNameA 

psapi.h 头文件psapi.dll 下载 (v ok)
psapi.lib复制到vc++6.0的lib目录下（如：C:\Program Files\Microsoft Visual Studio\VC98\Lib），psapi.h复制到Include目录下（如：C:\Program Files\Microsoft Visual Studio\VC98\Include）便可使用，psapi.dll一般在system32目录下会自带，所以可以不做操作

获取当前所有进程的完整路径
https://blog.csdn.net/u014417619/article/details/52797855?utm_source=blogxgwz4

遍历进程,获取当前进程下进程的路径.(获得全路径)
https://blog.csdn.net/hgreminem/article/details/4305084

MFC中获取进程名、PID及进程所在路径
https://blog.csdn.net/hgreminem/article/details/4305084

MFC获得指定进程的ID，路径及终止进程
https://blog.csdn.net/lebao82/article/details/17142789

C++ 获取进程所在目录（全路径）

获取windows下任务管理器中的进程列表
#include "stdafx.h"

//int main(int argc, char* argv[])
//{
//	printf("Hello World!\n");
//	return 0;
//}

#include <iostream>
#include <Windows.h>
#include <Tlhelp32.h>
using namespace std;
 
int main(int argc, char** argv)
{
    HANDLE hProcessSnp = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if(NULL == hProcessSnp)
    {
        return -1;
    }
    
    /* 列举第一个进程 */
    PROCESSENTRY32 pe32 = {0};
    pe32.dwSize = sizeof(pe32);
    BOOL bResult = Process32First(hProcessSnp, &pe32);
    while(bResult)
    {
        cout << pe32.szExeFile << endl;
        bResult = Process32Next(hProcessSnp, &pe32);
    }
    CloseHandle(hProcessSnp);
    
    getchar();
    return 0;
}
https://blog.csdn.net/c1520006273/article/details/50542052 (v ok)


求VC++6.0中注释多行代码的快捷键组合!!!!!!!!! [问题点数：5分，结帖人aqbeyond]
https://bbs.csdn.net/topics/70072414 (v ok)

VC++6.0中设置注释多行代码的快捷键组合(v ok)
https://blog.csdn.net/zz460833359/article/details/48348431

为Visual C++ 6.0添加批量注释和取消批量注释功能
首先在Visual C++ 6.0的安装目录下“Microsoft Visual Studio\Common\MSDev98\Macros”中新建一个txt文件，复制如下代码到文件中：然后把文件保存为Comment.dsm，注意文件后缀为dsm，文件类型也要更改。
打开VC6.0，Tools-Customize
打开Add-ins and Macro Files标签页，在下面勾上刚刚新建的文件名Comment，如果没有，点击下面的Browse找到自己保存的文件。
打开Commands标签页，下拉Category找到Macros，右边会出现CancelSelNote和SetSelNote，分别代表取消注释和添加注释的功能。
用左键选中CancelSelNote或SetSelNote不放，把它们拖动到工具栏上，然后放手，会弹出下面的对话框，让你给这个功能选择一个图标，可以随意选择，然后确定即可。
注意：

当你用【取消注释】这个功能时，它会删除选中行的前两个字符。。。

　　正常情况下，删除的是每一行前面“//”这两个字符，但是，有时候，你选中多行时，如果其中有1行是不带注释的，那么，它也会删除这行的前两个字符。自己可以慢慢试一下，就清楚了。

　　所以，在使用【 取消注释 】功能时，要慎用。
――――――――――――――――
版权声明：本文为CSDN博主「qlexcel」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qlexcel/article/details/86709679
https://blog.csdn.net/qlexcel/article/details/86709679 (v ok)

VC6.0快捷键 与 Visual Assist X 快捷键(转载)
https://blog.csdn.net/weixin_30432007/article/details/96790356

VS 和Visual Assist X快捷键
https://blog.csdn.net/xueying_/article/details/7679042

MultiByteToWideChar和WideCharToMultiByte用法详解
void main()
{
    char sBuf[25]={0};

    strcpy(sBuf, "我最棒");

    //获取输入缓存大小
    int sBufSize=strlen(sBuf);
    //获取输出缓存大小
    //VC++ 默认使用ANSI，故取第一个参数为CP_ACP
    DWORD dBufSize=MultiByteToWideChar(CP_ACP, 0, sBuf, sBufSize, NULL, 0);
    printf("需要wchar_t%u个\n", dBufSize);

    wchar_t * dBuf=new wchar_t[dBufSize];
    wmemset(dBuf, 0, dBufSize);

    //进行转换
    int nRet=MultiByteToWideChar(CP_ACP, 0, sBuf, sBufSize, dBuf, dBufSize);
    
    if(nRet<=0)
    {
        cout<<"转换失败"<<endl;
        DWORD dwErr=GetLastError();
        switch(dwErr)
        {
        case ERROR_INSUFFICIENT_BUFFER:
            printf("ERROR_INSUFFICIENT_BUFFER\n");
            break;
        case ERROR_INVALID_FLAGS:
            printf("ERROR_INVALID_FLAGS\n");
            break;
        case ERROR_INVALID_PARAMETER:
            printf("ERROR_INVALID_PARAMETER\n");
            break;
        case ERROR_NO_UNICODE_TRANSLATION:
            printf("ERROR_NO_UNICODE_TRANSLATION\n");
            break;
        }
    }
    else
    {
        cout<<"转换成功"<<endl;
        cout<<dBuf; 
    }

    delete(dBuf);
}
https://www.cnblogs.com/ranjiewen/p/5770639.html

Window获取所有运行的进程
https://blog.csdn.net/oshirdey/article/details/29407467

Windows编程 - 遍历所有进程(exe) 代码(C++)
https://blog.csdn.net/caroline_wendy/article/details/29381987

【转】Windows下如何枚举所有进程（含代码）
https://blog.csdn.net/zdragon2002/article/details/3690925

急！获取windows中所有正在运行的应用程序信息 [问题点数：20分，结帖人liaoyilin_2001]
https://bbs.csdn.net/topics/310054898

C语言编写获取当前系统所有正在运行的应用程序
EnumProcesses函数枚举进程。
https://ask.csdn.net/questions/201936

获取当前正在运行的应用程序

查看正在打开的应用程序或目录

最近打开的目录或程序

Windows 三种开机自启动的设置方式（全面）
https://blog.csdn.net/lee008108/article/details/78713385

Windows设置自己的程序开机自动启动
https://blog.csdn.net/lwpkjio/article/details/85129507

开机自动打开最近的目录或程序

vc打开文件和打开文件所在目录
https://blog.csdn.net/mail_cm/article/details/7248359

cmd一次性打开多个应用程序
https://blog.csdn.net/xufeng0991/article/details/41309603

批处理一键打开多个应用程序
@echo off
echo Starting PLSQL...
start "" "D:\YLZ\PLSQL Developer 12正式版64位+中文语言包+注册码\plsqldev.exe"
echo Starting sublime...
start "" "D:\QuickStart\sublime"
echo Starting youdao...
start "" "D:\QuickStart\youdao"
echo Starting idea...
start "" "D:\tools\quickStart\idea"
echo Starting mongo...
start "" "D:\tools\quickStart\mongo"
echo Starting navicat...
start "" "D:\tools\quickStart\navicat"
echo Starting SecureCRT...
start "" "D:\tools\quickStart\SecureCRT"
echo Starting xmind...
start "" "E:\desktop\wzh\xxx\xxx.xmind"
echo Starting alwaysup...
start "" "D:\tools\quickStart\alwaysup"
https://blog.csdn.net/qq_31748587/article/details/84138742

win7如何删除开始菜单最近打开文档记录听语音
https://jingyan.baidu.com/article/67508eb4974d3edcca1ce488.html

Win7系统中如何查看最近打开过的文档项目？
右键点击Win7系统的开始按钮，选择属性按钮点击。点击属性按钮后，进入属性界面。
在属性界面点击自定义按钮，进入自定义菜单，在自定义菜单上勾选“最近使用的项目”，然后点击确定按钮。
在开始菜单点击最近使用的项目图标，显示最近打开过的文件。
需要查看最近打开过的所有项目，右键点击最近打开项目的图标。
C:\Users\Wendy\AppData\Roaming\Microsoft\Windows\Recent
https://jingyan.baidu.com/article/67508eb4974d3edcca1ce488.html

查找最近打开的目录或程序

如何查看和删除电脑的各种使用历史记录
四.查看资源管理器地址栏快速打开记录
查看方法：点击地址栏右侧的向下箭头
这里写图片描述
删除方法： 
1.按下 Windows + R ， 输入并执行 regedit ， 打开注册表编辑器 
2.按以下路径展开： HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\TypedPaths 
3.Windows 资源管理器地址栏历史记录会列在以上注册表路径下，不需要的路径删除掉即可。
https://blog.csdn.net/bruce135lee/article/details/79675259

C:\Windows\Prefetch

记录打开的程序或目录

查看电脑使用记录（包括打开过的文件）
C:\Windows\Tasks\SCHEDLGU.TXT
C:\Users\Wendy\Recent Nothings
6、电脑日志记录
开始/控制面板/性能和维护(经典视图里去掉这个)/管理工具/事件查看器，看看里面的记录，或者有比较简单的方法就是在开始里\设置\控制面板\管理工具\事件查看器。这样也能查看
7、查看文档记录
开始→我最近的文档，点开这里就可以查看最近都写了什么文档，看了什么电影、图片。
https://blog.csdn.net/bruce135lee/article/details/79674898

2020.01.02

ATL窗口实现
https://download.csdn.net/download/clever101/4359848

mfc在对话框中创建单文档问题

COM003.Simple.1

com组件对话框

COM组件中显示对话框的资源
https://download.csdn.net/download/yangshusen55/2508773?utm_source=bbsseo

MFC编程 CButton::Create
第四个参数，表示按钮的大小和位置。
CRect(x1,y1,x2,y2)
x1和y1表示按钮左上角坐标
x2和y2表示按钮右下角坐标
所以x2必须大于x1，y2必须大于y1；
你的x都设成了100，按钮的宽度为0了，当然不显示了。
明白了不。
https://zhidao.baidu.com/question/127558261.html

	CRect rect1 ;
	GetClientRect( rect1 ) ;

	//m_pwndBgn->MoveWindow( rect1 ) ;
	//m_pwndBgn->GetClientRect( rect1 ) ;

	CRect rectbtn( rect1 ) ;
	rectbtn.left++ ;  //左上角X位置
	rectbtn.top++ ;   //左上角Y位置
	rectbtn.right  = rectbtn.left+120 ; //右下角 X 位置 // wendy 80
	rectbtn.bottom = rectbtn.top+20 ;  //右下角 Y 位置

	m_pbtnItemCode->Create( "", WS_CHILD|WS_VISIBLE, rectbtn, m_pwndBgn, MACRO_BtnItemCodeID ) ;  // wendy rectbtn rect


m_pbtnItemCode->Create( "", WS_CHILD|WS_VISIBLE, rect, m_pwndBgn, MACRO_BtnItemCodeID ) ;
	ON_BN_CLICKED(MACRO_BtnItemCodeID, OnSelectItemCode)

	CRect rectbtn( rect ) ;
	rectbtn.left++ ;  //左上角X位置
	rectbtn.top++ ;   //左上角Y位置
	rectbtn.right  = rectbtn.left+40 ; //右下角 X 位置 // wendy 80
	rectbtn.bottom = rectbtn.top+20 ;  //右下角 Y 位置
	//m_pbtnItemCode->MoveWindow( rectbtn ) ;//设置位置大小
	int nPreX = rectbtn.right ;	

D:\VC6_SOFT\vc6cn\VC6CN\COMMON\MSDEV98\BIN 覆盖

暂时跳过 直接编辑资源文件改为MS Sans Serif即可 (v ok)

VC6 IDE字体设置增强补丁
DEVSHL.DLL 6.00.8168.2

VC6.0经典字体 Fixedsys字体 MS Sans Serif

D:\Program Files\Microsoft Visual Studio\Common\MSDev98\Bin\MSDEV.EXE属性
VC6产品版本: 6.00.8168.2 (v ok)

vc中如何更改对话框的字体属性
https://jingyan.baidu.com/article/e8cdb32b5a698f37052bad29.html

转载：修改VC++6.0对话框资源字体及大小（不修改源码）
3、打开工程目录下的rcTest.rc文件
搜索“IDD_ABOUTBOX DIALOG DISCARDABLE”，可以看到
CAPTION "关于 rcTest"
FONT 9, "宋体"
https://blog.csdn.net/MOLLY0511/article/details/81062011

vc6 选择对话字体
select dialog font

VC里面大家都喜欢用什么字体？ [问题点数：40分，结帖人HelloDan]
Fixedsys, system ,Arial
Courier New or Courier 是标准答案
https://bbs.csdn.net/topics/320099237

VC++6.0使用非默认字体
近期在使用vc++6.0写C程序
问题：vc++自带的字体不太好看
解决办法：修改注册表
1. win+r 运行 regedit 调出注册表编辑器
进入到目录 HKEY_CURRENT_USER\SOFTWARE\Microsoft\DevStudio\6.0\Format
2.在Format上右键导出


https://blog.csdn.net/qq_21808961/article/details/78191167

VC6.0修改字体（非系统自带的5种字体）
在VC6.0下更改字体，我们一般通过菜单-Tools-Options-Format来更改
但在我的win7 64位系统下这一选项下的字体和字体颜色是空的，无法选择
所以我想起来通过注册表来更改。
Win+R输入“Regedit”，找到“HKEY_CURRENT_USER/Software/Microsoft/DevStudio/6.0”
发现下面没有Format，这也是为什么VC环境中找不到字体的原因，注册表里面都没有该信息
在6.0上右键New-Key（项（K）），给它重命名为“Format”
这里我只要更改编辑源文件窗口和输出窗口的字体
所以在“Format”下面再新建两个New-Key：“Output Window”和“Source Window”，“Workspace Window”
单击“Output Window”后在右侧显示详情区右键New-String Value，命名为“FontFace”
再右键“FontFace”Modify...为“Courier New”
https://blog.csdn.net/pk124729136/article/details/16339609

VC6 IDE字体设置增强补丁 评分:     
适用于版本号6.0.9782.0的devshl.dll。对应MSDEV.EXE版本号为6.0.9782.2
参考moring#pediy的帖子做个一个补丁。
复制到
C:\Program Files\Microsoft Visual Studio\Common\MSDev98\Bin
覆盖同名原文件(DEVSHL.DLL)即可，然后你可以在VC6的字体设置中选择更多的字体。

引用来自：
VC6 IDE字体设置增强
by morning

VC6只枚举系统缺省字符集一致的字体,这导致选择字体时甚为不便.虽然说可以通过修改注册表,直接设置字体,但是总觉得有些遗憾,今天有点时间,就小小patch了
https://download.csdn.net/download/lonmaor/5108632

VC++6.0字体设置工具（完美版）
https://download.csdn.net/download/xd20065401417/3270033

VC6字体列表不全和默认字体修改的补丁
https://download.csdn.net/download/networkdragon/1764649
https://download.csdn.net/download/limotao2011/4909644
https://download.csdn.net/download/u010436145/6595767
VC6 IDE字体设置增强补丁
https://download.csdn.net/download/lonmaor/5108632
手动修改注册表来添加vc6.0的字体
https://download.csdn.net/download/zhouzijian588/4705970

设置VC++6.0字体，非自带字体，可改为任何字体

运行regedit（注册表编辑器），打开 HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format为了方便编写，我们先导出Format，然后修改成下面的样子，只需要改FontFace （字体名称） 这里写你想改成的字体名称
FontSize（字体大小） 0000000a = 10 （学过16进制的我想应该都知道）
设置VC++6.0字体，非自带字体，可改为任何字体
Windows Registry Editor Version 5.00
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format]
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format\Calls Window]
"FontFace"="Courier New"
"FontSize"=dword:0000000a
"Text"=hex:00,00,00,00,ff,ff,ff,00,13,01,b3,00
"Text Selection"=hex:ff,ff,ff,00,00,00,00,00,19,00,19,00
"Calls Highlight"=hex:00,00,00,00,00,ff,00,00,10,00,10,00
"Superceded code"=hex:80,80,80,00,ff,ff,ff,00,10,00,10,00
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format\Disassembly Window]
"FontFace"="Courier New"
"FontSize"=dword:0000000a
"Text"=hex:00,00,00,00,ff,ff,ff,00,13,01,b3,00
"Text Selection"=hex:ff,ff,ff,00,00,00,00,00,19,00,19,00
"Assembly Code"=hex:80,80,80,00,ff,ff,ff,00,10,00,10,00
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format\Memory Window]
"FontFace"="Courier New"
"FontSize"=dword:0000000a
"Text"=hex:00,00,00,00,ff,ff,ff,00,13,01,b3,00
"Text Selection"=hex:ff,ff,ff,00,00,00,00,00,19,00,19,00
"Memory Highlight"=hex:ff,00,00,00,ff,ff,ff,00,10,00,10,00
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format\Output Window]
"FontFace"="Courier New"
"FontSize"=dword:0000000a
"文本"=hex:00,00,00,00,ff,ff,ff,00,15,00,15,00
"文本选择"=hex:ff,ff,ff,00,00,00,00,00,19,00,19,00
"当前错误/标记"=hex:ff,ff,ff,00,00,00,80,00,55,00,55,00
"书签"=hex:00,00,00,00,00,ff,ff,00,10,00,10,00
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format\Registers Window]
"FontFace"="Courier New"
"FontSize"=dword:0000000a
"Text"=hex:00,00,00,00,ff,ff,ff,00,13,01,b3,00
"Text Selection"=hex:ff,ff,ff,00,00,00,00,00,19,00,19,00
"Value Highlight"=hex:ff,00,00,00,ff,ff,ff,00,10,00,10,00
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format\Source Browser]
"FontFace"="Courier New"
"FontSize"=dword:0000000a
"文本"=hex:00,00,00,00,ff,ff,ff,00,15,00,15,00
"文本选择"=hex:ff,ff,ff,00,00,00,00,00,19,00,19,00
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format\Source Window]
"FontFace"="Courier New"
"FontSize"=dword:0000000a
"文本"=hex:00,00,00,00,ff,ff,ff,00,13,01,b3,00
"文本选择"=hex:ff,ff,ff,00,00,00,00,00,19,00,19,00
"当前错误/标记"=hex:ff,ff,ff,00,00,00,80,00,d2,01,b2,01
"书签"=hex:00,00,00,00,00,ff,ff,00,10,00,10,00
"断点"=hex:ff,ff,ff,00,80,00,00,00,10,00,10,00
"当前声明"=hex:00,00,00,00,ff,ff,00,00,70,00,70,00
"选择边距"=hex:d4,d0,c8,00,d4,d0,c8,00,13,00,13,00
"关键字"=hex:00,00,ff,00,ff,ff,ff,00,10,00,11,00
"注释"=hex:00,80,00,00,ff,ff,ff,00,10,00,11,00
"Number"=hex:00,00,00,00,ff,ff,ff,00,11,00,11,00
"String"=hex:00,00,00,00,ff,ff,ff,00,11,00,11,00
"操作员"=hex:00,00,00,00,ff,ff,ff,00,11,00,11,00
"Wizard IDL/ODL Code"=hex:80,80,80,00,ff,ff,ff,00,14,00,15,00
"HTML Element Name"=hex:80,00,80,00,ff,ff,ff,00,14,00,15,00
"HTML Attribute Name"=hex:ff,00,00,00,ff,ff,ff,00,14,00,15,00
"HTML Attribute Value"=hex:00,00,ff,00,ff,ff,ff,00,14,00,15,00
"HTML Comment"=hex:00,80,00,00,ff,ff,ff,00,14,00,15,00
"HTML Entity"=hex:ff,00,00,00,ff,ff,ff,00,14,00,15,00
"HTML Tag Delimiter"=hex:00,00,ff,00,ff,ff,ff,00,14,00,15,00
"HTML String"=hex:00,00,ff,00,ff,ff,ff,00,14,00,15,00
"HTML Tag Text"=hex:ff,00,ff,00,ff,ff,ff,00,14,00,15,00
"HTML Operator"=hex:00,00,ff,00,ff,ff,ff,00,14,00,15,00
"HTML Server-Side Script"=hex:00,00,00,00,ff,ff,00,00,14,00,14,00
"User Defined Keywords"=hex:00,00,ff,00,ff,ff,ff,00,14,00,15,00
"Wizard Code"=hex:80,80,80,00,ff,ff,ff,00,14,00,15,00
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format\Variables Window]
"FontFace"="Courier New"
"FontSize"=dword:0000000a
"Text"=hex:00,00,00,00,ff,ff,ff,00,13,01,b3,00
"Text Selection"=hex:ff,ff,ff,00,00,00,00,00,19,00,19,00
"Variables Highlight"=hex:ff,00,00,00,ff,ff,ff,00,10,00,10,00
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format\Watch Window]
"FontFace"="Courier New"
"FontSize"=dword:0000000a
"Text"=hex:00,00,00,00,ff,ff,ff,00,13,01,b3,00
"Text Selection"=hex:ff,ff,ff,00,00,00,00,00,19,00,19,00
"Watch Highlight"=hex:ff,00,00,00,ff,ff,ff,00,10,00,10,00
[HKEY_CURRENT_USER\Software\Microsoft\Devstudio\6.0\Format\Workspace Window]
"FontFace"="Courier New"
"FontSize"=dword:0000000a
4
重新打开VC++6.0，是不是变的比较美观了
https://jingyan.baidu.com/article/90808022f9bedcfd91c80f20.html

?方法一: 1、解压文件,双击MS Sans Serif.fon文件; 2、放到【C:\Windows\Fonts】路径; 3、打开可以切换字体的软件,如Word、笔记本等,即可使用。
?方法二: 1、在本页直接下载这款字体,对下载好的字体压缩包进行解压处理; 2、直接双击运行字体文件,打开之后点击上方的安装按钮; 3、等待字体安装完毕,打开Word找到该字体即可使用。
MS Sans Serif.fon 如何安装字体 百度

IDD_FORMVIEW_ItemList DIALOGEX 0, 0, 225, 316
STYLE WS_CHILD
EXSTYLE WS_EX_NOPARENTNOTIFY
FONT 8, "MS Sans Serif", 0, 0, 0x1

IDD_FORMVIEW_ItemList DIALOG DISCARDABLE  0, 0, 187, 96
STYLE WS_CHILD
FONT 10, "System"
BEGIN
    CONTROL         "List1",IDC_LIST_Item,"SysListView32",LVS_REPORT | 
                    LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_SORTASCENDING | 
                    WS_BORDER | WS_TABSTOP,7,7,173,82
END

2019.12.31

一步搞定Beyond Compare文件乱码(v ok)
方法一：进行会话设置（仅用于本次会话）

步骤一打开文本比较会话界面，在“会话”菜单下选择“会话设置”选项卡；

步骤二切换到“格式”页面，在左侧编码重写和右侧编码覆盖选择 GB2312/UTF-8/GBK，选择完毕后，单击确定关闭窗口，完成设置。
方法二：文件格式（永久配置）

步骤一打开文本比较会话界面，在“工具”菜单下选择“文件格式”选项；

步骤二打开文件格式对话框转换窗口，在该窗口下面的编码选项里设置编码方式，然后点击保存即可。

http://www.sohu.com/a/117100747_200939

#define new DEBUG_NEW

使用方式：

在stdafx.h中包含头文件

在要用诊断机制的文件中加入如下的代码。
#ifdef _DEBUG
#define new DEBUG_NEW
#endif

这样不管是new申请的内存泄漏，还是malloc申请的内存泄漏在程序正常退出后都会输出在Debug窗口里。而且都会显示完整文件路径、行数、泄漏字节数。

https://www.cnblogs.com/lisuyun/p/5744548.html


C++中析构函数为虚函数
1、析构函数是否定义为虚函数的区别

（1）析构函数定义为虚函数时：基类指针可以指向派生类的对象（多态性），如果删除该指针delete []p；就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。

（2）析构函数不定义为虚函数时：编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。

5、基类析构函数定义为虚函数的情况

        如果不需要基类对派生类及对象进行操作,则不能定义虚函数,因为这样会增加内存开销.当类里面有定义虚函数的时候,编译器会给类添加一个虚函数表,里面来存放虚函数指针,这样就会增加类的存储空间。所以,只有当一个类被用来作为基类的时候,并且有使用到基类指针操作派生类的情况时，才把析构函数写成虚函数。

https://blog.csdn.net/King_weng/article/details/89263215


为什么构造函数不能声明为虚函数？

1.创建一个对象必须明确指出它的类型，否则无法创建，一个对象创建成功编译器获得它的实际类型，然后去调用对应的函数，而如果构造函数声明为虚函数，会形成一个死锁，虚函数是在运行才能确定确定其调用哪一个类型的函数，而具体哪一个类型是编译器通过对象的类型去确定的，但是此时对象还未创建也就没法知道其真实类型。

2.虚函数对应一张虚函数表，这个虚函数表是存储在对象的内存空间的，如果构造函数是虚函数就需要通过虚函数表来调用，可是对象还没有实例化，也就是内存空间还没有，找不到虚函数表，所以构造函数是不能声明为虚函数的。

https://www.cnblogs.com/wuyepeng/p/9882289.html


股票价格估值DPS
投融界为你提供股票价格估值DPS相关报道、相关新闻、相关动态，如果你想要了解股票价格估值DPS找项目，股票价格估值DPS相关资金项目介绍，就上投融界！这里拥有海量的投资融资项目合作信息,是专业的融资服务平台。
https://www.trjcn.com/tags/1569295/

EPS
每股收益即每股盈利（EPS），又称每股税后利润、每股盈余，指税后利润与股本总数的比率。
https://baike.baidu.com/item/%E6%AF%8F%E8%82%A1%E6%94%B6%E7%9B%8A/2429458?fromtitle=EPS&fromid=10928288&fr=aladdin

GetOEMCP(v ok)
VB声明
Declare Function GetOEMCP Lib "kernel32" Alias "GetOEMCP" () As Long
说明
判断在OEM和ANSI字符集间转换的windows代码页
返回值
Long，目前处于活动状态的OEM代码页的标识符。针对一种特定的语言，可能存在多个代码页。以下是可用代码页列表
437
默认：美国
708-720
阿拉伯代码页
737
希腊
775
波罗的
850
国际
852
Slavic
855
西里尔语
857
土耳其语
860
葡萄牙语
861
冰岛语
862
希伯来语
863
加拿大法语
864
阿拉伯语
865
挪威/丹麦语
866
俄语
874
泰语
932
日语
936
中文（简体）
949
朝鲜语
950
中文（台、港繁体）
1361
朝鲜语
http://www.office-cn.net/t/api/getoemcp.htm

VC如何创建没有基类的类(v ok)
很简单。
点Class View在最上面的***.classes上面点右键选New Class，
然后在Class type里选generic class，这样你新建的类就没基类了。
https://zhidao.baidu.com/question/127700748.html


IGPEditor_hwdDoc.cpp(59) : error C2079: 'c_file' uses undefined struct '_finddata_t'(v ok)
#include <io.h>

上传时间：2017-02-20 所需积分/C币： 
这个有点不明白了，你下架就下架吧，扣分的理由是什么呢？
这是2017年上传的,现在2019年底来扣我100分呀？

我只是修改个下载所需积分就要重新审核了？
积分里有反动内容还是有违犯法律条例的东西在里面了呢？呵呵。


舍本求末;本末倒置

这个问题必须从根本上加以解决，头痛医头，脚痛医脚，总不是个办法。
正本清源
https://www.cidianwang.com/cy/t/toutongyitoujiaotongyijiao363.htm

很遗憾，你上传的VC6功能完整版本安装后有插入ATL对象菜单项 没有通过审核，已被删除,原因是：资源违规，如有疑问，请联系webmaster@csdn.net
前几天上传的资源通过了审核,昨晚就仅仅是修改个下载所需积分从免费改为1分。然后就审核不通过了，这是怎么回事呢？

你上传的资源没有通过审核vc6.0 免安装 绿色版 兼容win7 vc助手1小时前
很遗憾，你上传的vc6.0 免安装 绿色版 兼容win7 vc助手 没有通过审核，已被删除,原因是：资源违规，如有疑问，请联系webmaster@csdn.net
之前一直好好的资源，也是只修改个下载所需积分就不能通过审核了。这太不合理了吧。
上一封 下一封


vc++ 整型 最大值
	if (ntimes >= INT_MAX) ntimes = 0;
https://zhidao.baidu.com/question/383761125.html

windows API 第八篇 _tcsicmp _stricmp _wcsicmp _mbsicmp
wchar_t szStr1[] = "asdfg";
wchar_t szStr2[] = "AsDfG";
int nResult = _wcsicmp(szStr1, szStr2);      //nResult = 0
https://blog.csdn.net/weixin_34202952/article/details/93466664

#include <string.h>
_tcsicmp

strcmp|wcscmp 与 stricmp|wcsicmp
区分大小写：

1、strcmp

????? 这是用于ANSI标准字符串的函数(如string和char *)，此函数接受两个字符串缓冲区做为参数，如果两个字符串是相同的则返回零。否则若第一个传入的字符串的值大于第二个字符串返回值将会大于零，若传入的第一个字符串的值小于第二个字符串返回值将小于零。


char *ch="test";
if(strcmp(ch,"TeSt")==0)
{
    //字符串相等
}
else
{
    //字符串不相等
}
?
2、wcscmp

????? 这个函数是strcmp所对应的Unicode系列的函数，它的使用方法和strcmp相同，它用来比较两个Unicode字符串是否相等(如wstring和wchar_t *)。


wchar_t *ch=L"NewString";
if(wcscmp(ch,L"newstring")==0)
{
    //字符串相等
}
else
{
    //字符串不相等
}

不区分大小写：

1、stricmp

????? 这是用于ANSI标准字符串的函数(如string和char *)，此函数接受两个字符串缓冲区做为参数，如果两个字符串是相同的则返回零，不区分大小写。否则若第一个传入的字符串的值大于第二个字符串返回值将会大于零，若传入的第一个字符串的值小于第二个字符串返回值将小于零。


char *ch="AbcD";
if(stricmp(ch,"aBCd")==0)
{
    //字符串相等
}
else
{
    //字符串不相等
}

2、wcsicmp
????? 这个函数是stricmp所对应的Unicode系列的函数，它的使用方法和stricmp相同，它用来比较两个Unicode字符串是否相等，不区分大小写(如wstring和wchar_t *)。

wchar_t *ch=L"AbcD";
if(wcsicmp(ch,L"aBCd")==0)
{
    //字符串相等
}
else
{
    //字符串不相等
}

――――――――――――――――
版权声明：本文为CSDN博主「hellokandy」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/hellokandy/article/details/52161852

区分大小写
这个函数是strcmp所对应的Unicode系列的函数，它的使用方法和strcmp相同，它用来比较两个Unicode字符串是否相等(如wstring和wchar_t *)。
wchar_t *ch=L"NewString";
if(wcscmp(ch,L"newstring")==0)
{
    //字符串相等
}
else
{
    //字符串不相等
}


不区分大小写
这个函数是stricmp所对应的Unicode系列的函数，它的使用方法和stricmp相同，它用来比较两个Unicode字符串是否相等，不区分大小写(如wstring和wchar_t *)。
wchar_t *ch=L"AbcD";
if(wcsicmp(ch,L"aBCd")==0)
{
    //字符串相等
}
else
{
    //字符串不相等
}


https://blog.csdn.net/hellokandy/article/details/52161852?utm_source=blogxgwz8

windows API 第八篇 _tcsicmp _stricmp _wcsicmp _mbsicmp
https://blog.csdn.net/weixin_33946605/article/details/93257253

常用的字符串处理函数和宏
http://www.cppblog.com/xyjzsh/archive/2010/10/15/130044.html

MIDL示例
cpp_quote：指导MIDL编译器将限定了的字符串转换成生成的头文件。具体来说，这四行会在MIDL编译器生成的头文件中做出C++的注释。
https://www.xuebuyuan.com/1194141.html

cpp_quote

2019.12.30

CTTOptions::CTTOptions() 
{

	CLogout("CTTOptions::CTTOptions() b \r\n");
...
	m_pwndBgn = new CwndBgn() ;
	ASSERT( m_pwndBgn!=NULL ) ;
...}

LRESULT CTTOptions::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
	// TODO : Add Code for message handler. Call DefWindowProc if necessary.
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	RECT rect ;
	CLogout("CTTOptions::OnCreate() b \r\n");
	m_pwndBgn->Create( CwndBgn::m_strMyClass, NULL, WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN , rect, CWnd::FromHandle(m_hWnd), NULL ) ;
...}

wndBgn.cpp
CwndBgn::~CwndBgn()
{
}
BEGIN_MESSAGE_MAP(CwndBgn, CWnd)
	//{{AFX_MSG_MAP(CwndBgn)
	ON_WM_PAINT()
	ON_WM_CTLCOLOR()
	//}}AFX_MSG_MAP
	ON_BN_CLICKED(MACRO_BtnItemCodeID, OnSelectItemCode)


void CwndBgn::OnSelectItemCode() 
{
	if( m_pOwner!=NULL )
	{
		m_pOwner->m_bSelectWin = 0;
		m_pOwner->OnSelectItemCode() ;
	}

}

新视图->期权->左上角按钮单击响应的函数如下:
[17:01:16.653]:CTTOptions::OnSelectItemCode()  
void CTTOptions::OnSelectItemCode()
{
	CLogout("CTTOptions::OnSelectItemCode()  \r\n");
...}



listctrlOptions.cpp
UINT ColorThread(LPVOID  lParam)  //检查字体颜色的线程函数
{
	//CoInitializeEx(NULL,COINIT_MULTITHREADED);
	ClistctrlOptions * pclass;
	pclass=(ClistctrlOptions *)lParam;
	int iCount = 0;
	int iCount2 = 0;
	while (pclass->m_bStopColorThread == FALSE)
	{
		Sleep(50);
		iCount++;
		iCount2++;
		if(iCount >= 20) //1秒判断一次
...}

BIN为后缀名的文件是什么文件啊
.bin是二进制文件，其用途依系统或应用而定
bin有多种含义，包括虚拟光驱格式.bin，用于科研计算的数据格式为bin格式。另外，FTP 在传送文件时分为ASC 和 Bin 两种格式，只有文字文件 (例如 html 文件) 使用 ASC，其他的通通使用 Bin 格式 (例如图像文件、压缩文件、可执行文件等等)。 
一般来说，常见的虚拟光驱格式。建议你使用WINISO。WinISO是一款功能强大的镜像文件处理工具，它可以从CD-ROM中创建ISO镜像文件，或将其他格式的镜像文件转换为标准的ISO格式，还可以轻松实现镜像文件的添加、删除、重命名、提取文件等操作。 
PC上常见的bin如果很大的多半是光盘镜像，1.44M左右的可能是软盘镜像。小于1M的可能是主板BIOS的程序。
嵌入式开发里面交叉编译出来通常是个bin，烧到板子去用的。
一切的bin都能用16进制编辑器打开
https://iask.sina.com.cn/b/iR1ayX5UMLKf.html


HRESULT CTTOptions::WriteLogFile(LPTSTR strLog)
{

	CLogout("CTTOptions::WriteLogFile()  \r\n");

	char strTime[100];
	SYSTEMTIME sysTime;
	GetLocalTime(&sysTime);

	HANDLE m_hLogFile;
	char strFileDir[200];
	char strTemp[50];
	sprintf(strTemp,"\\W2TOptionsIV-%04d%02d%02d.LOG",sysTime.wYear,sysTime.wMonth,sysTime.wDay);
...}

/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Nov 24 11:34:50 1999
 */
/* Compiler settings for C:\MWTT\MAS\MAS.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/

printf(" TEST_printf() \r\n");v
ATLTRACE("TEST_ATLTRACE() \r\n");
TRACE( "TEST_TRACE()\r\n" ) ;


删除文件 - G:\Tele-Trend\system\desktop\_g_charting.dsk
删除文件 - G:\Tele-Trend\system\desktop\_g_pf_aud.dsk
删除文件 - G:\Tele-Trend\system\desktop\_g_pf_white.dsk
删除文件 - G:\Tele-Trend\system\desktop\_g_pf_{aud}.dsk
删除文件 - G:\Tele-Trend\system\desktop\_g_pf_{white}.dsk
找不到 G:\Tele-Trend\HISTORYDATA\*.his
[13:44:44.751]:CTTOptions::GetExpiryTime()
[13:44:44.757]:CTTOptions::GetExpiryDays()

printf("%s", szMsg);

ATLTRACE("OnMySetItemsTotal \r\n");

TRACE( "tool_Icon create faile!\r\n" ) ;

logfile.h
// Debug版本宏1
#define _FLAG_OUTLOG_ENABLE TRUE // wendy add

D:\Program Files\Microsoft Visual Studio\MyProjects\CallOptions\Debug

#import "G:\Tele-Trend\bin\Options.dll" no_namespace (v ok)

void CCallOptionsDlg::OnButton1() 
{
	CoInitialize(NULL);
	
	CLSID clsid;
	
	HRESULT hr ;
	// Looks up a CLSID in the registry, given a ProgID.
	hr = CLSIDFromProgID(OLESTR("Options.TTOptions.1"),&clsid);
	
	if(S_OK !=hr )
		return;

	ITTObject* pInterf = NULL; //Interface Pointer 
	
	hr = CoCreateInstance(clsid,
		NULL,
		CLSCTX_INPROC_SERVER,
		__uuidof(ITTObject),
		(LPVOID*)&pInterf);
	
	if(pInterf->InitObject() != S_OK)  // 2708
	{
			printf("no do InitObject");
	}
	else
	{
			printf("ok do InitObject");
	}

	if(pInterf->Activate(1) != S_OK)  // 2708
	{
			printf("no do InitObject");
	}
	else
	{
			printf("ok do InitObject");
	}

	VARIANT var;
	var.vt = 13;
	VARIANT *pVar = &var;
	if(pInterf->GetByID(1021,&pVar) != S_OK)  // 2708
	{
			printf("no do GetByID");
	}
	else
	{
			printf("ok do GetByID");
	}


	CoUninitialize();
}

G:\Tele-Trend\bin\w2t.exe
G:\Tele-Trend\bin\

2019.12.27

WINCORE.CPP  894

CTTOptions::CTTOptions() 
{
	m_nColorMode = 2;  //颜色  0白色   1黑色   2彩色//wendy test
...}



ItemOptions* m_pDataBuf ;	//
CTTOptions* m_TTOptions;

	theta = theta/(365.0*conversionRatio) ;	// paul, 2008-4-30
											// ben 2017.6.29   252改为365

	double rho  =  ( bCallOption==TRUE ) ? 
						X*T_t*pow( MathE, -1.0*r*T_t )*N_d2/conversionRatio :
						-1.0*X*T_t*pow( MathE, -1.0*r*T_t )*( 1.0 - N_d2 )/conversionRatio ;


// ben 2017.6.29   252改为365
//cove	add 2019.07.08
//andy add 2003.02.13 for future always display first month
2002.07.11 create
char* CTTOptions::MakeFutCode( char* pEchoItemCode, char* pTitleCode, int nMM, int nYY )
{

	m_bUseNtMth = FALSE;

	//andy add 2003.02.13 for future always display first month
	memset(pEchoItemCode,' ',G_GENCODELEN);
...}


ClearData(); //ResetTable();  andy modify 20090507

int CStrategy::DrawIncomeLine() 5千 10309 - 4941 = 5368行画图代码

void CStrategy::OnMouseMove(UINT nFlags, CPoint point) 
{
	if( m_bMode==1 )
		return;
	CRect frmrect;
	m_frame.GetWindowRect(&frmrect);
	ScreenToClient(&frmrect);	
	int nCount = m_arrPL[0].GetSize();
	CRect rct(frmrect.left,frmrect.top+35,frmrect.right,frmrect.bottom-40);
	if( rct.PtInRect(point) && m_nRetn==1 && nCount!=0 && m_bDrawing==FALSE )
	{
		if( (m_bSelectLo || m_bSelectUp) && m_btMouseGet==1 && m_btMouseRelease==0 )
		{
			m_hCursor = LoadCursor(NULL,IDC_CROSS);
		}
		else
			m_hCursor = LoadCursor(NULL,IDC_ARROW);
		m_point = point;
		m_bPainted = FALSE;
		DrawIncomeLine();
	}
...}

option （期权） 编辑 讨论
Option中文译为期权，又称为选择权，是在期货的基础上产生的一种衍生性金融工具。
从其本质上讲，期权实质上是在金融领域中将权利和义务分开进行定价，使得权利的受让人在规定时间内对于是否进行交易，行使其权利，而义务方必须履行。在期权的交易时，购买期权的一方称作买方，而出售期权的一方则叫做卖方；买方即是权利的受让人，而卖方则是必须履行买方行使权利的义务人。
https://baike.baidu.com/item/option/1171193?fr=aladdin
期权具“零和游戏”特性，而个股期权及指数期权皆可组合，进行套利交易或避险交易。
期权主要可分为买方期权（Call Option）和卖方期权（Put Option），前者也称为看涨期权或认购期权，后者也称为看空期权或认沽期权

Options.TTOptions.1
492E31D3-B80D-11D3-AF24-00A0CC23E698
492E31C6-B80D-11D3-AF24-00A0CC23E698
492E31D4-B80D-11D3-AF24-00A0CC23E698

\CallOptionsDlg.cpp(221) : error C2787: 'ITTOptions' : no GUID has been associated with this object

CallOptionsDlg.cpp(179) : error C2065: 'IFirstInterface' : undeclared identifier
interface ITTOptions : IDispatch (v ok)

CallOptionsDlg.cpp(201) : error C2059: syntax error : '{'
CLSID clsid;
clsid = {0x492E31D3,0xB80D,0x11D3,{0xAF,0x24,0x00,0xA0,0xCC,0x23,0xE6,0x98}};
CLSID clsid = {0x492E31D3,0xB80D,0x11D3,{0xAF,0x24,0x00,0xA0,0xCC,0x23,0xE6,0x98}}; (v ok)

IDD_STRATEGY

电脑右下角显示星期，选中日期右键调整日期/时间-更改日期和时间...更改日历设置-区域和语言-格式 
日期和时间格式 其它设置...自定义格式 yyyy/M/d dddd (v ok)

492E31D3-B80D-11D3-AF24-00A0CC23E698 - ITTOptions

太极软件-新视窗-期权(v ok)

工程-设置-连接-输出文件名 (v ok)

CoInitialize

需要为控件工具栏按钮ID_GROUP_ADDITEM增加响应函数才会显示图标(v ok)

Microsoft Office 2013安装与激活
https://blog.csdn.net/qq_37798548/article/details/95317354


32位win7系统安装office2013以及破解
https://blog.csdn.net/willie_chen/article/details/49683303?utm_source=blogxgwz9
Microsoft Toolkit.exe
打开之后这个界面，这个界面不要动。看到左上角Main了么?单击右边的Activation。
大家来到这个界面第一件事是点击Install。完成后!
最重要的一步：点击右边绿色的EZ-Activator。大功告成。快去看吧~是不是破解成功了。


D:\Program Files\Microsoft Visual Studio\VC98\MFC\SRC\VIEWCORE.CPP
BOOL CView::OnSplitCmd(UINT) F5->F10调试进去.

MainFrm.cpp(126) : error C2664: 'CreateEx' : cannot convert parameter 1 from 'const int' to 'class CWnd *'
#define this                            32772 导致

手动修改文件和VC6加菜单资源两种方式.(v ok)
手动
Resource.h IGPEditor_hwd.rc 
#define ID_ADDMENU_TEST                 32771
MENUITEM "addmenu_test",                ID_ADDMENU_TEST
    POPUP "编辑(&E)"
    BEGIN
        // wendy del MENUITEM "撤消(&U)\tCtrl+Z",            ID_EDIT_UNDO
        // wendy del MENUITEM SEPARATOR
        // wendy del MENUITEM "剪切(&T)\tCtrl+X",            ID_EDIT_CUT

VC6
ResourceView Menu 选中菜单右击属性(分隔符或弹出)填写ID和字符 或按键盘Delete键删除菜单




D:\Program Files\Microsoft Visual Studio\MyProjects\IGPEditor_hwd\MainFrm.cpp(116) : error C2611: '~' : illegal following '~' (expected identifier)
D:\Program Files\Microsoft Visual Studio\MyProjects\IGPEditor_hwd\MainFrm.cpp(116) : error C2588: '::~CMainFrame' : illegal global destructor
52936(HZ-GB2312简体中文)会出错 no

[图]捷利资讯执行董事陈玉炯
https://finance.qq.com/a/20100423/007002.htm

// wendy b
// wendy e

Beyond Compare乱码问题这样就能解决(v ok)  
00936 (ANSI/OEM - 简体中文 GBK) ok
20936 (简体中文 GB2312) ok
54936 (GB18030 简体中文) ok
52936(HZ-GB2312简体中文)会出错 no
65001(UTF-8) or UTF-8 会出错 no
文本比较乱码
当使用Beyond Compare软件比较文本文件时，明明在项目里面是对的，可是用Beyond Compare 打开之后就会出现乱码，内容完全错误。
解决方法：
步骤一：在已经打开的Beyond Compare文本比较会话中，单击工具栏“会话”按钮，在展开的菜单中选择“会话设置”选项，并切换到“格式”选项卡页面。
步骤二：在界面“左边编码重写”和“右边编码覆盖”栏目中选择 GB2312/UTF-8/GBK，当然这个也可以根据自己喜好和文本自身的encode选择。
步骤三：单击“确定”按钮完成比较文本的编码设置，再次回到文本比较会话即可进行正常的文本比较工作。
https://blog.csdn.net/weixin_34198453/article/details/91910432
转载于:https://my.oschina.net/navicat/blog/707700
可以关注相关的Beyond Compare教程 http://www.beyondcompare.cc/support.html


了解TSCI - Thermotec Sistemas de Combust?o Industrial的最新动态

tele-trend  添加释义
网络释义

  环球快车
...应用标题 东方(香港)环球快车(Tele-Trend) 应用描述 东方(香港)环球快车iOS版是东方证券(香港)有限公司全新打造的一款国际化、专业化的iOS证券交易终端，提供最及时的沪深...
基于8个网页-相关网页
  港股快车
金(香港)港股快(Tele-Trend)应用说明 金C券(香港)有限公司之金(香港)港股快，橛籼峁└加方便和全面的Y料及Y服眨投Y者不管身在何都可以...
基于4个网页-相关网页
短语
Tele-Trend Limited 捷利资讯有限公司 ; 香港捷利信息有限公司
http://dict.youdao.com/w/tele-trend/


VC6 关键字蓝色如何改
https://zhidao.baidu.com/question/503043114.html
vc ++6.0中程序关键字不变蓝色，全部都是黑色的。程序可以正常运行。上面说的改format的方法没用。
你说的是一个叫visual assisx X 插件的功能,VC6自己是不会变蓝的.(v ok)


CSplitterWnd类分割MFC单文档应用程序窗口
https://blog.csdn.net/m_buddy/article/details/50803102

F5运行，重试自由定位到问题点上。(v ok)
D:\Program Files\Microsoft Visual Studio\VC98\MFC\SRC\VIEWFORM.CPP
#ifdef _DEBUG
	// dialog template must exist and be invisible with WS_CHILD set
	if (!_AfxCheckDialogTemplate(m_lpszTemplateName, TRUE))
	{
		ASSERT(FALSE);          // invalid dialog template name
		PostNcDestroy();        // cleanup if Create fails too soon
		return FALSE;
	}
#endif //_DEBUG

viewform.cpp , line 69 
原因是 CFormView 的导出类，需要与一个Dialog资源关联，这个Dialog的属性必须是ws_child，Style必须选 “下层”SystemMenu和TitleBar属性最好都设为False
参见 http://www.cnweblog.com/vcbird/archive/2005/10/10/36404.html
https://blog.csdn.net/u011514451/article/details/49174797

注：还有一种方法就是在添加Dialog资源时，在Dialog列表上点右键->添加资源，
选择Dialog->IDD_FORMVIEW,再点“新建”按钮，这样新建出来的Dialog属性就会自动配好了
http://www.cnweblog.com/vcbird/archive/2005/10/10/36404.html
如何导入对话框资源从一个项目到另一个项目使用 Visual C++.NET 或 Visual C
http://blog.sina.com.cn/s/blog_b646fbcf0102w7it.html

viewform.cpp 69
是AfxCheckDialogTemplate这个验证失败，CFormView类关联的对话框资源必须具有Child属性，(v ok)
打开你用来和CFormView关联的对话框属性页面，在Style里面选择Child再试试。
http://blog.sina.com.cn/s/blog_6a5aef5e0102uztp.html

Beyond Compare 修改保存提示: This file contains Unicode characters that will be lost if it is saved using
the current encodeing. 编码选改为UTF-8保存即可(v ok)

任务栏按钮:当任务栏被占满时合并(v ok)

通过比对修改后用unicode格式保存VC6会显示读取二进制文件出错。
用utraedit32打开后另存为格式为ansi/ascii(DOS)后可正常读取.(v ok)

win7 activation(win7激活工具) v2.6 绿色版 (v ok)
http://www.downcc.com/soft/5435.html
此windows副本不是正版怎么解决

Uedit32.zip
https://download.csdn.net/download/messeager5/10232684

source Insight3.0
https://download.csdn.net/download/ccm163/4194046

c6.0 免安装 绿色版 兼容win7 vc助手
https://download.csdn.net/download/hixi2007/9758584

beyond compare3 序列号
sl2T62PGJWHyemKxBS0+G94HyBMAN+qAvdqWlYaw1hN3VkAtOdqDYsDkmi9451fK9567RIt8sb85UwjEm5vb2tJzJXE6YVapYW7f+tRRXRFI4yn4NjjZ0RiiqGRCTVzwComUcXB-eiFWRBY6JpSsCNkmIxL5KsRCo442djHhTZE+
――――――――――――――――
版权声明：本文为CSDN博主「dlfgh」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/sinat_29891353/article/details/88994831

BCompare-zh-3.3.8.16340
https://download.csdn.net/download/jiejieforupdate/7440599

首页- 应用软件- 文件管理 - Beyond Compare3绿色破解版下载
https://www.newasp.net/soft/15746.html

oem7 编辑
Oem7是一款易用的windows7激活工具，采用一键式激活，人性化设计，所有激活软件中激活率最高。使用Oem7windows7激活软件windows7后是永久激活,和正版一样,可以自动更新,可以通过微软正版验证 [1]  。
https://baike.baidu.com/item/oem7/10013435?fr=aladdin

用电脑管家中的软件管理找到编程软件"Microsoft .NET Framework 4.6.1" 单独安装 (v ok)

net framework 4安装未成功，原因是hresult 0x80240037 是怎么回事啊
https://zhidao.baidu.com/question/814177706745454532.html


Windows 7安装.net framework 4 安装
https://blog.csdn.net/kingepoch/article/details/8817936

注册表,
HKEY_LOCAL_MACHINE\SOFWARE\Microsoft\Internet Explorer下
MAIN子键的权限问题,改成"允许完全控制"
https://zhidao.baidu.com/question/379292948.html?sort=11&rn=5&pn=0#wgt-answers

https://blog.csdn.net/gtatcs/article/details/8769787
.net framework 4.0 0xc8000247错误解决

SoftwareDistribution

Microsoft .NET Framework 4: [2] Error code -2145124297 for this component is not recognized.

安装visual studio 2010到framework 4总是失败
https://zhidao.baidu.com/question/569005009.html

安装visual studio 2010到framework 4总是失败
这是截图

错误日志在下面
[07/08/13,14:29:54] setup.exe: [2] ISetupComponent::Pre/Post/Install() failed in ISetupManager::InternalInstallManager() with HRESULT -2147467259.***EndOfSession***[07/08/13,15:14:45] Microsoft .NET Framework 4: [2] Error code -939523550 for this component is not recognized.[07/08/13,15:14:45] Microsoft .NET Framework 4: [2] Component Microsoft .NET Framework 4 returned an unexpected value.[07/08/13,15:14:46] VS70pgui: [2] DepCheck indicates Microsoft .NET Framework 4 is not installed.[07/08/13,15:14:46] VS70pgui: [2] DepCheck indicates Microsoft .NET Framework 4 简体中文语言包 was not attempted to be installed.
对了我单独安装framework 4的时候也失败了，出现HRESULT 0xc8000222错误代码

 我来答 分享 举报 浏览 4714 次
2个回答 #活动# 请回答2019，答题瓜分百万现金
lt8799  
推荐于2018-03-13
翻译：主要原因是windows update的临时文件损坏 建议重命名该文件夹
步骤 1.开始----- 运行------- cmd ----- 键入net stop WuAuServ回车（停止windows update服务）
2.开始----- 运行----键入%windir%回车（打开系统目录）
3.将SoftwareDistribution文件夹重命名为SDold
4.开始----- 运行------- cmd ----- 键入net start WuAuServ回车
5.可以正常安装.net了
 19     评论(2) 分享 举报

leiyangbdwk  
2013-07-11
有很多人遇到过你那个错误，我本人也遇到过，而且根据如下的办法也解决了。
安装不了的原因很有可能是你的操作系统是Ghost版本的。
http://wenku.baidu.com/view/484102e16294dd88d0d26b99.html
另外，如果你遇到其他问题，请把你的错误号百度一下，没准就可以搜到解决办法。

C#

域服务器windows 2008 Server, IP 10.10.1.2
把Win7无法加入域的电脑DNS配置成10.10.1.2，即可。
https://zhidao.baidu.com/question/405352662.html


win7下怎么配置ODBC数据源
我的系统是win7旗舰版的，找了半天也没有找到控制面板中的额管理工具--数据源，后来上网查了之后发现win7不是这样打开ODBC数据源管理器的，打开ODBC数据源管理器的方法是在cmd命令框中输入odbcad32之后会打开管理器。

1.Win+R-àodbcad32

2.点‘添加’

3.测试

之后的步骤都和XP下相同了。

也可以在桌面最下方右键---属性---开始菜单---自定义---系统管理工具---在“所有程序”菜单和【开始】菜单上显示，然后在开始中就可以看到管理工具了。之后使用方法和XP中相同。
――――――――――――――――
版权声明：本文为CSDN博主「gukesdo」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/gukesdo/article/details/6873445
https://blog.csdn.net/gukesdo/article/details/6873445